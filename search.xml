<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>leetcode 150. Evaluate Reverse Polish Notation</title>
      <link href="/2019/07/25/leetcode-150-Evaluate-Reverse-Polish-Notation/"/>
      <url>/2019/07/25/leetcode-150-Evaluate-Reverse-Polish-Notation/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="150"><li>Evaluate Reverse Polish Notation:<a href="https://leetcode.com/problems/evaluate-reverse-polish-notation/" target="_blank" rel="noopener">题目链接</a></li></ol><p><strong><code>AC code:</code></strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">基本思想：因为已经是后缀表达式了，遍历给出的表达式，遇到数字进栈，遇到符号出栈两个数进行运算再存入栈中，最后栈顶元素就是答案</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">evalRPN</span><span class="params">(<span class="keyword">char</span> **tokens, <span class="keyword">int</span> tokensSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">stack</span>[<span class="number">10000</span>]; <span class="comment">// 用数组模拟栈</span></span><br><span class="line">    <span class="keyword">int</span> top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tokensSize; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(tokens[i][<span class="number">0</span>]) || (tokens[i][<span class="number">0</span>] == <span class="string">'-'</span> &amp;&amp; <span class="built_in">isdigit</span>(tokens[i][<span class="number">1</span>]))) &#123; <span class="comment">//如果是数字  "-11"单独考虑</span></span><br><span class="line">            <span class="built_in">stack</span>[++top] = atoi(tokens[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 操作符</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, tokens[i]);</span><br><span class="line">            <span class="keyword">switch</span> (tokens[i][<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">                    <span class="built_in">stack</span>[top - <span class="number">1</span>] = <span class="built_in">stack</span>[top - <span class="number">1</span>] + <span class="built_in">stack</span>[top];</span><br><span class="line">                    top--;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">                    <span class="built_in">stack</span>[top - <span class="number">1</span>] = <span class="built_in">stack</span>[top - <span class="number">1</span>] - <span class="built_in">stack</span>[top];</span><br><span class="line">                    top--;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">                    <span class="built_in">stack</span>[top - <span class="number">1</span>] = <span class="built_in">stack</span>[top - <span class="number">1</span>] * <span class="built_in">stack</span>[top];</span><br><span class="line">                    top--;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">                    <span class="built_in">stack</span>[top - <span class="number">1</span>] = <span class="built_in">stack</span>[top - <span class="number">1</span>] / <span class="built_in">stack</span>[top];</span><br><span class="line">                    top--;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>[top];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 234. Palindrome Linked List</title>
      <link href="/2019/07/21/leetcode-234-Palindrome-Linked-List/"/>
      <url>/2019/07/21/leetcode-234-Palindrome-Linked-List/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="234"><li>Palindrome Linked List:[题目链接]<a href="https://leetcode.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">https://leetcode.com/problems/palindrome-linked-list/</a>)</li></ol><p><strong><code>AC code:</code></strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode*  <span class="title">reverse</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">pre</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">cur</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">next</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1-&gt;2-&gt;2-&gt;1</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">fast</span> = <span class="title">head</span>, * <span class="title">slow</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="comment">// 通过快慢指针找到中间节点</span></span><br><span class="line">    <span class="keyword">while</span> (fast-&gt;next !=<span class="literal">NULL</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">p</span> = <span class="title">slow</span>-&gt;<span class="title">next</span>;</span> <span class="comment">// p: 2-&gt;1</span></span><br><span class="line">    slow-&gt;next = <span class="literal">NULL</span>; <span class="comment">// 将head: 1-&gt;2 的尾节点置NULL</span></span><br><span class="line">    p =  reverse(p);   <span class="comment">// 逆转p   p: 1-&gt;2</span></span><br><span class="line">    <span class="comment">// 分别遍历 head:1-&gt;2  p:1-&gt;2 </span></span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span> &amp;&amp; p!= <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;val != p-&gt;val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">        &#125;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// // 当链表元素为奇数时 如果有剩余元素</span></span><br><span class="line">    <span class="comment">// if (head != NULL || p != NULL) &#123;</span></span><br><span class="line">    <span class="comment">//     return true;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 876. Middle of the Linked List</title>
      <link href="/2019/07/21/leetcode-876-Middle-of-the-Linked-List/"/>
      <url>/2019/07/21/leetcode-876-Middle-of-the-Linked-List/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="876"><li>Middle of the Linked List:<a href="https://leetcode.com/problems/middle-of-the-linked-list/" target="_blank" rel="noopener">题目链接</a></li></ol><div align="center" style="zoom: 50%; margin:  0px auto;"><img src="/2019/07/21/leetcode-876-Middle-of-the-Linked-List/8.jpg" alt="原理"></div><br><strong><code>AC code:</code></strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">middleNode</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">fast</span> = <span class="title">head</span>, * <span class="title">slow</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="comment">// fast-&gt;next != NULL &amp;&amp; fast-&gt;next-&gt;next != NULL 返回的是第一个中间节点</span></span><br><span class="line">    <span class="keyword">while</span> (fast!=<span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><strong><code>如果是返回第一个中间节点呢？</code></strong><br><div align="center" style="zoom: 70%; margin:  0px auto;"><img src="/2019/07/21/leetcode-876-Middle-of-the-Linked-List/5.jpg" alt="原理"></div> ]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 141. Linked List Cycle</title>
      <link href="/2019/07/21/leetcode-141-Linked-List-Cycle/"/>
      <url>/2019/07/21/leetcode-141-Linked-List-Cycle/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="141"><li>Linked List Cycle:<a href="https://leetcode.com/problems/linked-list-cycle/" target="_blank" rel="noopener">题目链接</a><br>官方解析:<a href="https://leetcode-cn.com/problems/linked-list-cycle/solution/huan-xing-lian-biao-by-leetcode/" target="_blank" rel="noopener">题目链接</a></li></ol><p><strong><code>AC code:</code></strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(struct ListNode *head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">fast</span> = <span class="title">head</span>-&gt;<span class="title">next</span>, * <span class="title">slow</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast == <span class="literal">NULL</span> || fast-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 143. Reorder List</title>
      <link href="/2019/07/21/leetcode-143-Reorder-List/"/>
      <url>/2019/07/21/leetcode-143-Reorder-List/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="143"><li>Reorder List:<a href="https://leetcode.com/problems/reorder-list/" target="_blank" rel="noopener">题目链接</a></li></ol><div align="center" style="zoom: 70%; margin:  0px auto;"><img src="/2019/07/21/leetcode-143-Reorder-List/leetcode_143.jpg" alt="原理"></div> <p><strong><code>AC code:</code></strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode*  <span class="title">reverse</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">pre</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">cur</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">next</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        next = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">dummyHead</span> = (<span class="title">struct</span> <span class="title">ListNode</span>*) <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    dummyHead-&gt;next = head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">fast</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">slow</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="keyword">while</span> (fast-&gt;next != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next-&gt;next!= <span class="literal">NULL</span>) &#123;</span><br><span class="line">        slow = slow-&gt;next; <span class="comment">// 一次移动一个</span></span><br><span class="line">        fast = fast-&gt;next-&gt;next; <span class="comment">// 一次移动2个</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">p</span> = <span class="title">slow</span>;</span></span><br><span class="line">    <span class="comment">// p指向链表中间节点 从链表头到p形成一个链表dummyHead  从p的后一个节点到尾节点形成一个链表q</span></span><br><span class="line">    <span class="comment">// 逆转中间往后部分的链表 q = reverse(p-&gt;next)</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">q</span> = <span class="title">p</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (q == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    q = reverse(q); <span class="comment">//逆转之后新的链表</span></span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>; <span class="comment">//置空</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 合并dummyHead 、q两个链表乘一个新的链表</span></span><br><span class="line">    p = dummyHead-&gt;next;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">tail</span> = <span class="title">dummyHead</span>;</span></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> &amp;&amp; q != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">            tail-&gt;next = p;</span><br><span class="line">            tail = p;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            flag = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            tail-&gt;next = q;</span><br><span class="line">            tail = q;</span><br><span class="line">            q = q-&gt;next;</span><br><span class="line">            flag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        tail-&gt;next = p;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (q != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        tail-&gt;next = q;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Runtime: 16 ms, faster than 92.53% of C online submissions for Reorder List.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 61</title>
      <link href="/2019/07/21/leetcode-61/"/>
      <url>/2019/07/21/leetcode-61/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="61"><li>Rotate List:<a href="https://leetcode.com/problems/rotate-list/" target="_blank" rel="noopener">题目链接</a></li></ol><div align="center" style="zoom: 70%; margin:  0px auto;"><img src="/2019/07/21/leetcode-61/leetcode 61.jpg" alt="原理"></div> <p><strong><code>AC code:</code></strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">rotateRight</span><span class="params">(struct ListNode* head, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">dummyHead</span> = (<span class="title">struct</span> <span class="title">ListNode</span>*) <span class="title">malloc</span> (<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    dummyHead-&gt;next = head;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">tail</span> = <span class="title">dummyHead</span>;</span> <span class="comment">// 表尾</span></span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>; <span class="comment">// 表长</span></span><br><span class="line">    <span class="comment">// 求表长</span></span><br><span class="line">    <span class="keyword">while</span> (tail-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        tail = tail-&gt;next;</span><br><span class="line">        len++;</span><br><span class="line">    &#125;</span><br><span class="line">       </span><br><span class="line">    <span class="comment">// 找到倒数第k个元素的前驱  跟删除倒数第K元素的思想一样</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">p</span> = <span class="title">dummyHead</span>;</span></span><br><span class="line">    <span class="keyword">int</span> idx = len-(k%len); <span class="comment">// 前驱所在位置</span></span><br><span class="line">    <span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span> &amp;&amp; i &lt; idx) &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;next == <span class="literal">NULL</span>) &#123; <span class="comment">// 此时 newHead: NUL</span></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">newHead</span> = <span class="title">p</span>-&gt;<span class="title">next</span>;</span>  <span class="comment">// newHead: 4-&gt;5</span></span><br><span class="line">    p-&gt;next = <span class="literal">NULL</span>;       <span class="comment">// dummy-&gt;1-&gt;2-&gt;3  此时p指向3 将3的指针域置为NULL 作为表尾</span></span><br><span class="line">    tail-&gt;next = head;    <span class="comment">// 将1-&gt;2-3挂到4-&gt;5的后面   newHead:4-&gt;5-&gt;1-&gt;2-&gt;3</span></span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>147. Insertion Sort List</title>
      <link href="/2019/07/18/147-Insertion-Sort-List/"/>
      <url>/2019/07/18/147-Insertion-Sort-List/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="147"><li>Insertion Sort List:<a href="https://leetcode.com/problems/insertion-sort-list/" target="_blank" rel="noopener">题目链接</a></li></ol><p><strong><code>方法1</code></strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct ListNode* <span class="title">insertionSortList</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">dummyHead</span> = (<span class="title">struct</span> <span class="title">ListNode</span>*)<span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    dummyHead-&gt;next = head;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> head;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">pre</span> = <span class="title">NULL</span>;</span>   <span class="comment">// pre:待排元素在链表中的正确排序下的前驱</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">cur</span> = <span class="title">head</span>;</span>   </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">next</span> = <span class="title">NULL</span>;</span>  <span class="comment">// next:待排序节点</span></span><br><span class="line">    <span class="keyword">while</span> (cur-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        next = cur-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (cur-&gt;val &lt;= next-&gt;val) &#123; <span class="comment">// 待排序节点 &gt;= 前面节点 说明有序 遍历下一个</span></span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pre = dummyHead; </span><br><span class="line">            <span class="keyword">while</span> (pre-&gt;next != <span class="literal">NULL</span> &amp;&amp; pre-&gt;next-&gt;val &lt;= next-&gt;val) &#123; <span class="comment">// 从链表头开始 找到待排节点要插入位置的前驱</span></span><br><span class="line">                pre = pre -&gt; next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 找到前驱 开始插入</span></span><br><span class="line">            cur-&gt;next = next-&gt;next;</span><br><span class="line">            next-&gt;next = pre-&gt;next;</span><br><span class="line">            pre-&gt;next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Runtime: 4 ms, faster than 100.00% of C online submissions for Insertion Sort List.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>堆与堆排序和优先队列</title>
      <link href="/2019/06/02/%E5%A0%86%E4%B8%8E%E5%A0%86%E6%8E%92%E5%BA%8F%E5%92%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
      <url>/2019/06/02/%E5%A0%86%E4%B8%8E%E5%A0%86%E6%8E%92%E5%BA%8F%E5%92%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>本文将介绍插入排序<a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><ul><li><p><font style="font-weight: bold; color: #FF0000;">最大堆？最小堆？</font><br><strong><code>最大堆</code></strong>:堆中每个节点的值 <strong><code>&gt;=</code></strong> 子节点的值<br><strong><code>最小堆</code></strong>:堆中每个节点的值 <strong><code>&lt;=</code></strong> 子节点的值 </p></li><li><font style="font-weight: bold; color: #FF0000;">堆总是一颗完全二叉树 </font></li></ul><ul><li><font style="font-weight: bold; color: #FF0000;">为什么用数组来实现堆？</font><br>二叉堆是一个完全二叉树  把完全二叉树编号后 编号就可以对应数组中的索引<br>如果从<strong><code>1</code></strong>开始编号，<strong><code>父节点 = 当前节点索引 / 2</code></strong> , <strong><code>左孩子 = 当前节点索引 * 2</code></strong>, <strong><code>右孩子 = 当前节点索引 *2 + 1</code></strong><br>从<strong><code>1</code></strong>开始编号，用数组来表示一颗完全二叉树，<font style="font-weight: bold; color: #FF0000;">最后一个非叶子节点索引：</font><strong><code>最后一个节点索引/2</code></strong>，</li></ul><div align="left" style="zoom: 55%; margin:  0px auto;"><img src="/2019/06/02/堆与堆排序和优先队列/数组存储最大堆.png" alt="原理"></div> <p>如果从<strong><code>0</code></strong>开始编号，<strong><code>父节点 = （当前节点索引-1） / 2</code></strong> , <strong><code>左孩子 = 当前节点索引 * 2 + 1</code></strong>, <strong><code>右孩子 = 当前节点索引 *2 + 2</code></strong><br>从<strong><code>0</code></strong>开始编号，用数组来表示一颗完全二叉树，<font style="font-weight: bold; color: #FF0000;">最后一个非叶子节点索引：</font><strong><code>(最后一个节点索引-1)/2</code></strong>，</p><div align="left" style="zoom: 55%; margin:  0px auto;"><img src="/2019/06/02/堆与堆排序和优先队列/数组表示2.png" alt="原理"></div> <h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100   <span class="comment">// 堆的容量 可以用动态数组来扩充</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大堆的定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> data[MAXSIZE];</span><br><span class="line">    <span class="keyword">int</span> size;         <span class="comment">// 堆中元素个数</span></span><br><span class="line">&#125; MaxHeap;</span><br></pre></td></tr></table></figure><h3 id="建堆-核心：heapify-O-logN"><a href="#建堆-核心：heapify-O-logN" class="headerlink" title="建堆 核心：heapify O(logN)"></a>建堆 核心：heapify O(logN)</h3><iframe width="993" height="506" src="https://www.youtube.com/embed/UWyqMFUyn14" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><p>heapify:<font style="font-weight: bold; color: #FF0000;">将任意数组整理成堆的形状</font><br>优化：如果将个元素逐个插入到一个空堆中，这样建堆 复杂度为<strong><code>O(NlogN)</code></strong>,heapify的过程，算法复杂度为<strong><code>O(N)</code></strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// heapify:将任意数组整理成堆的形状 将每个节点都符合最大堆的性质</span></span><br><span class="line"><span class="comment">//         因为叶节点本身没有子节点所以符合最大堆的性质，只需从最后一个非叶子节点到堆顶节点，依次将每个节点堆化</span></span><br><span class="line"><span class="comment">// 注意：heapfiy之后数组中元素并不是从大到小的顺序</span></span><br><span class="line"><span class="function">MaxHeap *<span class="title">buildHeap</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化堆 并且 对堆进行赋值</span></span><br><span class="line">    <span class="comment">/*** 堆中元素 ∈ [0,size-1] ***/</span></span><br><span class="line">    MaxHeap *heap = (MaxHeap *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(MaxHeap));</span><br><span class="line">    heap-&gt;size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        heap-&gt;data[i] = arr[i];</span><br><span class="line">        heap-&gt;size++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  heapfiy:最后一个节点的索引为size-1，因为数组从0开始，所以最后一个非叶子节点索引(size-1-1)/2</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (heap-&gt;size - <span class="number">2</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        shiftDown(heap, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> heap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="插入-核心：shiftUp-O-logN"><a href="#插入-核心：shiftUp-O-logN" class="headerlink" title="插入 核心：shiftUp O(logN)"></a>插入 核心：shiftUp O(logN)</h3><iframe width="955" height="506" src="https://www.youtube.com/embed/jdgK72u2K1A" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><p><strong><code>基本思想：</code></strong>先将节点插入堆中，然后通过shiftUp操作将该节点放在满足最大堆性质的位置<br><strong><code>shiftUp:</code></strong>将待调整节点与其父节点比较，如果待调整节点比其父节点大，交换两者位置，待调整节点继续与其新父节点比较，如果遇到待调整节点 &lt;= 父亲节点，说明满足最大堆的性质，否则一直执行此过程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shiftUp</span><span class="params">(MaxHeap *heap, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line"><span class="comment">//    // idx &gt;= 1 代码上讲防止了数组越界</span></span><br><span class="line"><span class="comment">//    // 实际意义：idx=0是堆顶元素 其子节点idx要么是1(左孩子)要么是2(右孩子),在idx=2或1的时候已经和堆顶元素进行了比较</span></span><br><span class="line"><span class="comment">//    while (idx &gt;= 1 &amp;&amp; heap-&gt;data[idx] &gt; heap-&gt;data[(idx - 1) / 2]) &#123; // 待调整节点比其父节点大，交换两者位置</span></span><br><span class="line"><span class="comment">//        swap(heap-&gt;data, idx, (idx - 1) / 2);</span></span><br><span class="line"><span class="comment">//        idx = (idx - 1) / 2; // 更新待调整节点 在堆中的位置</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优化：减少赋值次数 交换时需要3次赋值，执行一次swap，赋值3^n</span></span><br><span class="line">    <span class="keyword">int</span> temp = heap-&gt;data[idx];</span><br><span class="line">    <span class="keyword">while</span> (idx &gt;= <span class="number">1</span> &amp;&amp; temp &gt; heap-&gt;data[(idx - <span class="number">1</span>) / <span class="number">2</span>]) &#123; <span class="comment">// 待调整节点比其父节点大，交换两者位置</span></span><br><span class="line">        heap-&gt;data[idx] = heap-&gt;data[(idx - <span class="number">1</span>) / <span class="number">2</span>];</span><br><span class="line">        idx = (idx - <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">// 更新待调整节点 在堆中的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    heap-&gt;data[idx] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除-核心：shiftDown-O-logN"><a href="#删除-核心：shiftDown-O-logN" class="headerlink" title="删除 核心：shiftDown O(logN)"></a>删除 核心：shiftDown O(logN)</h3><iframe width="970" height="506" src="https://www.youtube.com/embed/iorTuDj4BA0?list=UUuvYGFPMTl-fAfNz1FwhU5g" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><p><strong><code>基本思想：</code></strong>将最后一个元素与堆顶元素互换，此时新的堆顶元素不一定符合最大堆的性质，对其进行shiftDown<br><strong><code>shiftDown:</code></strong>将当前元素与自己的左右孩子中最大的那个比较，如果比最大的孩子小，交换两者位置,继续与新的左右孩子比较，直到大于等于左右孩子中最大的，此时符合最大堆的性质</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向最大堆中取出堆顶元素 即堆中的最大元素 O(logN)</span></span><br><span class="line"><span class="comment">// 基本思想：将最后一个元素与堆顶元素互换，此时新的堆顶元素不一定符合最大堆的性质，对其进行shiftDown</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">entractMax</span><span class="params">(MaxHeap *heap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (heap-&gt;size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"堆中没有元素.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> max = heap-&gt;data[<span class="number">0</span>];   <span class="comment">// 堆顶元素</span></span><br><span class="line"><span class="comment">//printf("出堆元素: %d \n", max);</span></span><br><span class="line">    swap(heap-&gt;data, <span class="number">0</span>, heap-&gt;size - <span class="number">1</span>); <span class="comment">// 将堆顶元素与堆中最后一个元素互换  堆中元素存在[0,size-1]中，起到了删除堆顶元素的作用</span></span><br><span class="line">    heap-&gt;size--;  <span class="comment">// 更新size</span></span><br><span class="line">    shiftDown(heap, <span class="number">0</span>);  <span class="comment">// 让调整新的堆顶元素 使其符合最大堆性质</span></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下沉操作 调整索引为idx的节点，使其符合最大堆性质</span></span><br><span class="line"><span class="comment">// 基本思想：将当前元素与自己的左右孩子中最大的那个比较，如果比最大的孩子小，交换两者位置</span></span><br><span class="line"><span class="comment">// 继续与新的左右孩子比较，直到大于等于左右孩子中最大的，此时符合最大堆的性质</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shiftDown</span><span class="params">(MaxHeap *heap, <span class="keyword">int</span> idx)</span> </span>&#123;</span><br><span class="line"><span class="comment">//    while (idx * 2 + 1 &lt;= heap-&gt;size - 1) &#123; // 左孩子 = idx *2 +1 如果在堆中  [0,size-1]</span></span><br><span class="line"><span class="comment">////        int j = idx * 2 + 1;</span></span><br><span class="line"><span class="comment">////        // 如果有右孩子 并且右孩子比左孩子大</span></span><br><span class="line"><span class="comment">////        if (j + 1 &lt;= heap-&gt;size - 1 &amp;&amp; heap-&gt;data[j + 1] &gt; heap-&gt;data[j]) &#123;</span></span><br><span class="line"><span class="comment">////            j = j + 1; // 更新j为右孩子的索引</span></span><br><span class="line"><span class="comment">////        &#125;</span></span><br><span class="line"><span class="comment">////        if (heap-&gt;data[idx] &gt;= heap-&gt;data[j]) &#123; //  待调节点 &gt;= 左右孩子最大</span></span><br><span class="line"><span class="comment">////            break; // 满足最大堆性质 结束</span></span><br><span class="line"><span class="comment">////        &#125;</span></span><br><span class="line"><span class="comment">////        swap(heap-&gt;data, idx, j); // 交换待调节点与其左右孩子最大的</span></span><br><span class="line"><span class="comment">////        idx = j; // 更新待调节点为 左右孩子最大的</span></span><br><span class="line"><span class="comment">////    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 优化：减少赋值次数 交换时需要3次赋值，执行一次swap，赋值3^n</span></span><br><span class="line">    <span class="keyword">int</span> temp = heap-&gt;data[idx];</span><br><span class="line">    <span class="keyword">while</span> (idx * <span class="number">2</span> + <span class="number">1</span> &lt;= heap-&gt;size - <span class="number">1</span>) &#123; <span class="comment">// 左孩子 = idx *2 +1 如果在堆中  [0,size-1]</span></span><br><span class="line">        <span class="keyword">int</span> j = idx * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果有右孩子 并且右孩子比左孩子大</span></span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt;= heap-&gt;size - <span class="number">1</span> &amp;&amp; heap-&gt;data[j + <span class="number">1</span>] &gt; heap-&gt;data[j]) &#123;</span><br><span class="line">            j = j + <span class="number">1</span>; <span class="comment">// 更新j为右孩子的索引</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp &gt;= heap-&gt;data[j]) &#123; <span class="comment">//  待调节点 &gt;= 左右孩子最大</span></span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 满足最大堆性质 结束</span></span><br><span class="line">        &#125;</span><br><span class="line">        heap-&gt;data[idx] = heap-&gt;data[j];</span><br><span class="line">        idx = j; <span class="comment">// 更新待调节点为 左右孩子最大的</span></span><br><span class="line">    &#125;</span><br><span class="line">    heap-&gt;data[idx] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一些其他操作"><a href="#一些其他操作" class="headerlink" title="一些其他操作"></a>一些其他操作</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取最大堆顶元素 即整个堆中最大的元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHeadTop</span><span class="params">(MaxHeap *heap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (heap-&gt;size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"堆中没有元素."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-9999999</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> heap-&gt;data[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取出堆中的最大元素，并且替换成元素e</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">replace</span><span class="params">(MaxHeap *heap, <span class="keyword">int</span> e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> max = heap-&gt;data[<span class="number">0</span>]; <span class="comment">// 堆中最大元素</span></span><br><span class="line">    heap-&gt;data[<span class="number">0</span>] = e; <span class="comment">// 修改堆顶元素</span></span><br><span class="line">    shiftDown(heap, <span class="number">0</span>); <span class="comment">// 修改后堆顶元素不一定满足最大堆性质</span></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原地堆排序"><a href="#原地堆排序" class="headerlink" title="原地堆排序"></a>原地堆排序</h2><iframe width="970" height="506" src="https://www.youtube.com/embed/kSNDFNsDq7Y?list=UUuvYGFPMTl-fAfNz1FwhU5g" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><p><strong><code>基本思想：</code></strong>首先将待排序数组heapfiy，即数组中每个元素都满足最大堆的性质<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h2 id="堆的应用-优先队列"><a href="#堆的应用-优先队列" class="headerlink" title="堆的应用-优先队列"></a>堆的应用-优先队列</h2><ol><li><font style="font-weight: bold; color: #FF0000;">优先队列与普通队列的区别？</font><br>普通队列：先进先出，后进后出<br>优先队列：出队顺序和入队顺序无关，和<strong><code>优先级有关</code></strong></li></ol><ol start="2"><li><p><font style="font-weight: bold; color: #FF0000;">为什么使用优先队列？</font><br><strong><code>动态</code></strong> 的选择优先级最高的任务<br>在N个元素中选出前M个元素，快排，归并等都是NlogN ,使用优先队列NlogM</p></li><li><font style="font-weight: bold; color: #FF0000;">优先队列可以用什么实现？</font></li></ol><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">入队</th><th style="text-align:left">出队</th></tr></thead><tbody><tr><td style="text-align:center">普通数组</td><td style="text-align:center"><strong><code>O(1)</code></strong></td><td style="text-align:left"><strong><code>O(N)</code></strong> 出队时遍历数组找出优先级最高的</td></tr><tr><td style="text-align:center">有序数组</td><td style="text-align:center"><strong><code>O(N)</code></strong> 入队时需要遍历一遍数组，插入适合的位置</td><td style="text-align:left"><strong><code>O(1)</code></strong> 优先级从大到小</td></tr><tr><td style="text-align:center">堆</td><td style="text-align:center"><strong><code>O(logN)</code></strong> 完全二叉树</td><td style="text-align:left"><strong><code>O(logN)</code></strong> 完全二叉树</td></tr></tbody></table></the>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 堆 </tag>
            
            <tag> 堆排序 </tag>
            
            <tag> 优先队列 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 236. Lowest Common Ancestor of a Binary Tree</title>
      <link href="/2019/02/16/leetcode-236-Lowest-Common-Ancestor-of-a-Binary-Tree/"/>
      <url>/2019/02/16/leetcode-236-Lowest-Common-Ancestor-of-a-Binary-Tree/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="236"><li>Lowest Common Ancestor of a Binary Tree:<a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/" target="_blank" rel="noopener">题目链接</a></li></ol><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><div align="center" style="zoom: 80%; margin:  0px auto;"><img src="/2019/02/16/leetcode-236-Lowest-Common-Ancestor-of-a-Binary-Tree/1.png" alt="原理"></div>  ]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 230. Kth Smallest Element in a BST</title>
      <link href="/2019/02/15/leetcode-230-Kth-Smallest-Element-in-a-BST/"/>
      <url>/2019/02/15/leetcode-230-Kth-Smallest-Element-in-a-BST/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="230"><li>Kth Smallest Element in a BST:<a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/" target="_blank" rel="noopener">题目链接</a></li></ol><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p><strong><code>思路：</code></strong>利用二分搜索树的特性 对其中序遍历可以得到一个<strong><code>从小到大</code></strong>的顺序<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> count = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 递归宏观语义：返回以root为根节点的二分搜索树中第k小的数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        kthSmallest(root.left, k);    <span class="comment">// 递归访问左子树</span></span><br><span class="line">        count++;                      <span class="comment">// 访问根</span></span><br><span class="line">        <span class="keyword">if</span> (count == k) &#123;</span><br><span class="line">            res = root.val;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        kthSmallest(root.right, k);   <span class="comment">// 访问右子树</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 107. Binary Tree Level Order Traversal II</title>
      <link href="/2019/02/14/leetcode-107-Binary-Tree-Level-Order-Traversal-II/"/>
      <url>/2019/02/14/leetcode-107-Binary-Tree-Level-Order-Traversal-II/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="107"><li>Binary Tree Level Order Traversal II:<a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/" target="_blank" rel="noopener">题目链接</a></li></ol><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 层序遍历这棵树  将第i层的结点全部加入到一个list中  最后再将该list压入栈中  最后将栈中结果集出栈就是answer</span></span><br><span class="line">    <span class="comment">// 其实也可以不用栈  用java里面的一个方法 res.add(0, 该层的结点集合) 就可以起到压栈再出栈的效果</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrderBottom(TreeNode root) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res= <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Stack&lt;List&lt;Integer&gt;&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> size = queue.size(); size &gt; <span class="number">0</span>; --size) &#123;</span><br><span class="line">                TreeNode front = queue.poll();</span><br><span class="line">                list.add(front.val);</span><br><span class="line">                <span class="keyword">if</span> (front.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(front.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (front.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(front.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(list);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            res.add(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 98. Validate Binary Search Tree</title>
      <link href="/2019/02/14/leetcode-98-Validate-Binary-Search-Tree/"/>
      <url>/2019/02/14/leetcode-98-Validate-Binary-Search-Tree/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="98"><li>Validate Binary Search Tree:<a href="https://leetcode.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">题目链接</a></li></ol><h2 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h2><div align="center" style="zoom: 55%; margin:  0px auto;"><img src="/2019/02/14/leetcode-98-Validate-Binary-Search-Tree/1.png" alt="原理"></div><p><strong><code>错误的解法：</code></strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归宏观语义:返回以root为根节点的二叉树是不是二分搜索树</span></span><br><span class="line">    <span class="comment">// 此写法错误  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;      </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> ((root.left != <span class="keyword">null</span> &amp;&amp; root.val &lt;= root.left.val) || (root.right != <span class="keyword">null</span> &amp;&amp;  root.val &gt;= root.right.val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root.left) &amp;&amp; isValidBST(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong><code>修改后的解法：</code></strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(root, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归宏观语义:返回以root为根节点的二叉树是不是二分搜索树  当前结点.val ∈ (leftLimit,rightLimit)  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(TreeNode root, Integer leftLimit, Integer rightLimit )</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((leftLimit != <span class="keyword">null</span> &amp;&amp; root.val &lt;= leftLimit) || (rightLimit != <span class="keyword">null</span> &amp;&amp; root.val &gt;= rightLimit)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> helper(root.left, leftLimit, root.val) &amp;&amp; helper(root.right, root.val, rightLimit);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 235. Lowest Common Ancestor of a Binary Search Tree</title>
      <link href="/2019/02/13/leetcode-235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree/"/>
      <url>/2019/02/13/leetcode-235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="235"><li>Lowest Common Ancestor of a Binary Search Tree:<a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/" target="_blank" rel="noopener">题目链接</a></li></ol><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><div align="center" style="zoom: 80%; margin:  0px auto;"><img src="/2019/02/13/leetcode-235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree/1.png" alt="原理"></div>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归宏观语义:返回以root为根节点的二分搜索树中 结点p和q的最近公共祖先结点</span></span><br><span class="line">    <span class="comment">// 时间复杂度O(N)  空间复杂度O(N)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;  <span class="comment">// 题目已经明确说明 p q在二分搜索树中</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p.val &lt; root.val &amp;&amp; q.val &lt; root.val) &#123; <span class="comment">// p,q都在左子树中</span></span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q); <span class="comment">// 递归到左子树去找p，q的最近公共祖先</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p.val &gt; root.val &amp;&amp; q.val &gt; root.val) &#123; <span class="comment">// p,q都在右子树中</span></span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q); <span class="comment">// 递归到右子树去找p，q的最近公共祖先</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// return root包含一下几种情况</span></span><br><span class="line">        <span class="comment">// 1. p,q在root两侧，那么最近公共祖先结点就是root</span></span><br><span class="line">        <span class="comment">// 2. p就是根结点 q在左子树或右子树  最近公共祖先结点就是root</span></span><br><span class="line">        <span class="comment">// 3. q就是根结点 p在左子树或右子树  最近公共祖先结点就是root</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="非递归"><a href="#非递归" class="headerlink" title="非递归"></a>非递归</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根递归的思路类似</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode curNode = root;</span><br><span class="line">        <span class="keyword">while</span> (curNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.val &lt; curNode.val &amp;&amp; q.val &lt; curNode.val) &#123; <span class="comment">// 最近公共结点在左子树</span></span><br><span class="line">                curNode = curNode.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (p.val &gt; curNode.val &amp;&amp; q.val &gt; curNode.val) &#123; <span class="comment">// 最近公共结点在右子树</span></span><br><span class="line">                curNode = curNode.right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// return curNode包含一下几种情况</span></span><br><span class="line">                <span class="comment">// 1. p,q在curNode两侧，那么最近公共祖先结点就是curNode</span></span><br><span class="line">                <span class="comment">// 2. p就是根结点 q在左子树或右子树  最近公共祖先结点就是curNode</span></span><br><span class="line">                <span class="comment">// 3. q就是根结点 p在左子树或右子树  最近公共祖先结点就是curNode</span></span><br><span class="line">                <span class="keyword">return</span> curNode;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 113. Path Sum II</title>
      <link href="/2019/02/12/leetcode-113-Path-Sum-II/"/>
      <url>/2019/02/12/leetcode-113-Path-Sum-II/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="113"><li>Path Sum II:<a href="https://leetcode.com/problems/path-sum-ii/" target="_blank" rel="noopener">题目链接</a></li></ol><h2 id="dfs-huisu"><a href="#dfs-huisu" class="headerlink" title="dfs +huisu"></a>dfs +huisu</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> sum, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; curPath, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; allPath)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;val == sum) &#123;</span><br><span class="line">                  curPath.push_back(root-&gt;val);</span><br><span class="line">                  allPath.push_back(curPath);</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        curPath.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            dfs(root-&gt;left, sum - root-&gt;val,curPath,allPath);</span><br><span class="line">            curPath.pop_back(); <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (root-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            dfs(root-&gt;right, sum - root-&gt;val,curPath,allPath);</span><br><span class="line">            curPath.pop_back();  <span class="comment">// 回溯</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pathSum(TreeNode* root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; allPath ;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; curPath;</span><br><span class="line">        dfs(root, sum, curPath, allPath);</span><br><span class="line">        <span class="keyword">return</span> allPath;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回root为根节点的二叉树中从根结点到叶子结点其和围殴sum的结点</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="keyword">return</span> res; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span> &amp;&amp; root.val == sum) &#123;  <span class="comment">// 叶子结点并且符合该路径上的结点之和 === sum</span></span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            list.add(root.val);</span><br><span class="line">            res.add(list); </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; leftRes = pathSum(root.left, sum - root.val); <span class="comment">// 返回左子树符合条件的路径</span></span><br><span class="line">        <span class="keyword">for</span> (List list : leftRes) &#123;</span><br><span class="line">            list.add(<span class="number">0</span>,root.val);  <span class="comment">// 将根节点放在该路径的第一个</span></span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; rightRes = pathSum(root.right, sum - root.val); <span class="comment">// 返回右子树符合条件的路径</span></span><br><span class="line">        <span class="keyword">for</span> (List list : rightRes) &#123;</span><br><span class="line">            list.add(<span class="number">0</span>,root.val);  <span class="comment">// 将根节点放在该路径的第一个</span></span><br><span class="line">            res.add(list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
            <tag> Recursion </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 257. Binary Tree Paths</title>
      <link href="/2019/02/12/leetcode-257-Binary-Tree-Paths/"/>
      <url>/2019/02/12/leetcode-257-Binary-Tree-Paths/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="257"><li>Binary Tree Paths:<a href="https://leetcode.com/problems/binary-tree-paths/" target="_blank" rel="noopener">题目链接</a></li></ol><h2 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归的宏观语义：返回以root为根节点的二叉树所有从根节点到叶节点的路径</span></span><br><span class="line">    <span class="comment">// 时间复杂度O(N) 空间复杂度O(M):list的长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">binaryTreePaths</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res; <span class="comment">// 如果树空 返回一个空的List&lt;String&gt;   [] </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right ==<span class="keyword">null</span>) &#123; <span class="comment">// 叶节点</span></span><br><span class="line">            res.add(<span class="string">""</span> + root.val);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        List&lt;String&gt; leftRes = binaryTreePaths(root.left); <span class="comment">// 左子树为根节点的二叉树所有从根节点到叶节点的路径</span></span><br><span class="line">        <span class="keyword">for</span> (String s : leftRes) &#123;</span><br><span class="line">            res.add(root.val + <span class="string">"-&gt;"</span> + s);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        List&lt;String&gt; rightRes = binaryTreePaths(root.right); <span class="comment">// 右子树为根节点的二叉树所有从根节点到叶节点的路径</span></span><br><span class="line">        <span class="keyword">for</span> (String s : rightRes) &#123;</span><br><span class="line">            res.add(root.val + <span class="string">"-&gt;"</span> + s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代解答"><a href="#迭代解答" class="headerlink" title="迭代解答"></a>迭代解答</h2><p>待补</p>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 101. Symmetric Tree</title>
      <link href="/2019/02/12/leetcode-101-Symmetric-Tree/"/>
      <url>/2019/02/12/leetcode-101-Symmetric-Tree/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="101"><li>Symmetric Tree:<a href="https://leetcode.com/problems/symmetric-tree/" target="_blank" rel="noopener">题目链接</a></li></ol><div align="center" style="zoom: 85%; margin:  0px auto;"><img src="/2019/02/12/leetcode-101-Symmetric-Tree/1.png" alt="原理"></div><h2 id="DFS-递归"><a href="#DFS-递归" class="headerlink" title="DFS-递归"></a>DFS-递归</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回以t1，t2分别为根节点的二叉树 是否对称</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMirror</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="keyword">null</span> &amp;&amp; t2 == <span class="keyword">null</span>) &#123; <span class="comment">// 叶子结点的左右两个NULL 也要看  递归到了这一步说明对称</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1. t1空 t2 不空 false   2. t1不空 t2空 false   3. t1和t2的数据域不相等 false</span></span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="keyword">null</span> || t2 == <span class="keyword">null</span> || t1.val != t2.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isMirror(t1.left, t2.right) &amp;&amp; isMirror(t1.right, t2.left); <span class="comment">// t1的左子树与t2的右子树 t1的右子树与t2的左子树是否对称 </span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isMirror(root.left, root.right);   <span class="comment">// 返回根节点左右子树是否对称</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">BFS</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">        Queue&lt;TreeNode&gt; q1 = <span class="keyword">new</span> LinkedList&lt;&gt;();   <span class="comment">// 装t1</span></span><br><span class="line">        Queue&lt;TreeNode&gt; q2 = <span class="keyword">new</span> LinkedList&lt;&gt;();   <span class="comment">// 装t2</span></span><br><span class="line">        q1.offer(t1);</span><br><span class="line">        q2.offer(t2);</span><br><span class="line">        <span class="keyword">while</span> (!q1.isEmpty() &amp;&amp; !q2.isEmpty()) &#123;</span><br><span class="line">            TreeNode f1 = q1.poll();</span><br><span class="line">            TreeNode f2 = q2.poll();</span><br><span class="line">            <span class="keyword">if</span> (f1 == <span class="keyword">null</span> &amp;&amp; f2 == <span class="keyword">null</span>) &#123; <span class="comment">// NULL 结点也入队</span></span><br><span class="line">                <span class="keyword">continue</span>; </span><br><span class="line">            &#125;</span><br><span class="line">             <span class="comment">// 1. f1空 f2 不空 false   2. f1不空 f2空 false   3. f1和f2的数据域不相等 false</span></span><br><span class="line">            <span class="keyword">if</span> (f1 == <span class="keyword">null</span> || f2 == <span class="keyword">null</span> || f1.val != f2.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            q1.offer(f1.left);  <span class="comment">// t1的入队顺序 是左 右  t2的入队顺序是 右 左  只要两者是反着的就行 </span></span><br><span class="line">            q1.offer(f1.right);</span><br><span class="line">            q2.offer(f2.right);</span><br><span class="line">            q2.offer(f2.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!q1.isEmpty() || !q2.isEmpty()) &#123; <span class="comment">// 说明一棵树遍历完了 另外一棵树还没有 肯定不对称</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> BFS(root.left, root.right);  <span class="comment">// 返回根节点左 右 子树是否对称</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
            <tag> BFS </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 404. Sum of Left Leaves</title>
      <link href="/2019/02/11/leetcode-404-Sum-of-Left-Leaves/"/>
      <url>/2019/02/11/leetcode-404-Sum-of-Left-Leaves/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="404"><li>Sum of Left Leaves:<a href="https://leetcode.com/problems/sum-of-left-leaves/" target="_blank" rel="noopener">题目链接</a></li></ol><h2 id="DFS-递归"><a href="#DFS-递归" class="headerlink" title="DFS-递归"></a>DFS-递归</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="comment">// 时间复杂度O(N) 空间复杂度O(N):递归栈的大小</span></span><br><span class="line">    <span class="comment">// 递归宏观语义：返回以root为根的二叉树的左叶子结点之和</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span> &amp;&amp; root.left.left == <span class="keyword">null</span> &amp;&amp; root.left.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root.left.val + sumOfLeftLeaves(root.right); <span class="comment">// 如果不加sumOfLeftLeaves(root.right) 当满足上面条件时因为return结束了函数 根本就没有递归到右子树</span></span><br><span class="line">        &#125;</span><br><span class="line">         <span class="comment">// 二叉树的左叶子结点之和 = 左子树左叶子结点之和 + 有子树左叶子结点之和 </span></span><br><span class="line">        <span class="keyword">return</span> sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BFS-层次遍历"><a href="#BFS-层次遍历" class="headerlink" title="BFS-层次遍历"></a>BFS-层次遍历</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// BFS 时间复杂度O(N) 空间复杂度O(M):队列的大小</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">sumOfLeftLeaves</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode front = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (front.left!= <span class="keyword">null</span> &amp;&amp; front.left.left == <span class="keyword">null</span> &amp;&amp; front.left.right ==<span class="keyword">null</span>) &#123; <span class="comment">// 左叶子结点</span></span><br><span class="line">                res += front.left.val;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (front.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(front.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (front.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(front.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
            <tag> BFS </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 112. Path Sum</title>
      <link href="/2019/02/11/leetcode-112-Path-Sum/"/>
      <url>/2019/02/11/leetcode-112-Path-Sum/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="112"><li>Path Sum:<a href="https://leetcode.com/problems/path-sum/" target="_blank" rel="noopener">题目链接</a></li></ol><h2 id="DFS-递归"><a href="#DFS-递归" class="headerlink" title="DFS-递归"></a>DFS-递归</h2><p>首先<strong><code>子问题</code></strong> 看左子树是否包含从root到叶子结点和为sum的路径 <strong><code>hasPathSum(root.left, sum - root.val)</code></strong>，再看右子树是否包含<strong><code>hasPathSum(root.right, sum - root.val)</code></strong>; 只要左子树或右子树一个包含说明有这样的路径，递归结束的条件有两个 <strong><code>root == null</code></strong> 树空 ,<strong><code>root.left ==null &amp;&amp; root.right == null 返回 root.val == sum</code></strong>是叶子结点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归宏观语义：返回以root为根节点的二叉树，从根节点到叶子结点 其和为sum的路径是否存在</span></span><br><span class="line">    <span class="comment">// 时间复杂度O(N)  空间复杂度O(N) 递归栈的大小</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123; <span class="comment">// 递归到叶子结点 看剩下的sum是否等于叶子结点的值</span></span><br><span class="line">            <span class="keyword">return</span> root.val == sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 去左子树找是否存在这样的路径并更新sum的值 去右子树找是否存在这样的路径并更新sum的值 只有左右子树有一个找到了 就返回true</span></span><br><span class="line">        <span class="keyword">return</span> hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><div align="center" style="zoom: 90%; margin:  0px auto;"><img src="/2019/02/11/leetcode-112-Path-Sum/1.png" alt="原理"></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// BFS 时间复杂度O(N)  空间复杂度O(M):队列大小</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;  <span class="comment">// 树空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode front = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (front.left == <span class="keyword">null</span> &amp;&amp; front.right == <span class="keyword">null</span>) &#123;  <span class="comment">// 遍历到叶节点</span></span><br><span class="line">                <span class="keyword">if</span> (front.val == sum) &#123; <span class="comment">// 只有当从根节点到该叶节点路径上的和累加起来 == sum</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (front.left != <span class="keyword">null</span>) &#123; <span class="comment">// 左子树不空 左孩子入队 并将父亲结点的值累加到左孩子结点</span></span><br><span class="line">                front.left.val += front.val; </span><br><span class="line">                queue.offer(front.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (front.right != <span class="keyword">null</span>) &#123; <span class="comment">// 右子树不空 右孩子入队 并将父亲结点的值累加到右孩子结点</span></span><br><span class="line">                front.right.val += front.val;</span><br><span class="line">                queue.offer(front.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
            <tag> DFS </tag>
            
            <tag> recursive </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 100. Same Tree</title>
      <link href="/2019/02/11/leetcode-100-Same-Tree/"/>
      <url>/2019/02/11/leetcode-100-Same-Tree/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="100"><li>Same Tree:<a href="https://leetcode.com/problems/same-tree/" target="_blank" rel="noopener">题目链接</a></li></ol><h2 id="BFS-层次遍历"><a href="#BFS-层次遍历" class="headerlink" title="BFS-层次遍历"></a>BFS-层次遍历</h2><p><strong><code>基本思路：</code></strong>层次遍历两根树 将出队元素进行比较 不同 返回false 注意null结点也要入队(试下题目给出的Example 2:[1,2]  [1,nul,2]就知道了)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// BFS 时间复杂度O(N) N：max(p的结点个数，q的结点个数) 空间复杂度O(M) m:两个队列的大小</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> &amp;&amp; q != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; q1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        Queue&lt;TreeNode&gt; q2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        q1.offer(p);</span><br><span class="line">        q2.offer(q);</span><br><span class="line">        <span class="keyword">while</span> (!q1.isEmpty() &amp;&amp; !q2.isEmpty()) &#123;</span><br><span class="line">            TreeNode front1 = q1.poll();</span><br><span class="line">            TreeNode front2 = q2.poll();</span><br><span class="line">            <span class="keyword">if</span> (front1 == <span class="keyword">null</span> &amp;&amp; front2 == <span class="keyword">null</span>) &#123; <span class="comment">// null结点也要入队 比如[1,2] [1,null,2]的情况</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果front1空 front2不空 false  </span></span><br><span class="line">            <span class="comment">// front1不空 front2空 false</span></span><br><span class="line">            <span class="comment">// front1.val != front2.val fasle</span></span><br><span class="line">            <span class="keyword">if</span> (front1 == <span class="keyword">null</span> || front2 == <span class="keyword">null</span> || front1.val != front2.val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            q1.offer(front1.left); </span><br><span class="line">            q1.offer(front1.right);</span><br><span class="line">            q2.offer(front2.left);</span><br><span class="line">            q2.offer(front2.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q1.size() != <span class="number">0</span> || q2.size() != <span class="number">0</span>)&#123; <span class="comment">// 如果最后两个队列中还有队列还有元素 false </span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="DFS-递归"><a href="#DFS-递归" class="headerlink" title="DFS-递归"></a>DFS-递归</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归宏观语义：返回二叉树p和q是否一样</span></span><br><span class="line"><span class="comment">// DFS 时间复杂度O(N) N:max(p的结点个数，q的结点个数) 空间复杂度O(N) 递归栈的大小 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> &amp;&amp; q != <span class="keyword">null</span>) &#123; <span class="comment">// p空 q不空 false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>) &#123; <span class="comment">// p不空 q空 false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>) &#123; <span class="comment">// p空 q空 true</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p.val != q.val) &#123; <span class="comment">// 两个结点val不同 false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果p的左子树和q的左子树相同 p的右子树和q的右子树相同 true 否则 false</span></span><br><span class="line">        <span class="keyword">return</span> isSameTree(p.left,q.left) &amp;&amp; isSameTree(p.right, q.right); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
            <tag> BFS </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>226. Invert Binary Tree</title>
      <link href="/2019/02/11/226-Invert-Binary-Tree/"/>
      <url>/2019/02/11/226-Invert-Binary-Tree/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="226"><li>Invert Binary Tree:<a href="https://leetcode.com/problems/invert-binary-tree/" target="_blank" rel="noopener">题目链接</a></li></ol><h2 id="DFS-递归"><a href="#DFS-递归" class="headerlink" title="DFS-递归"></a>DFS-递归</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归宏观语义：返回左右孩子互换的二叉树  时间复杂度O(N) 空间复杂度O(N)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode temp = root.left;  <span class="comment">// 先用临时变量记住root的left</span></span><br><span class="line">        root.left = invertTree(root.right); <span class="comment">// root的左孩子变成已经交换好了的右子树</span></span><br><span class="line">        root.right = invertTree(temp); <span class="comment">// root的右孩子变成已经交换好了的左子树</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BFS-层次遍历"><a href="#BFS-层次遍历" class="headerlink" title="BFS-层次遍历"></a>BFS-层次遍历</h2><p>在层次遍历出队时，将队首结点的左右孩子互换<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// BFS 时间复杂度O(N) 空间复杂度O(M)M:队列的长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            TreeNode front = queue.poll();</span><br><span class="line">            <span class="comment">// 在将队首结点出队的时候 将队首结点的左右孩子 互换</span></span><br><span class="line">            TreeNode temp = front.left;</span><br><span class="line">            front.left = front.right;</span><br><span class="line">            front.right = temp;</span><br><span class="line">            <span class="keyword">if</span> (front.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(front.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (front.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.offer(front.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
            <tag> BFS </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>662. Maximum Width of Binary Tree</title>
      <link href="/2019/02/11/662-Maximum-Width-of-Binary-Tree/"/>
      <url>/2019/02/11/662-Maximum-Width-of-Binary-Tree/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="662"><li>Maximum Width of Binary Tree:<a href="https://leetcode.com/problems/maximum-width-of-binary-tree/" target="_blank" rel="noopener">题目链接</a></li></ol><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p><strong><code>基本思想：</code></strong>其实就是求二叉树上所有层里 从第一层到最后一层，<strong><code>所在层的宽度 = 最右结点的位置-最左结点的位置 + 1</code></strong>,求所有层中宽度最大的值，利用层次遍历的思想，父亲结点编号idx = i，那么左孩子编号idx = 2i，右孩子编号idx = 2i + 1， 定义一个leftIdx变量每次指向当前深度的最左结点的位置 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">nodeIndex</span></span>&#123;</span><br><span class="line">         TreeNode node;</span><br><span class="line">         <span class="keyword">int</span> idx;</span><br><span class="line">         nodeIndex(TreeNode node, <span class="keyword">int</span> idx)&#123;</span><br><span class="line">            <span class="keyword">this</span>.node = node;</span><br><span class="line">            <span class="keyword">this</span>.idx = idx;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">widthOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;nodeIndex&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(<span class="keyword">new</span> nodeIndex(root, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>, size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (queue.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            depth++;  <span class="comment">// 当前深度</span></span><br><span class="line">            <span class="keyword">int</span> left = queue.peek().idx; <span class="comment">// 当前深度的第一个节点的idx</span></span><br><span class="line">            size = queue.size(); <span class="comment">// 第depth层所有节点个数(不含NULL)</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; size ; ++i) &#123;  <span class="comment">// 遍历该depth层的节点 </span></span><br><span class="line">                nodeIndex  front = queue.peek();</span><br><span class="line">                queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (front.node.left != <span class="keyword">null</span>) &#123; </span><br><span class="line">                    queue.offer(<span class="keyword">new</span> nodeIndex(front.node.left, front.idx * <span class="number">2</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (front.node.right != <span class="keyword">null</span>) &#123; </span><br><span class="line">                    queue.offer(<span class="keyword">new</span> nodeIndex(front.node.right, front.idx * <span class="number">2</span>+<span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i == size -<span class="number">1</span>) &#123; <span class="comment">// 当遍历到当前depth的最后一个节点  更新res</span></span><br><span class="line">                    res = res &lt; (front.idx - left + <span class="number">1</span>) ? (front.idx - left + <span class="number">1</span>) : res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
            <tag> BFS </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>111. Minimum Depth of Binary Tree</title>
      <link href="/2019/02/10/111-Minimum-Depth-of-Binary-Tree/"/>
      <url>/2019/02/10/111-Minimum-Depth-of-Binary-Tree/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="111"><li>Minimum Depth of Binary Tree:<a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">题目链接</a></li></ol><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p><strong><code>思路：</code></strong>借助队列首先根节点入队，此时depth=1，然后将depth=1的结点出队，出队的同时将depth=1的结点的左右孩子入队，此时depth = 2，将depth = 2的结点出队并将其左右孩子入队，同理第N层也是这样，在此过程中检查是否有结点是叶节点，有说明该叶节点对应的深度就是最小深度<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// BFS  时间复杂度O(N)  空间复杂度O(M) M:队列的长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="comment">// 树空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);  <span class="comment">// 根节点入队</span></span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;      <span class="comment">// 二叉树最小深度 初始为0</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123; <span class="comment">// 队列不空</span></span><br><span class="line">            depth++;  <span class="comment">// 深度+1 </span></span><br><span class="line">            <span class="comment">// 获取当前层次的所有结点 并将其左右孩子入队</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> size = queue.size(); size &gt; <span class="number">0</span>; --size) &#123; </span><br><span class="line">                TreeNode front = queue.poll(); <span class="comment">// 取出队首元素</span></span><br><span class="line">                <span class="keyword">if</span> (front.left == <span class="keyword">null</span> &amp;&amp; front.right == <span class="keyword">null</span>) &#123; <span class="comment">// 如果队首元素是叶节点说明 该结点所在层次即为最小深度</span></span><br><span class="line">                    <span class="keyword">return</span> depth;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (front.left != <span class="keyword">null</span>) &#123;  <span class="comment">// 左孩子不空 左孩子入队</span></span><br><span class="line">                    queue.offer(front.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (front.right != <span class="keyword">null</span>) &#123; <span class="comment">// 右孩子不空右孩子入队</span></span><br><span class="line">                    queue.offer(front.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong><code>解法2：</code></strong>BFS入队列的是一个新建的结构体里面包含当前结点已经当前结点所在深度<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        TreeNode node;</span><br><span class="line">        <span class="keyword">int</span> level;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>(<span class="keyword">null</span>,<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(TreeNode node,<span class="keyword">int</span> level )</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.node = node;</span><br><span class="line">            <span class="keyword">this</span>.level = level;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">levelOrder</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">999999</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(<span class="keyword">new</span> Node(root,<span class="number">1</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            Node front = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (front.node.left==<span class="keyword">null</span> &amp;&amp; front.node.right==<span class="keyword">null</span> &amp;&amp; front.level &lt; res) &#123;</span><br><span class="line">                <span class="keyword">return</span>  front.level;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (front.node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(<span class="keyword">new</span> Node(front.node.left, front.level + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (front.node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(<span class="keyword">new</span> Node(front.node.right, front.level + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> levelOrder(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="DFS-递归"><a href="#DFS-递归" class="headerlink" title="DFS-递归"></a>DFS-递归</h2><p><div align="center" style="zoom: 55%; margin:  0px auto;"><img src="/2019/02/10/111-Minimum-Depth-of-Binary-Tree/1.png" alt="原理"></div><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归宏观语义：返回以root为根二叉树的最小深度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123; <span class="comment">// 树空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123; <span class="comment">// 当前结点左右孩子都空 返回root的深度1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span>) &#123; <span class="comment">// 左孩子空 右孩子不空 返回root深度 + root右子树最小深度</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + minDepth(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right == <span class="keyword">null</span>) &#123; <span class="comment">// 右孩子空 左孩子不空 返回root深度 + root左子树最小深度</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + minDepth(root.left);  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftMinDepth = minDepth(root.left); <span class="comment">// 递归左子树最小深度</span></span><br><span class="line">        <span class="keyword">int</span> rightMinDepth = minDepth(root.right); <span class="comment">// 递归右子树最小深度</span></span><br><span class="line">        <span class="keyword">return</span> leftMinDepth &lt; rightMinDepth ? leftMinDepth + <span class="number">1</span> : rightMinDepth + <span class="number">1</span>; <span class="comment">// 左右子树最小深度 + 根节点深度 </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
            <tag> BFS </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 104. Maximum Depth of Binary Tree</title>
      <link href="/2019/02/09/leetcode-104-Maximum-Depth-of-Binary-Tree/"/>
      <url>/2019/02/09/leetcode-104-Maximum-Depth-of-Binary-Tree/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="104"><li>Maximum Depth of Binary Tree:<a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">题目链接</a></li></ol><h2 id="递归-DFS"><a href="#递归-DFS" class="headerlink" title="递归-DFS"></a>递归-DFS</h2><p><strong><code>AC:</code></strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// DFS遍历了所有结点 时间复杂度O(N) 空间复杂度O(N) </span></span><br><span class="line">    <span class="comment">// 递归宏观语义 返回二叉树的最大深度  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;  <span class="comment">// 递归终止条件</span></span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> leftMaxDepth = maxDepth(root.left);   <span class="comment">// 递归求解左子树最大深度</span></span><br><span class="line">      <span class="keyword">int</span> rightMaxDepth = maxDepth(root.right); <span class="comment">// 递归求解右子树最大深度</span></span><br><span class="line">      <span class="keyword">return</span> leftMaxDepth &gt; rightMaxDepth ? leftMaxDepth+<span class="number">1</span> : rightMaxDepth + <span class="number">1</span>; <span class="comment">// 返回左子树和右子树深度最大的 再加上 根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="BFS"><a href="#BFS" class="headerlink" title="BFS"></a>BFS</h2><p><strong><code>第一种写法：</code></strong>在层次遍历的基础上，入队的时刻不止将当前结点入队，并且把当前结点的层数入队，用一个类(结构体)记录当前结点和其层数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;        </span><br><span class="line">        TreeNode node; <span class="comment">// 当前结点</span></span><br><span class="line">        <span class="keyword">int</span> level;     <span class="comment">// 当前结点对应层数</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(TreeNode node, <span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.node = node;</span><br><span class="line">            <span class="keyword">this</span>.level = level;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 时间复杂度O(N)  空间复杂度O(M) M：队列大小</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;   <span class="comment">// 如果树空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;  <span class="comment">// 存放结果 初始为0</span></span><br><span class="line">        Queue&lt;Node&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(<span class="keyword">new</span> Node(root,<span class="number">1</span>)); <span class="comment">// 根节点入队</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;     <span class="comment">// 队列不空</span></span><br><span class="line">            Node front = queue.poll(); <span class="comment">// 队首结点出队</span></span><br><span class="line">            <span class="keyword">if</span> (front.level &gt; res) &#123;   <span class="comment">// 如果队首结点的层次比res大 更新res</span></span><br><span class="line">                res = front.level;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (front.node.left != <span class="keyword">null</span>) &#123; <span class="comment">// 队首元素左孩子不空 左孩子及其level入队</span></span><br><span class="line">                queue.offer(<span class="keyword">new</span> Node(front.node.left, front.level + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (front.node.right != <span class="keyword">null</span>) &#123; <span class="comment">// 队首元素右孩子不空 右孩子及其level入队</span></span><br><span class="line">                queue.offer(<span class="keyword">new</span> Node(front.node.right, front.level + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong><code>第二种写法：</code></strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 时间复杂度O(N)  空间复杂度O(M) M：队列大小</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;   <span class="comment">// 如果树空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;  <span class="comment">// 存放结果 初始为0</span></span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root); <span class="comment">// 根节点入队</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;     <span class="comment">// 队列不空</span></span><br><span class="line">            res++;  <span class="comment">// 层数+1</span></span><br><span class="line">            <span class="comment">// 取出当前层的结点 并将其孩子入队</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> size = queue.size(); size &gt; <span class="number">0</span>; --size) &#123;</span><br><span class="line">                TreeNode front = queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (front.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(front.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (front.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    queue.offer(front.right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
            <tag> BFS </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数组|链表实现及与栈和队列的关系</title>
      <link href="/2019/02/01/%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8%E5%BD%A2%E6%88%90%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/02/01/%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8%E5%BD%A2%E6%88%90%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><blockquote><font style="font-weight: bold; color: #FF0000;">数组的特点：随机访问</font>  </blockquote><h2 id="数组实现-动态数组"><a href="#数组实现-动态数组" class="headerlink" title="数组实现-动态数组"></a>数组实现-动态数组</h2><p><strong><code>结点构造:</code></strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INITSIZE 10 <span class="comment">// 数组初始容量</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> E int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// 静态数组节点定义</span></span><br><span class="line"><span class="comment">typedef struct &#123;</span></span><br><span class="line"><span class="comment">    E data[INITSIZE];  // 数组长度为固定长度</span></span><br><span class="line"><span class="comment">    int size;</span></span><br><span class="line"><span class="comment">&#125;Array;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态数组节点定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    E * data;      <span class="comment">// 动态分配数组的空间基址</span></span><br><span class="line">    <span class="keyword">int</span> capacity;  <span class="comment">// 数组的最大容量</span></span><br><span class="line">    <span class="keyword">int</span> size;      <span class="comment">// 数组元素当前所占容量 size:0 表示数组空</span></span><br><span class="line">                   <span class="comment">// 有的教材是int last指向数组最后一个元素的下标  初始时为空：last = -1 两个原理一致</span></span><br><span class="line">&#125;Array;</span><br></pre></td></tr></table></figure></p><p><strong><code>初始化及相关操作：</code></strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化动态数组</span></span><br><span class="line"><span class="function">Array * <span class="title">initArray</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Array *arr = (Array *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Array));</span><br><span class="line">    arr-&gt;data = (E *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(E) * INITSIZE);</span><br><span class="line">    arr-&gt;capacity = INITSIZE;</span><br><span class="line">    arr-&gt;size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数组的容量   O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getCapacity</span><span class="params">(Array * arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr-&gt;capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取数组中的元素个数  O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">(Array * arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回数组是否为空 O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isEmpty</span><span class="params">(Array * arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印数组信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMessage</span><span class="params">(Array * arr)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Array:size = %d  , capacity = %d \n"</span>,arr-&gt;size,arr-&gt;capacity);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"["</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; arr-&gt;size; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, arr-&gt;data[i]);</span><br><span class="line">        <span class="keyword">if</span> (i != arr-&gt;size - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">", "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"]\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong><code>插入操作:</code></strong><br>在数组头部插入数据需要O(N)，尾部插入数据需要O(1),平均插入数据需要O(N)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将数组空间的容量扩容成newCapacity大小 O(N)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(Array * arr,<span class="keyword">int</span> newCapacity)</span></span>&#123;</span><br><span class="line">    E *newDate = (E *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(E) * newCapacity); <span class="comment">// 此处可以使用realloc</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; arr-&gt;size; ++i) &#123;</span><br><span class="line">        newDate[i] = arr-&gt;data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    arr-&gt;data = newDate;</span><br><span class="line">    arr-&gt;capacity = newCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在index索引的位置插入一个新元素e   index∈[0,size]  O(N)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Array * arr,<span class="keyword">int</span> index, E e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; arr-&gt;size) &#123; <span class="comment">// index位置不合法</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Add failed. Require index [0,size]."</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr-&gt;size == arr-&gt;capacity)&#123; <span class="comment">// 数组满 动态增长数组</span></span><br><span class="line">        resize(arr, <span class="number">2</span> * arr-&gt;capacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = arr-&gt;size<span class="number">-1</span>; i &gt;=index ; --i) &#123;</span><br><span class="line">        arr-&gt;data[i + <span class="number">1</span>] = arr-&gt;data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    arr-&gt;data[index] = e;</span><br><span class="line">    arr-&gt;size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向所有元素后添加一个新元素   O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addLast</span><span class="params">(Array * arr,E e)</span></span>&#123;</span><br><span class="line">    add(arr, arr-&gt;size, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在所有元素前添加一个新元素   O(N)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(Array * arr,E e)</span></span>&#123;</span><br><span class="line">    add(arr, <span class="number">0</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong><code>删除操作:</code></strong><br>在数组头删除元素需要O(N)，数组尾删除元素O(1),平均删除元素需要O(N)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从数组中删除index位置的元素, 返回删除的元素   O(N)</span></span><br><span class="line"><span class="function">E <span class="title">Remove</span><span class="params">(Array * arr,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= arr-&gt;size) &#123; <span class="comment">// index ∈[0,size)</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Remove failed. Index ∈ [0,size)."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-9999999</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    E res = arr-&gt;data[index];</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = index + <span class="number">1</span>; i &lt; arr-&gt;size; ++i) &#123;</span><br><span class="line">        arr-&gt;data[i<span class="number">-1</span>] = arr-&gt;data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    arr-&gt;size--;</span><br><span class="line">    <span class="comment">// 动态缩减数组 更好的写法：arr-&gt;size == arr-&gt;capacity / 4 &amp;&amp; arr-&gt;capacity / 2 !=0</span></span><br><span class="line">    <span class="keyword">if</span> (arr-&gt;size == arr-&gt;capacity / <span class="number">2</span>) &#123;</span><br><span class="line">        resize(arr, arr-&gt;capacity / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从数组中删除第一个元素, 返回删除的元素   O(N)</span></span><br><span class="line"><span class="function">E <span class="title">removeFirst</span><span class="params">(Array * arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Remove(arr, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从数组中删除最后一个元素, 返回删除的元素  O(1)</span></span><br><span class="line"><span class="function">E <span class="title">removeLast</span><span class="params">(Array * arr)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Remove(arr, arr-&gt;size - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从数组中删除元素e   O(N)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeElement</span><span class="params">(Array * arr,E e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = find(arr, e);</span><br><span class="line">    <span class="keyword">if</span> (index != <span class="number">-1</span>) &#123;</span><br><span class="line">        Remove(arr, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong><code>修改操作:</code></strong><br>已知索引O(1),未知索引是O(N)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改index索引位置的元素为e O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(Array * arr,<span class="keyword">int</span> index, E e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; arr-&gt;size) &#123; <span class="comment">// index∈[0,size)</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Set failed. Index ∈ [0,size)."</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    arr-&gt;data[index] = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong><code>查找操作:</code></strong><br>已知索引O(1),未知索引是O(N)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取index索引位置的元素 O(1)</span></span><br><span class="line"><span class="function">E <span class="title">get</span><span class="params">(Array * arr,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= arr-&gt;size) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Get failed. Index ∈ [0,size)."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-9999999</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr-&gt;data[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找数组中是否有元素e  O(N)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">contains</span><span class="params">(Array * arr,E e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; arr-&gt;size; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr-&gt;data[i] == e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找数组中元素e所在的索引，如果不存在元素e，则返回-1  O(N)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(Array * arr,E e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; arr-&gt;size; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr-&gt;data[i] == e) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="链表实现"><a href="#链表实现" class="headerlink" title="链表实现"></a>链表实现</h2><p><strong><code>节点定义：</code></strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> E int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    E data;                       <span class="comment">// 数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> * <span class="title">next</span>;</span>           <span class="comment">// 指针域</span></span><br><span class="line">&#125;LinkNode;</span><br></pre></td></tr></table></figure></p><p><strong><code>初始化及相关操作：</code></strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化链表</span></span><br><span class="line"><span class="function">LinkNode * <span class="title">initLink</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LinkNode *dummyHead = (LinkNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode)); <span class="comment">// 创建虚拟头节点</span></span><br><span class="line">    dummyHead-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> dummyHead;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取链表中的元素个数  O(N)  可以通过加入size成员 来使复杂度降为O(1) 虽然需要维护size 见java版</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">(LinkNode * dummyHead)</span></span>&#123;</span><br><span class="line">    LinkNode *curNode = dummyHead-&gt;next;</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>, i;</span><br><span class="line">    <span class="keyword">while</span> (curNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        size++;</span><br><span class="line">        curNode = curNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回链表是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isEmpty</span><span class="params">(LinkNode * dummyHead)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span> == dummyHead-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMessage</span><span class="params">(LinkNode *dummyHead)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(dummyHead))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"printMessage failed. LinkedList is empty.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"LinkedList : "</span>);</span><br><span class="line">    LinkNode * curNode = dummyHead-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (curNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d -&gt; "</span>, curNode-&gt;data);</span><br><span class="line">        curNode = curNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"NULL\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong><code>插入操作:</code></strong><br>在链表头部插入数据需要O(1)，尾部插入数据需要O(N),平均插入数据需要O(N)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在链表的索引为index位置添加新的元素e  index从0开始  O(N)</span></span><br><span class="line"><span class="comment">// dummyHead -&gt; 1 -&gt; 2 -&gt; 3</span></span><br><span class="line"><span class="comment">// index        0    1    2    则index可以使在索引为0,1,2,3的位置插入 即index ∈ [0,getSize()]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(LinkNode * dummyHead,<span class="keyword">int</span> index, E e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt; getSize(dummyHead)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Add failed. index index ∈ [0,getSize()]\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkNode *pre = dummyHead;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; index; ++i) &#123;</span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkNode *newNode = (LinkNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    newNode-&gt;data = e;</span><br><span class="line">    newNode-&gt;next = pre-&gt;next;</span><br><span class="line">    pre-&gt;next = newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在链表头添加新的元素e   O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(LinkNode * dummyHead,E e)</span></span>&#123;</span><br><span class="line">    add(dummyHead, <span class="number">0</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在链表末尾添加新的元素e  O(N)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addLast</span><span class="params">(LinkNode * dummyHead,E e)</span></span>&#123;</span><br><span class="line">    add(dummyHead, getSize(dummyHead), e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong><code>删除操作:</code></strong><br>在链表头删除元素需要O(1)，链表尾删除元素O(N),平均删除元素需要O(N)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从链表中删除index ∈ [0,getSize()-1]位置的元素, 返回删除的元素  O(N)</span></span><br><span class="line"><span class="function">E <span class="title">Remove</span><span class="params">(LinkNode * dummyHead,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= getSize(dummyHead))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"remove failed. index ∈ [0,getSize()-1].\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-9999999</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkNode *pre = dummyHead;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; index; ++i) &#123;</span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkNode *delNode = pre-&gt;next;</span><br><span class="line">    E res = delNode-&gt;data;</span><br><span class="line">    pre-&gt;next = delNode-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(delNode);</span><br><span class="line">    delNode = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从链表中删除第一个元素, 返回删除的元素  O(1)</span></span><br><span class="line"><span class="function">E <span class="title">removeFirst</span><span class="params">(LinkNode * dummyHead)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Remove(dummyHead, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从链表中删除最后一个元素, 返回删除的元素  O(N)</span></span><br><span class="line"><span class="function">E <span class="title">removeLast</span><span class="params">(LinkNode * dummyHead)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Remove(dummyHead, getSize(dummyHead) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从链表中删除元素e  O(N)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removeElement</span><span class="params">(LinkNode * dummyHead,E e)</span></span>&#123;</span><br><span class="line">    LinkNode *pre = dummyHead;</span><br><span class="line">    <span class="keyword">while</span> (pre-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pre-&gt;next-&gt;data == e)&#123;</span><br><span class="line">            LinkNode *delNode = pre-&gt;next;</span><br><span class="line">            pre-&gt;next = delNode-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(delNode);</span><br><span class="line">            delNode = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong><code>修改操作：</code></strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改链表的第index ∈ [0,getSize()-1]个位置的元素为e  O(N)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(LinkNode *dummyHead, <span class="keyword">int</span> index, E e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= getSize(dummyHead)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"set failed. index index ∈ [0,getSize()-1]\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkNode *curNode = dummyHead-&gt;next;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; index; ++i) &#123;</span><br><span class="line">        curNode = curNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    curNode-&gt;data = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong><code>查找操作：</code></strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得链表的第index ∈ [0,getSize()-1]个位置的元素  O(N)</span></span><br><span class="line"><span class="function">E <span class="title">get</span><span class="params">(LinkNode * dummyHead,<span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= getSize(dummyHead)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"get failed. index index ∈ [0,getSize()-1]\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-9999999</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkNode *curNode = dummyHead-&gt;next;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; index; ++i) &#123;</span><br><span class="line">        curNode = curNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curNode-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得链表的第一个元素  O(1)</span></span><br><span class="line"><span class="function">E <span class="title">getFirst</span><span class="params">(LinkNode *dummyHead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(dummyHead, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得链表的最后一个元素  O(N)</span></span><br><span class="line"><span class="function">E <span class="title">getLast</span><span class="params">(LinkNode *dummyHead)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(dummyHead, getSize(dummyHead) - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找链表中是否有元素e O(N)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">contains</span><span class="params">(LinkNode * dummyHead, E e)</span></span>&#123;</span><br><span class="line">    LinkNode *curNode = dummyHead-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (curNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (curNode-&gt;data == e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        curNode = curNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong><code>数组：</code></strong></p><blockquote><p><font style="font-weight: bold; color: #FF0000;">基于数组实现的栈和队列都是 数组操作的子集</font>  </p><ul><li><font style="font-weight: bold; color: #FF0000;">栈(数组)：</font>addLast() 入栈 O(1); removeLast() 出栈 O(1); get(index:size-1)读栈顶元素O(1)</li><li><font style="font-weight: bold; color: #FF0000;">队列(数组)：</font> addLast() 入队 O(1); removeFirst() 出队 o(N) ; get(index:0) 读队头元素 O(1)；get(index:size-1) 度队尾元素O(1)因为出队是O(N) 于是加入<strong><code>队尾指针</code></strong>并进行对应的改变 使出队变成O(1)</li></ul></blockquote><p><strong><code>链表：</code></strong></p><blockquote><p><font style="font-weight: bold; color: #FF0000;">基于链表实现的栈和队列都是 链表操作的子集</font>  </p><ul><li><font style="font-weight: bold; color: #FF0000;">栈(链表)：</font>addFirst()入栈   removeFirst()出栈    getFirst()取栈顶元素  都是O(1)</li><li><font style="font-weight: bold; color: #FF0000;">队列(链表)：</font>removeFirst()出队   addLast()入队   getFirst()队头元素    队列出队，取队头O(1),入队需要O(N) 但是如果在头指针的基础上设<strong><code>尾指针</code></strong> 降为O(1)</li></ul></blockquote><blockquote><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/02_%E6%A0%88" target="_blank" rel="noopener">C源代码链接</a><br><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/02_%E6%A0%88" target="_blank" rel="noopener">java源代码链接</a></p></blockquote></the>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> Array </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 102. Binary Tree Level Order Traversal</title>
      <link href="/2019/01/05/leetcode-102-Binary-Tree-Level-Order-Traversal/"/>
      <url>/2019/01/05/leetcode-102-Binary-Tree-Level-Order-Traversal/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="102"><li>Binary Tree Level Order Traversal:<a href="https://leetcode.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">题目链接</a>  </li></ol><h2 id="方法1：beat4-79-time-4ms"><a href="#方法1：beat4-79-time-4ms" class="headerlink" title="方法1：beat4.79% time:4ms"></a>方法1：beat4.79% time:4ms</h2><p><strong><code>基本思路：</code></strong> 构造一个类或结构体记录当前节点cur 和 当前节点所在层level的信息（cur，level），如根节点root(root,0),用广度优先遍历根据当前节点的level来</p>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> tree </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>栈详解</title>
      <link href="/2018/11/28/%E6%A0%88%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/11/28/%E6%A0%88%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><blockquote><font style="font-weight: bold; color: #FF0000;">栈的特点：后进先出  Last In First Out(LIFO)</font><br><font style="font-weight: bold; color: #FF0000;">相比数组，栈对应的操作是数组的子集</font><br><font style="font-weight: bold; color: #FF0000;">只能从栈顶添加元素，删除元素</font>  </blockquote><h2 id="顺序栈-动态数组"><a href="#顺序栈-动态数组" class="headerlink" title="顺序栈-动态数组"></a>顺序栈-动态数组</h2><p><strong><code>节点定义：</code></strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不能动态伸缩数组的节点定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    E data[capacity];</span><br><span class="line">    <span class="keyword">int</span> top;</span><br><span class="line">&#125; ArrayStack;</span><br></pre></td></tr></table></figure></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> E int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INITSIZE 10                    <span class="comment">// 数组的初始大小</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态增长或缩减顺序栈的节点定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    E *data;        <span class="comment">// 数组基址</span></span><br><span class="line">    <span class="keyword">int</span> capacity;   <span class="comment">// 数组的最大容量</span></span><br><span class="line">    <span class="keyword">int</span> top;        <span class="comment">// 栈顶指针  指向数组最后一个元素的下标  初始时为空：-1  有一个元素：0 以此类推</span></span><br><span class="line">&#125; ArrayStack;</span><br></pre></td></tr></table></figure><p><strong><code>相关操作：</code></strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化栈  top等于-1时 表示栈空    top等于MAXSIZE-1时 表示栈满</span></span><br><span class="line"><span class="function">ArrayStack *<span class="title">initStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ArrayStack *<span class="built_in">stack</span> = (ArrayStack *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ArrayStack));</span><br><span class="line">    <span class="built_in">stack</span>-&gt;data = (E *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(E) * INITSIZE);</span><br><span class="line">    <span class="built_in">stack</span>-&gt;capacity = INITSIZE;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顺序栈是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isEmpty</span><span class="params">(ArrayStack *<span class="built_in">stack</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span> == <span class="built_in">stack</span>-&gt;top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取顺序栈中元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">(ArrayStack *<span class="built_in">stack</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取顺序栈的最大容量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getCapacity</span><span class="params">(ArrayStack *<span class="built_in">stack</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印栈信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMessage</span><span class="params">(ArrayStack *<span class="built_in">stack</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">stack</span>))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"printMessage failed. stack is empty.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Array:size = %d  , capacity = %d \n"</span>, getSize(<span class="built_in">stack</span>), getCapacity(<span class="built_in">stack</span>));</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"stack : ["</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="built_in">stack</span>-&gt;top; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, <span class="built_in">stack</span>-&gt;data[i]);</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="built_in">stack</span>-&gt;top) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">", "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"] top\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong><code>入栈：</code></strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将数组空间的容量扩容成newCapacity大小  O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(ArrayStack *<span class="built_in">stack</span>, <span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    E *newData = (E *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(E) * newCapacity);</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= <span class="built_in">stack</span>-&gt;top; ++i) &#123;</span><br><span class="line">        newData[i] = <span class="built_in">stack</span>-&gt;data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;data = newData;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;capacity = newCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入栈 不算resize()   O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(ArrayStack *<span class="built_in">stack</span>, E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stack</span>-&gt;top + <span class="number">1</span> == <span class="built_in">stack</span>-&gt;capacity) &#123; <span class="comment">// 栈满</span></span><br><span class="line">        resize(<span class="built_in">stack</span>, <span class="number">2</span> * <span class="built_in">stack</span>-&gt;capacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;top++;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;data[<span class="built_in">stack</span>-&gt;top] = e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong><code>出栈：</code></strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 出栈 并返回出栈元素  O(1) 并没有真正的删除栈顶元素 只是改变了栈顶指针的指向</span></span><br><span class="line"><span class="function">E <span class="title">pop</span><span class="params">(ArrayStack *<span class="built_in">stack</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">stack</span>))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"pop failed. stack is empty.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-9999999</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    E res = <span class="built_in">stack</span>-&gt;data[<span class="built_in">stack</span>-&gt;top];</span><br><span class="line">    <span class="built_in">stack</span>-&gt;top--;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stack</span>-&gt;top + <span class="number">1</span> == <span class="built_in">stack</span>-&gt;capacity / <span class="number">2</span>) &#123;</span><br><span class="line">        resize(<span class="built_in">stack</span>, <span class="built_in">stack</span>-&gt;capacity / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong><code>获取栈顶元素：</code></strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取栈顶元素  O(1)</span></span><br><span class="line"><span class="function">E <span class="title">peek</span><span class="params">(ArrayStack *<span class="built_in">stack</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">stack</span>))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"peek failed. stack is empty.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-9999999</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;data[<span class="built_in">stack</span>-&gt;top];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="链式栈"><a href="#链式栈" class="headerlink" title="链式栈"></a>链式栈</h2><font style="font-weight: bold; color: #FF0000;">首先链式栈 一般都定义为 有结构体包着 并且 只有头指针 没有头结点</font> <p><strong><code>节点定义如下：</code></strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> E int</span></span><br><span class="line"><span class="comment">// 链式栈节点定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stackNode</span>&#123;</span></span><br><span class="line">    E data;     <span class="comment">// 数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stackNode</span> * <span class="title">next</span>;</span> <span class="comment">// 指针域</span></span><br><span class="line">&#125;StackNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    StackNode * top; <span class="comment">// 栈顶指针</span></span><br><span class="line">&#125;LinkStack;</span><br></pre></td></tr></table></figure></p><blockquote><p>为什么会这样定义呢？看下面几种情况</p></blockquote><div align="center" style="zoom: 70%; margin:  0px auto;"><img src="/2018/11/28/栈详解/Stack_1.png" alt="原理"></div>  <div align="center" style="zoom: 70%; margin:  0px auto;"><img src="/2018/11/28/栈详解/Stack_2.png" alt="原理"></div>  <div align="center" style="zoom: 70%; margin:  0px auto;"><img src="/2018/11/28/栈详解/Stack_3.png" alt="原理"></div>  <font style="font-weight: bold; color: #FF0000;">2，3起到的效果都是一样的，栈一般都是不带头结点的，栈是往前插上节点，头结点的功能除了在插入的时候有用，在其他操作并没有发挥功效，但是后插的操作比如链表、队列，明显有头结点，操控要简单点</font> <p><strong><code>LinkedStack.c</code></strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> E int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR -999999</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 链式栈节点定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">stackNode</span>&#123;</span></span><br><span class="line">    E data;     <span class="comment">// 数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stackNode</span> * <span class="title">next</span>;</span> <span class="comment">// 指针域</span></span><br><span class="line">&#125;StackNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    StackNode * top; <span class="comment">// 栈顶指针</span></span><br><span class="line">    <span class="keyword">int</span> size;        <span class="comment">// 栈中元素个数  加入size变量可以使求长度操作的复杂度从O(N)降为O(1)</span></span><br><span class="line">                     <span class="comment">// 不需要遍历求链栈长度 只需要花费一点时间维护size</span></span><br><span class="line">&#125;LinkedStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建链栈</span></span><br><span class="line"><span class="function">LinkedStack * <span class="title">createStack</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LinkedStack *<span class="built_in">stack</span> = (LinkedStack *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkedStack));</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">stack</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"malloc is failed.\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;top = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取链式栈大小   O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">(LinkedStack * <span class="built_in">stack</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//// 链栈的长度  O(N)  不加size时</span></span><br><span class="line"><span class="comment">//int getSize(LinkStack * stack)&#123;</span></span><br><span class="line"><span class="comment">//    stackNode * curNode = stack-&gt;top;</span></span><br><span class="line"><span class="comment">//    int count = 0;</span></span><br><span class="line"><span class="comment">//    while (curNode-&gt;next != NULL) &#123;</span></span><br><span class="line"><span class="comment">//        count++;</span></span><br><span class="line"><span class="comment">//        curNode = curNode-&gt;next;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"><span class="comment">//    return count;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回链式栈是否为空   O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isEmpty</span><span class="params">(LinkedStack * <span class="built_in">stack</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> == <span class="built_in">stack</span>-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入栈 O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(LinkedStack * <span class="built_in">stack</span>, E data)</span></span>&#123;</span><br><span class="line">    StackNode *newNode = (StackNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackNode));</span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    newNode-&gt;next = <span class="built_in">stack</span>-&gt;top;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;top = newNode;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 出栈  O(1)</span></span><br><span class="line"><span class="function">E <span class="title">pop</span><span class="params">(LinkedStack * <span class="built_in">stack</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">stack</span>))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"LinkStack is empty, pop is failed.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    StackNode * delNode = <span class="built_in">stack</span>-&gt;top; <span class="comment">// 待出栈节点</span></span><br><span class="line">    E res= delNode-&gt;data; <span class="comment">// 出栈节点的数据域</span></span><br><span class="line">    <span class="built_in">stack</span>-&gt;top = delNode-&gt;next; <span class="comment">// 栈顶指针指向待出栈节点的后一个节点</span></span><br><span class="line">    <span class="built_in">free</span>(delNode); <span class="comment">// 释放待出栈节点</span></span><br><span class="line">    delNode = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;size--;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取栈顶元素  O(1)</span></span><br><span class="line"><span class="function">E <span class="title">peek</span><span class="params">(LinkedStack * <span class="built_in">stack</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">stack</span>))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"peek failed. LinkedStack is empty.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-9999999</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印栈信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMessage</span><span class="params">(LinkedStack * <span class="built_in">stack</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">stack</span>))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"printMessage failed. LinkedStack is empty.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    StackNode * curNode = <span class="built_in">stack</span>-&gt;top;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"LinkedStack is: top "</span>);</span><br><span class="line">    <span class="keyword">while</span> (curNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d -&gt; "</span>, curNode-&gt;data);</span><br><span class="line">        curNode = curNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"NULL \n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    LinkedStack *<span class="built_in">stack</span> = createStack();</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        push(<span class="built_in">stack</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"size: %d  peek: %d\n"</span>, getSize(<span class="built_in">stack</span>), peek(<span class="built_in">stack</span>));</span><br><span class="line">    printMessage(<span class="built_in">stack</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"------------\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"pop: %d\n"</span>,pop(<span class="built_in">stack</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"size: %d  peek: %d\n"</span>, getSize(<span class="built_in">stack</span>), peek(<span class="built_in">stack</span>));</span><br><span class="line">    printMessage(<span class="built_in">stack</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"------------\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h2><ol><li>undo操作(撤回) - 编译器</li><li>系统调用栈 - 操作系统</li><li>括号匹配 - 编译器</li></ol><blockquote><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/02_%E6%A0%88" target="_blank" rel="noopener">C源代码链接</a><br><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/02_%E6%A0%88" target="_blank" rel="noopener">java源代码链接</a></p></blockquote></the>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Stack </tag>
            
            <tag> C </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>二分搜索树(二叉搜索树)</title>
      <link href="/2018/11/25/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91C%E7%89%88/"/>
      <url>/2018/11/25/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91C%E7%89%88/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="二分搜索树"><a href="#二分搜索树" class="headerlink" title="二分搜索树"></a>二分搜索树</h2><ul><li><font style="font-weight: bold; color: #FF0000;">二叉树具有天然的递归结构，二分搜索树也是二叉树</font> </li><li><font style="font-weight: bold; color: #FF0000;">二分搜索树的每个节点的值大于其左子树的所有节点的值，小于其右子树的所有节点的值</font> </li><li><font style="font-weight: bold; color: #FF0000;">每一颗子树也是二分搜索树</font>  </li><li><font style="font-weight: bold; color: #FF0000;">存储的元素必须有<strong><code>可比较性</code></strong></font> </li><li><font style="font-weight: bold; color: #FF0000;">一定是二叉树</font> </li><li><font style="font-weight: bold; color: #FF0000;">一定不会有相同的结点(考试的时候)  如果想要<strong><code>包含重复元素</code></strong>，只需要定义：<strong><code>左子树小于等于节点或者是右子树大于等于节点</code></strong>   </font> </li><li><font style="font-weight: bold; color: #FF0000;"><strong><code>特点：</code></strong>对其中序遍历  可以得到一个 从小到大 的序列 </font> </li><li><font style="font-weight: bold; color: #FF0000;"><strong><code>最小元素</code></strong>一定在<strong><code>最左边</code></strong>分支的端结点上 <strong><code>最大元素</code></strong>一定在<strong><code>最右边</code></strong>分支的端结点上 </font></li></ul><div align="left" style="zoom: 80%; margin:  0px auto;"><img src="/2018/11/25/二叉搜索树C版/BST_1.png" alt="原理"></div>  <p><strong><code>节点构造：</code></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#define E int</span><br><span class="line"></span><br><span class="line">typedef struct Node &#123;</span><br><span class="line">    E data;</span><br><span class="line">    struct Node *left;</span><br><span class="line">    struct Node *right;</span><br><span class="line">&#125; BSTNode;</span><br></pre></td></tr></table></figure></p><h2 id="二分搜索树-插入节点"><a href="#二分搜索树-插入节点" class="headerlink" title="二分搜索树 插入节点"></a>二分搜索树 插入节点</h2><div><font style="font-weight: bold; color: #FF0000;">我们的二分搜索树不包含重复元素</font> 如果想要<strong><code>包含重复元素</code></strong>，只需要定义：<strong><code>左子树小于等于节点或者是右子树大于等于节点</code></strong> </div><br><font style="font-weight: bold; color: #FF0000;">新插入的节点总是叶子节点</font>   <strong><code>插入data = 9</code></strong><br><div align="left" style="zoom: 80%; margin:  0px auto;"><img src="/2018/11/25/二叉搜索树C版/BST_insert.gif" alt="原理"></div>  <p><strong><code>基本思想：</code></strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 插入结点  插入（找前驱）</span></span><br><span class="line"><span class="comment"> *   基本思想：</span></span><br><span class="line"><span class="comment"> *      1.如果二叉搜索树此时为空 则将插入结点当成新的根节点</span></span><br><span class="line"><span class="comment"> *      2.若二叉搜索树非空 从树根开始找 插入的值大于根结点 往根节点右边找</span></span><br><span class="line"><span class="comment"> *                                  插入的值小于根节点 往根节点左边找</span></span><br><span class="line"><span class="comment"> *                                  插入的值等于根节点 说明之前就有这个 值 结束插入</span></span><br><span class="line"><span class="comment"> *                                  直到为空NULL 此时找到了要插入结点的前驱结点</span></span><br><span class="line"><span class="comment"> *      3.若插入结点的值大于前驱结点 接到 前驱节点的右孩子域   小于前驱结点 接到左孩子域</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p><p><strong><code>插入：</code></strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入 往二分搜索树中插入 数据</span></span><br><span class="line"><span class="function">BSTNode * <span class="title">add</span><span class="params">(BSTNode * pT, E data)</span></span>&#123;</span><br><span class="line">    BSTNode *pre = <span class="literal">NULL</span>, *cur = <span class="literal">NULL</span>;  <span class="comment">// cur:当前遍历到的节点  pre：cur的前驱</span></span><br><span class="line"></span><br><span class="line">    BSTNode *newNode = (BSTNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSTNode)); <span class="comment">// 创建 data节点并将左子域 右子域置NULL</span></span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    newNode-&gt;left = newNode-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pT == <span class="literal">NULL</span>)&#123;    <span class="comment">// 树空</span></span><br><span class="line">        pT = newNode; <span class="comment">// data所在的节点成为新的根节点</span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        cur = pT; <span class="comment">// 当前节点指向根节点  这样可以不改变根节点的地址</span></span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">NULL</span>) &#123; <span class="comment">// 遍历二分搜索树</span></span><br><span class="line">            <span class="keyword">if</span> (data &lt; cur-&gt;data) &#123; <span class="comment">// data 比当前结点值小 去左子树找 并更新 pre cur的值</span></span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data &gt; cur-&gt;data) &#123; <span class="comment">// data 比当前结点值大 去右子树找 并更新 pre cur的值</span></span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123; <span class="comment">// data == cur-&gt;data  说明二分搜索树中已经有了这个节点 书上的二分索搜树是不包含重复元素的</span></span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 如果想包含重复元素 将break去掉加上 pre = cur; cur = cur-&gt;left?cur-&gt;left:cur-&gt;right;</span></span><br><span class="line">                       <span class="comment">// 并修改下面data &lt; pre-&gt;data</span></span><br><span class="line">                       <span class="comment">// 想挂在重复节点的左孩子域  data &lt; pre-&gt;data 改成 data &lt;= pre-&gt;data</span></span><br><span class="line">                       <span class="comment">// 想挂在重复节点的右孩子域  data &gt; pre-&gt;data 改成 data &gt;= pre-&gt;data</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时cur == NULL 说明找到了cur应在的位置 只需连接到其前驱节点就行了  插入的节点由于二分搜索树的特性都是 叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> (data &lt; pre-&gt;data) &#123;</span><br><span class="line">            pre-&gt;left = newNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data &gt; pre-&gt;data) &#123;</span><br><span class="line">            pre-&gt;right = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong><code>递归插入：</code></strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 向以pT为根的二分搜索树中插入节点</span></span><br><span class="line"><span class="comment">// 递归宏观语义：返回插入data后以data为根节点的二分搜索树</span></span><br><span class="line"><span class="function">BSTNode *<span class="title">add_recursion</span><span class="params">(BSTNode *pT, E data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pT == <span class="literal">NULL</span>) &#123;     <span class="comment">// 递归到最底层(包含树空的情况) 就是data节点应该在的位置</span></span><br><span class="line">        <span class="comment">// 创建data所在的节点</span></span><br><span class="line">        BSTNode *newNode = (BSTNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BSTNode));</span><br><span class="line">        newNode-&gt;data = data;</span><br><span class="line">        newNode-&gt;left = newNode-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果想包含重复元素 重复元素在左子域 data &lt;= pT-&gt;data 在右子域 data &gt;= pT-&gt;data</span></span><br><span class="line">    <span class="keyword">if</span> (data &lt; pT-&gt;data) &#123; <span class="comment">// 如果data比当前节点小, 去左子树找,并更新左子树</span></span><br><span class="line">        pT-&gt;left = add_recursion(pT-&gt;left, data);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data &gt; pT-&gt;data) &#123;  <span class="comment">// 如果data比当前节点大,去右子树找,并更新右子树</span></span><br><span class="line">        pT-&gt;right = add_recursion(pT-&gt;right, data);</span><br><span class="line">    &#125;  <span class="comment">// data = pT-&gt;data 因为我们写的二分搜索树不包含重复元素 所以此处不做任何操作</span></span><br><span class="line">    <span class="keyword">return</span> pT;  <span class="comment">// 此处一定要返回pT  画图体会</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="二分搜索树创建-基于插入算法"><a href="#二分搜索树创建-基于插入算法" class="headerlink" title="二分搜索树创建 基于插入算法"></a>二分搜索树创建 基于插入算法</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建二分搜索树 基于 插入元素</span></span><br><span class="line"><span class="function">BSTNode * <span class="title">createBST</span><span class="params">(E * nums, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    BSTNode *pT = <span class="literal">NULL</span>;         <span class="comment">// 这里不能malloc 初始为空</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">        pT = add(pT, nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">5</span>;</span><br><span class="line">    E nums[len] = &#123;<span class="number">5</span>, <span class="number">4</span>, <span class="number">20</span>, <span class="number">17</span>, <span class="number">18</span>&#125;;</span><br><span class="line">    BSTNode * bst = createBST(nums, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分搜索树-前序-中序-后序遍历-深度优先"><a href="#二分搜索树-前序-中序-后序遍历-深度优先" class="headerlink" title="二分搜索树 前序 中序 后序遍历(深度优先)"></a>二分搜索树 前序 中序 后序遍历(深度优先)</h2><p><strong><code>前序遍历：</code></strong> <font style="font-weight: bold; color: #FF0000;">根 -&gt; 左 -&gt; 右</font><br><strong><code>中序遍历：</code></strong> <font style="font-weight: bold; color: #FF0000;">左 -&gt; 根 -&gt; 右</font><br><strong><code>后序遍历：</code></strong> <font style="font-weight: bold; color: #FF0000;">左 -&gt; 右 -&gt; 根</font> </p><p><strong><code>递归算法:</code></strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归宏观语义：求以pT为根节点的二分搜索树的前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder_recursion</span><span class="params">(BSTNode *pT)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pT == <span class="literal">NULL</span>) &#123;   <span class="comment">// 递归到最底层  树空</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, pT-&gt;data);        <span class="comment">// 打印根节点</span></span><br><span class="line">    preOrder_recursion(pT-&gt;left);     <span class="comment">// 递归遍历左子树</span></span><br><span class="line">    preOrder_recursion(pT-&gt;right);    <span class="comment">// 递归遍历右子树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归宏观语义：求以pT为根节点的二分搜索树的中序序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder_recursion</span><span class="params">(BSTNode *pT)</span> </span>&#123;</span><br><span class="line"><span class="comment">//    if (pT == NULL) &#123;   // 递归到最底层  树空</span></span><br><span class="line"><span class="comment">//        return;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="keyword">if</span> (pT) &#123;</span><br><span class="line">        inOrder_recursion(pT-&gt;left);     <span class="comment">// 递归遍历左子树</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, pT-&gt;data);        <span class="comment">// 打印根节点</span></span><br><span class="line">        inOrder_recursion(pT-&gt;right);    <span class="comment">// 递归遍历右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归宏观语义：求以pT为根节点的二分搜索树的后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder_recursion</span><span class="params">(BSTNode *pT)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pT == <span class="literal">NULL</span>) &#123;   <span class="comment">// 递归到最底层  树空</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    postOrder_recursion(pT-&gt;left);     <span class="comment">// 递归遍历左子树</span></span><br><span class="line">    postOrder_recursion(pT-&gt;right);    <span class="comment">// 递归遍历右子树</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, pT-&gt;data);        <span class="comment">// 打印根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong><code>非递归算法：适用于先序 中序 后序：</code></strong><a href="https://xerdemo.github.io/2018/11/18/%E6%A0%88%E4%B8%8E%E9%80%92%E5%BD%92%E7%B4%A7%E5%AF%86%E7%9A%84%E8%81%94%E7%B3%BB/">利用栈模拟系统栈实现非递归：点击这里</a><br><strong>借助栈 栈的内容如下：</strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 栈的节点定义以及操作  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *s;              <span class="comment">// 二分搜索树结点的描叙性信息 go：访问 print：打印</span></span><br><span class="line">    BSTNode* data;        <span class="comment">// 二分搜索树节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">Next</span>;</span></span><br><span class="line">&#125; StackNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line">    StackNode *pTop;</span><br><span class="line">&#125; LinkStack;</span><br><span class="line"></span><br><span class="line"><span class="function">LinkStack *<span class="title">createStack</span><span class="params">()</span> </span>&#123; <span class="comment">// 创建栈</span></span><br><span class="line">    LinkStack *pS = (LinkStack *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkStack));</span><br><span class="line">    pS-&gt;pTop = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(LinkStack *pS, <span class="keyword">char</span> *s, BSTNode* data)</span> </span>&#123; <span class="comment">// 入栈 压入 该节点的描叙字符 和 该节点</span></span><br><span class="line">    StackNode *newNode = (StackNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackNode));</span><br><span class="line">    newNode-&gt;Next = pS-&gt;pTop;</span><br><span class="line">    newNode-&gt;s = s;</span><br><span class="line">    newNode-&gt;data = data;</span><br><span class="line">    pS-&gt;pTop = newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">emptyStack</span><span class="params">(LinkStack *pS)</span> </span>&#123; <span class="comment">// 判断栈是否为空</span></span><br><span class="line">    <span class="keyword">return</span> pS-&gt;pTop == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(LinkStack *pS, <span class="keyword">char</span> **s, BSTNode **data)</span> </span>&#123; <span class="comment">// 出栈</span></span><br><span class="line">    <span class="keyword">if</span> (pS-&gt;pTop == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    StackNode *temp = pS-&gt;pTop;</span><br><span class="line">    *s = temp-&gt;s;</span><br><span class="line">    *data = temp-&gt;data;</span><br><span class="line">    pS-&gt;pTop = temp-&gt;Next;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong><code>非递归遍历通用算法：模拟系统栈</code></strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非递归先序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(BSTNode *pT)</span> </span>&#123;</span><br><span class="line">    LinkStack *<span class="built_in">stack</span> = createStack();</span><br><span class="line">    <span class="keyword">char</span> *s = <span class="literal">NULL</span>;   <span class="comment">// s : 入栈的这个指令的信息 "go":访问这个节点   "print":打印这个节点的值</span></span><br><span class="line">    BSTNode *node = <span class="literal">NULL</span>;</span><br><span class="line">    push(<span class="built_in">stack</span>, <span class="string">"go"</span>, pT);  <span class="comment">// 根节点入栈</span></span><br><span class="line">    <span class="keyword">while</span> (!emptyStack(<span class="built_in">stack</span>)) &#123; <span class="comment">// 栈不空</span></span><br><span class="line">        pop(<span class="built_in">stack</span>, &amp;s, &amp;node); <span class="comment">// 取出栈顶节点 看有什么指令</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="string">"print"</span>) &#123; <span class="comment">// 打印其节点值</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, node-&gt;data);</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123; <span class="comment">// s == "go" 访问</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right != <span class="literal">NULL</span>) &#123;               <span class="comment">// ①   访问右子树 右</span></span><br><span class="line">                push(<span class="built_in">stack</span>, <span class="string">"go"</span>, node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left != <span class="literal">NULL</span>) &#123;                <span class="comment">// ②   访问左子树 左</span></span><br><span class="line">                push(<span class="built_in">stack</span>, <span class="string">"go"</span>, node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            push(<span class="built_in">stack</span>, <span class="string">"print"</span>, node);              <span class="comment">// ③   访问根节点 根</span></span><br><span class="line">            <span class="comment">// 因为栈的特性 后进先出  入栈顺序 右-&gt; 左 -&gt; 根 对应实际执行顺序 根 -&gt; 左 -&gt; 右 (先序)</span></span><br><span class="line">            <span class="comment">//                      入栈顺序 右-&gt; 根 -&gt; 左 对应实际执行顺序 左 -&gt; 根 -&gt; 右 (中序)</span></span><br><span class="line">            <span class="comment">//                      入栈顺序 根-&gt; 右 -&gt; 左 对应实际执行顺序 左 -&gt; 右 -&gt; 根 (后序)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><div align="left" style="zoom: 80%; margin:  0px auto;"><img src="/2018/11/25/二叉搜索树C版/BST_result.png" alt="原理"></div> <h2 id="二分搜索树-层次遍历-广度优先遍历"><a href="#二分搜索树-层次遍历-广度优先遍历" class="headerlink" title="二分搜索树 层次遍历(广度优先遍历)"></a>二分搜索树 层次遍历(广度优先遍历)</h2><p><strong><code>基本思想：</code></strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 层次遍历 广度优先遍历 队列</span></span><br><span class="line"><span class="comment"> *   基本思想： 从整个树的根节点开始 如果树不为空 将根节点入队</span></span><br><span class="line"><span class="comment"> *             如果队列不为空 出队  打印出队元素的值</span></span><br><span class="line"><span class="comment"> *             如果出队元素左孩子不为空 入队  右孩子不为空 入队  直到队列为空为止</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p><p><strong><code>借助队列：队列内容如下</code></strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 队列的节点定义以及操作</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">qnode</span>&#123;</span></span><br><span class="line">    BSTNode * data;         <span class="comment">// 数据域存放的是 BSTnode节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">qnode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;QueueNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    QueueNode * front;</span><br><span class="line">    QueueNode * rear;</span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="function">LinkQueue * <span class="title">createQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LinkQueue *pQ = (LinkQueue *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkQueue));</span><br><span class="line">    pQ-&gt;front = pQ-&gt;rear = (QueueNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QueueNode));</span><br><span class="line">    pQ-&gt;rear-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> pQ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addQueue</span><span class="params">(LinkQueue * pQ, BSTNode * node)</span></span>&#123;</span><br><span class="line">    QueueNode *newNode = (QueueNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QueueNode));</span><br><span class="line">    newNode-&gt;data = node;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    pQ-&gt;rear-&gt;next = newNode;</span><br><span class="line">    pQ-&gt;rear = newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">emptyQueue</span><span class="params">(LinkQueue * pQ)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pQ-&gt;front == pQ-&gt;rear;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BSTNode * <span class="title">removeQueue</span><span class="params">(LinkQueue * pQ)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (emptyQueue(pQ)) &#123; <span class="comment">// 队列空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    QueueNode *temp = pQ-&gt;front-&gt;next;</span><br><span class="line">    BSTNode *data = temp-&gt;data;</span><br><span class="line">    pQ-&gt;front-&gt;next = temp-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (temp == pQ-&gt;rear) &#123; <span class="comment">// 队列中只有一个节点 被删除的情况</span></span><br><span class="line">        pQ-&gt;rear = pQ-&gt;front ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong><code>层次遍历：广度优先</code></strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 层次遍历 借用队列  (广度优先遍历)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(BSTNode *pT)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pT == <span class="literal">NULL</span>) &#123; <span class="comment">// 二分搜索树空</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkQueue *<span class="built_in">queue</span> = createQueue();</span><br><span class="line">    addQueue(<span class="built_in">queue</span>, pT);  <span class="comment">// 根节点入队</span></span><br><span class="line">    <span class="keyword">while</span> (!emptyQueue(<span class="built_in">queue</span>)) &#123; <span class="comment">// 队列不空</span></span><br><span class="line">        BSTNode *node = removeQueue(<span class="built_in">queue</span>); <span class="comment">// 取出队首节点</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, node-&gt;data);  <span class="comment">// 打印</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left != <span class="literal">NULL</span>) &#123;  <span class="comment">// 左子树不空 压入队列</span></span><br><span class="line">            addQueue(<span class="built_in">queue</span>, node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right != <span class="literal">NULL</span>) &#123; <span class="comment">// 右子树不空 压入队列</span></span><br><span class="line">            addQueue(<span class="built_in">queue</span>, node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="二分搜索树-查找元素"><a href="#二分搜索树-查找元素" class="headerlink" title="二分搜索树 查找元素"></a>二分搜索树 查找元素</h2><p><strong><code>基本思想：</code></strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 查找data 所在的位置(地址)</span></span><br><span class="line"><span class="comment"> *    基本思想：从树根开始找 如果data比根节点的data大 往根节点右边找</span></span><br><span class="line"><span class="comment"> *                         如果data比根节点的data小 往根节点左边找</span></span><br><span class="line"><span class="comment"> *                         如果data == 根结点的data  找到了</span></span><br><span class="line"><span class="comment"> *                         如果上述情况都不是 则不存在data这个结点</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p><p><strong><code>查找：</code></strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找元素data的位置</span></span><br><span class="line"><span class="function">BSTNode *<span class="title">find</span><span class="params">(BSTNode *pT, E data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pT == <span class="literal">NULL</span>) &#123;   <span class="comment">// 树空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="comment">/* else &#123;</span></span><br><span class="line"><span class="comment">        BSTNode *cur = pT;</span></span><br><span class="line"><span class="comment">        while (cur != NULL) &#123;</span></span><br><span class="line"><span class="comment">            if (data &lt; cur-&gt;data) &#123;</span></span><br><span class="line"><span class="comment">                cur = cur-&gt;left;</span></span><br><span class="line"><span class="comment">            &#125; else if (data &gt; cur-&gt;data) &#123;</span></span><br><span class="line"><span class="comment">                cur = cur-&gt;right;</span></span><br><span class="line"><span class="comment">            &#125; else &#123; // data == cur_&gt;data 找到了</span></span><br><span class="line"><span class="comment">                return cur;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="comment">// 上面的写法可以换种形式 更简洁</span></span><br><span class="line">    BSTNode *cur = pT;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (data == cur-&gt;data) &#123; <span class="comment">// 找到了</span></span><br><span class="line">            <span class="keyword">return</span> cur;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = data &lt; cur-&gt;data ? cur-&gt;left : cur-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 没有找到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong><code>递归算法:</code></strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找元素data</span></span><br><span class="line"><span class="comment">// 递归宏观语义: 返回在以pT为根的二分搜索树中 含有data的节点的地址</span></span><br><span class="line"><span class="function">BSTNode * <span class="title">find</span><span class="params">(BSTNode * pT, E data)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pT == <span class="literal">NULL</span>)&#123;    <span class="comment">// 递归到底 发现都没找到data</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (data == pT-&gt;data) &#123; <span class="comment">// 找到了 返回</span></span><br><span class="line">        <span class="keyword">return</span> pT;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data &lt; pT-&gt;data) &#123; <span class="comment">// data小于当前节点的值 去左子树找</span></span><br><span class="line">        <span class="keyword">return</span> find(pT-&gt;left, data);</span><br><span class="line">    &#125; <span class="keyword">else</span>&#123;  <span class="comment">// data 大于当前节点的值 去右子树找</span></span><br><span class="line">        <span class="keyword">return</span> find(pT-&gt;right, data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="二分搜索树-查最大值"><a href="#二分搜索树-查最大值" class="headerlink" title="二分搜索树 查最大值"></a>二分搜索树 查最大值</h2><p><strong><code>基本思想：</code></strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 查找最大值：</span></span><br><span class="line"><span class="comment"> *     基本思想：一路从根节点往右边查 直到 为空  最右边那个结点就是最大值</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p><p><strong><code>查找最大值节点：</code></strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找最大值节点</span></span><br><span class="line"><span class="function">BSTNode *<span class="title">findMax</span><span class="params">(BSTNode *pT)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pT == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    BSTNode *cur = pT;</span><br><span class="line">    <span class="keyword">while</span> (cur-&gt;right != <span class="literal">NULL</span>) &#123;  <span class="comment">// 沿右分支一直向下，直到最右端点</span></span><br><span class="line">        cur = cur-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong><code>递归：</code></strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找最大值 递归算法</span></span><br><span class="line"><span class="comment">// 递归宏观语义: 返回以pT为根的二分搜索树的最大值所在的节点</span></span><br><span class="line"><span class="function">BSTNode *<span class="title">findMax_recursion</span><span class="params">(BSTNode *pT)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pT-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> pT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> findMax_recursion(pT-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="二分搜索树-查最小值节点"><a href="#二分搜索树-查最小值节点" class="headerlink" title="二分搜索树 查最小值节点"></a>二分搜索树 查最小值节点</h2><p><strong><code>基本思想：</code></strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 查找最小值：</span></span><br><span class="line"><span class="comment"> *     基本思想：一路从根节点往左边查 直到 为空  最左边那个结点是最小值</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p><p><strong><code>查找最小值节点：</code></strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找最小值节点</span></span><br><span class="line"><span class="function">BSTNode *<span class="title">findMin</span><span class="params">(BSTNode *pT)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pT == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    BSTNode *cur = pT;</span><br><span class="line">    <span class="keyword">while</span> (cur-&gt;left != <span class="literal">NULL</span>) &#123;  <span class="comment">// 沿左分支一直向下，直到最左端点</span></span><br><span class="line">        cur = cur-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong><code>递归：</code></strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找最小值 递归算法</span></span><br><span class="line"><span class="comment">// 递归宏观语义: 返回以pT为根的二分搜索树的最小值所在的节点</span></span><br><span class="line"><span class="function">BSTNode *<span class="title">findMin_recursion</span><span class="params">(BSTNode *pT)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pT-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> pT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> findMin_recursion(pT-&gt;left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="二分搜索树-删除最小值节点"><a href="#二分搜索树-删除最小值节点" class="headerlink" title="二分搜索树 删除最小值节点"></a>二分搜索树 删除最小值节点</h2><p><strong><code>递归:</code></strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归删除最小值节点</span></span><br><span class="line"><span class="comment">// 返回删除最小值后 新的二分搜索树的根</span></span><br><span class="line"><span class="function">BSTNode *<span class="title">removeMin_recursion</span><span class="params">(BSTNode *pT)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pT-&gt;left == <span class="literal">NULL</span>) &#123; <span class="comment">// 递归到底</span></span><br><span class="line">        BSTNode *rightNode = pT-&gt;right;</span><br><span class="line">        pT-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">free</span>(pT);</span><br><span class="line">        <span class="keyword">return</span> rightNode;</span><br><span class="line">    &#125;</span><br><span class="line">    pT-&gt;left = removeMin_recursion(pT-&gt;left);</span><br><span class="line">    <span class="keyword">return</span> pT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="二分搜索树-删除任意节点"><a href="#二分搜索树-删除任意节点" class="headerlink" title="二分搜索树 删除任意节点"></a>二分搜索树 删除任意节点</h2><p><strong><code>基本思想：</code></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 删除结点</span><br><span class="line"> *    基本思想：</span><br><span class="line"> *    * 删除结点 3种情况</span><br><span class="line"> *    1.删除的是叶子节点</span><br><span class="line"> *        将其父节点对应的指针域 设为NULL</span><br><span class="line"> *    2.删除的结点 只有一颗左子树或右子树</span><br><span class="line"> *        用子树的根节点取代被删除结点</span><br><span class="line"> *    3.删除的结点 有左右两颗子树  （2种方法）</span><br><span class="line"> *        1）中序直接前驱法：将被删除结点的中序遍历的直接前驱结点 取代删除结点</span><br><span class="line"> *        2）中序直接后继法：将被删除结点的中序遍历的直接后继结点 取代删除结点</span><br><span class="line"> *        找被删除点的前驱：从被删除点的左子树 一路向右  (被删结点左子树中的最大值)</span><br><span class="line"> *        找被删除点的后继：从被删除点的右子树 一路向左  (被删结点右子树中的最小值)</span><br><span class="line"> */</span><br></pre></td></tr></table></figure></p><p><strong><code>删除只有左孩子的节点：</code></strong> <strong>将节点58左子树的根节点50取代待删除节点</strong></p><div align="center" style="zoom: 80%; margin:  0px auto;"><img src="/2018/11/25/二叉搜索树C版/BST_remove1.gif" alt="原理"></div> <p><strong><code>删除只有右孩子的节点：</code></strong> <strong>将节点58右子树的根节点60取代待删除节点</strong></p><div align="center" style="zoom: 80%; margin:  0px auto;"><img src="/2018/11/25/二叉搜索树C版/BST_remove2.gif" alt="原理"></div> <p><strong><code>删除有左右子树的节点</code></strong> <strong>删除28  动画演示如下：</strong> <font style="font-weight: bold; color: #FF0000;">中序直接后继法</font> </p><ol><li><strong>采用中序直接后继法（中序直接前驱法一样的道理只是去找待删除节点左子树的最大值取代待删除节点</strong></li><li><strong>在待删除节点17右子树找到的最小值节点36(找到待删除节点的直接后继)</strong></li><li><strong>将最小值36的右子树的根节点37挂到36的父亲节点对应的位置</strong></li><li><strong>并将最小值节点36取代待删除节点，其右孩子指向待删除节点的右子树(此时右子树已经删除了最小值节点)，左孩子指向待删除节点的左子树，最后删掉待删除节点17</strong></li></ol><div align="center" style="zoom: 80%; margin:  0px auto;"><img src="/2018/11/25/二叉搜索树C版/BST_remove4.gif" alt="原理"></div> <p><strong><code>删除任意节点：</code></strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归删除最大值节点</span></span><br><span class="line"><span class="comment">// 返回删除最大值后 新的二分搜索树的根</span></span><br><span class="line"><span class="function">BSTNode *<span class="title">removeMax_recursion</span><span class="params">(BSTNode *pT)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pT-&gt;right == <span class="literal">NULL</span>) &#123; <span class="comment">// 递归到底</span></span><br><span class="line">        BSTNode *leftNode = pT-&gt;left;</span><br><span class="line">        pT-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">free</span>(pT);</span><br><span class="line">        <span class="keyword">return</span> leftNode;</span><br><span class="line">    &#125;</span><br><span class="line">    pT-&gt;right = removeMax_recursion(pT-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> pT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除掉以pT为根的二分搜索树中值为data的节点, 递归算法</span></span><br><span class="line"><span class="comment">// 返回删除节点后新的二分搜索树的根</span></span><br><span class="line"><span class="function">BSTNode *<span class="title">remove_recursion</span><span class="params">(BSTNode *pT, E data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pT == <span class="literal">NULL</span>) &#123;   <span class="comment">// 没有data这个节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (data &lt; pT-&gt;data) &#123; <span class="comment">// 去左子树递归删除</span></span><br><span class="line">        pT-&gt;left = remove_recursion(pT-&gt;left, data);</span><br><span class="line">        <span class="keyword">return</span> pT;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data &gt; pT-&gt;data) &#123; <span class="comment">// 去右子树递归删除</span></span><br><span class="line">        pT-&gt;right = remove_recursion(pT-&gt;right, data);</span><br><span class="line">        <span class="keyword">return</span> pT;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// data == pT-&gt;data 找到了data节点</span></span><br><span class="line">        <span class="keyword">if</span> (pT-&gt;left == <span class="literal">NULL</span>) &#123; <span class="comment">// 有右子树 || 左右子树都没有</span></span><br><span class="line">            BSTNode *rightNode = pT-&gt;right;</span><br><span class="line">            pT-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">free</span>(pT);</span><br><span class="line">            <span class="keyword">return</span> rightNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pT-&gt;right == <span class="literal">NULL</span>) &#123; <span class="comment">// 只有左子树</span></span><br><span class="line">            BSTNode *leftNode = pT-&gt;left;</span><br><span class="line">            pT-&gt;left = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="built_in">free</span>(pT);</span><br><span class="line">            <span class="keyword">return</span> leftNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 待删除节点左右子树均不为空的情况</span></span><br><span class="line">        <span class="comment">// 用中序直接后继法去右子树找到最小值节点 用它取代待删除节点</span></span><br><span class="line">        BSTNode *successor = findMin(pT-&gt;right);</span><br><span class="line">        <span class="comment">// 这里也可以写成successor-&gt;right = remove_recursion(pT-&gt;right，successor-&gt;data);</span></span><br><span class="line">        successor-&gt;right = removeMin_recursion(pT-&gt;right);</span><br><span class="line">        successor-&gt;left = pT-&gt;left;</span><br><span class="line">        pT-&gt;left = pT-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">free</span>(pT);</span><br><span class="line">        <span class="keyword">return</span> successor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong><code>leetcode对应习题</code></strong></p><blockquote><ol start="450"><li>Delete Node in a BST:<a href="https://leetcode.com/problems/delete-node-in-a-bst/" target="_blank" rel="noopener">题目链接</a></li><li>Kth Smallest Element in a BST:<a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/" target="_blank" rel="noopener">题目链接</a></li></ol></blockquote></the>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
            <tag> C </tag>
            
            <tag> Binary Search Tree </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>二分搜索树</title>
      <link href="/2018/11/22/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
      <url>/2018/11/22/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="二分搜索树初始化"><a href="#二分搜索树初始化" class="headerlink" title="二分搜索树初始化"></a>二分搜索树初始化</h2><ul><li><font style="font-weight: bold; color: #FF0000;">二分树具有天然的递归结构，二分搜索树也是二叉树</font> </li><li><font style="font-weight: bold; color: #FF0000;">二分搜索树的每个节点的值大于其左子树的所有节点的值，小于其右子树的所有节点的值</font> </li><li><font style="font-weight: bold; color: #FF0000;">每一颗子树也是二分搜索树</font>  </li><li><font style="font-weight: bold; color: #FF0000;">存储的元素必须有可比较性</font> </li><li><font style="font-weight: bold; color: #FF0000;">二分搜索树的中序遍历就是按从小到大的顺序</font> </li></ul><p><strong><code>初始化代码：</code></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class BST&lt;E extends Comparable&lt;E&gt;&gt; &#123; // 存储的元素必须有可比性</span><br><span class="line"></span><br><span class="line">    private class Node &#123;     // 用匿名内部类定义节点</span><br><span class="line">        public E e;</span><br><span class="line">        public Node left, right;</span><br><span class="line"></span><br><span class="line">        public Node(E e) &#123;   // 构造方法 对节点进行初始化操作</span><br><span class="line">            this.e = e;</span><br><span class="line">            left = null;</span><br><span class="line">            right = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Node root;      // 二分搜索树的根节点</span><br><span class="line">    private int size;       // 二分搜索树的节点个数</span><br><span class="line"></span><br><span class="line">    public BST() &#123;           // 初始化root 和 size</span><br><span class="line">        root = null;</span><br><span class="line">        size = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int size() &#123;     // 返回节点个数</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isEmpty() &#123;  // 判断二分搜索树是否为空</span><br><span class="line">        return size == 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="二分搜索树插入节点"><a href="#二分搜索树插入节点" class="headerlink" title="二分搜索树插入节点"></a>二分搜索树插入节点</h2><p><font style="font-weight: bold; color: #FF0000;">我们的二分搜索树不包含重复元素</font> 如果想要<strong><code>包含重复元素</code></strong>，只需要定义：<strong><code>左子树小于等于节点或者是右子树大于等于节点</code></strong> </p><p><strong><code>方案1：</code></strong> </p><div align="center" style="zoom: 80%; margin:  0px auto;"><img src="/2018/11/22/二叉搜索树/BST1.png" alt="原理"></div>  <p>此方法不是最佳写法，在于<font style="font-weight: bold; color: #FF0000;">没有深入理解递归终止条件</font> 递归到最底层应该是发现某个节点的左/右孩子为空的情况，发现为空说明e就应该插入到为空的地方</p><p><strong><code>方案2：递归到底</code></strong> <font style="font-weight: bold; color: #FF0000;">强推</font></p><div align="center" style="zoom: 80%; margin:  0px auto;"><img src="/2018/11/22/二叉搜索树/BST2.png" alt="原理"></div>  <blockquote><p>leetcode 804. Unique Morse Code Words:<a href="https://leetcode.com/problems/unique-morse-code-words/" target="_blank" rel="noopener">点击这里</a> 就可以用二分搜索树添加的方式解决</p></blockquote><h2 id="查询操作"><a href="#查询操作" class="headerlink" title="查询操作"></a>查询操作</h2><div align="center" style="zoom: 80%; margin:  0px auto;"><img src="/2018/11/22/二叉搜索树/BST3.png" alt="原理"></div>  <h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><p><strong><code>前序遍历-递归：</code></strong></p><div align="center" style="zoom: 80%; margin:  0px auto;"><img src="/2018/11/22/二叉搜索树/BST4.png" alt="原理"></div>  <p><strong><code>调试递归算法：</code></strong></p><div align="center" style="zoom: 80%; margin:  0px auto;"><img src="/2018/11/22/二叉搜索树/BST5.png" alt="原理"></div> <p>主函数及结果：</p><div align="center" style="zoom: 80%; margin:  0px auto;"><img src="/2018/11/22/二叉搜索树/BST6.png" alt="原理"></div>  <h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p><font style="font-weight: bold; color: #FF0000;">二分搜索树的中序遍历就是按从小到大的顺序</font> </p><div align="center" style="zoom: 80%; margin:  0px auto;"><img src="/2018/11/22/二叉搜索树/BST7.png" alt="原理"></div> <h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><div align="center" style="zoom: 80%; margin:  0px auto;"><img src="/2018/11/22/二叉搜索树/BST8.png" alt="原理"></div> <h2 id="其他以后完善"><a href="#其他以后完善" class="headerlink" title="其他以后完善"></a>其他以后完善</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br></pre></td><td class="code"><pre><span class="line">import java.util.LinkedList;</span><br><span class="line">import java.util.Queue;</span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">public class BST&lt;E extends Comparable&lt;E&gt;&gt; &#123; // 存储的元素必须有可比性</span><br><span class="line"></span><br><span class="line">    private class Node &#123;     // 用匿名内部类定义节点</span><br><span class="line">        public E e;</span><br><span class="line">        public Node left, right;</span><br><span class="line"></span><br><span class="line">        public Node(E e) &#123;   // 构造方法 对节点进行初始化操作</span><br><span class="line">            this.e = e;</span><br><span class="line">            left = null;</span><br><span class="line">            right = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Node root;      // 二分搜索树的根节点</span><br><span class="line">    private int size;       // 二分搜索树的节点个数</span><br><span class="line"></span><br><span class="line">    public BST() &#123;           // 初始化root 和 size</span><br><span class="line">        root = null;</span><br><span class="line">        size = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int size() &#123;     // 返回节点个数</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isEmpty() &#123;  // 判断二分搜索树是否为空</span><br><span class="line">        return size == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//    // 向二分搜索书中添加新的元素e</span><br><span class="line">//    public void add(E e) &#123;</span><br><span class="line">//        if (root == null) &#123;     // 如果根节点为空 则生成的节点作为根节点 并更新size</span><br><span class="line">//            root = new Node(e);</span><br><span class="line">//            size++;</span><br><span class="line">//        &#125; else &#123;</span><br><span class="line">//            add(root, e);</span><br><span class="line">//        &#125;</span><br><span class="line">//    &#125;</span><br><span class="line">//</span><br><span class="line">//    // 向以node为根的二分搜索树中插入e  递归算法</span><br><span class="line">//    private void add(Node node, E e) &#123;</span><br><span class="line">//        /*****递归结束条件  begin********/</span><br><span class="line">//        if (e.equals(node.e)) &#123;         // 如果二分搜索树中已有该节点 什么都不用做</span><br><span class="line">//            return;</span><br><span class="line">//        &#125;</span><br><span class="line">//        if (e.compareTo(node.e) &lt; 0 &amp;&amp; node.left == null) &#123; // 如果e比该节点的值小并且该节点的左孩子为空</span><br><span class="line">//            node.left = new Node(e);  // 说明e就应该插入到node的左孩子</span><br><span class="line">//            return;</span><br><span class="line">//        &#125; else if (e.compareTo(node.e) &gt; 0 &amp;&amp; node.right == null) &#123; // 如果e比该节点的值大并且该节点的右孩子为空</span><br><span class="line">//            node.right = new Node(e);</span><br><span class="line">//            return;</span><br><span class="line">//        &#125; // 不需要写else 体会</span><br><span class="line">//        /*****递归结束条件  end********/</span><br><span class="line">//</span><br><span class="line">//        if (e.compareTo(node.e) &lt; 0) &#123; // 如果e比当前节点的值小  到当前节点的左子树去找</span><br><span class="line">//            add(node.left, e);</span><br><span class="line">//        &#125; else if (e.compareTo(node.e) &gt; 0) &#123; // 如果e比当前节点的值大  到当前节点的右子树去找</span><br><span class="line">//            add(node.right, e);</span><br><span class="line">//        &#125; // e.compareTo(node.e) == 0 的情况在 e.equals(node.e)已经判断了</span><br><span class="line">//    &#125;</span><br><span class="line"></span><br><span class="line">    // 向二分搜索树中插入e</span><br><span class="line">    public void add(E e) &#123;</span><br><span class="line">        root = add(root, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 向以node为根的二分搜索树中插入节点</span><br><span class="line">    // 递归的宏观语义：返回插入e之后以e为根节点的二分搜索树</span><br><span class="line">    // 与之前的add相比 将递归的深度到最深(NULL也是二分搜索树)  发现某个节点的左/右孩子为空，说明e就应该插入到为空的地方</span><br><span class="line">    private Node add(Node node, E e) &#123;</span><br><span class="line">        if (node == null) &#123;  // 递归结束条件： 发现了e应该插入的地方 并更新size</span><br><span class="line">            size++;</span><br><span class="line">            return new Node(e);</span><br><span class="line">        &#125;</span><br><span class="line">        if (e.compareTo(node.e) &lt; 0) &#123;  // 如果e比当前节点小, 去左子树找,并更新左子树</span><br><span class="line">            node.left = add(node.left, e);</span><br><span class="line">        &#125; else if (e.compareTo(node.e) &gt; 0) &#123; // 如果e比当前节点大,去右子树找,并更新右子树</span><br><span class="line">            node.right = add(node.right, e);</span><br><span class="line">        &#125; // e.compareTo(node.e) == 0  因为我们写的二分搜索树不包含重复元素 所以此处不做任何操作</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 看二分搜索树中是否包含元素e</span><br><span class="line">    public boolean contains(E e) &#123;</span><br><span class="line">        return contains(root, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 递归宏观语义：返回以node为根节点的二分搜索树是否包含e</span><br><span class="line">    private boolean contains(Node node, E e) &#123;</span><br><span class="line">        if (node == null) &#123; // 递归出口： 递归到了最深还没有发现e</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        if (e.compareTo(node.e) == 0) &#123;  // 发现树中已有e</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else if (e.compareTo(node.e) &lt; 0) &#123; // e比当前节点值小 左边找 并把结果返回给上层</span><br><span class="line">            return contains(node.left, e);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return contains(node.right, e);  //  e比当前节点值大 右边找 并把结果返回给上层</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 先序遍历 二分搜索树</span><br><span class="line">    public void preOrderTraverse() &#123;</span><br><span class="line">        preOrderTraverse(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 递归宏观语义：求以node为根节点的二分搜索树的前序遍历</span><br><span class="line">    private void preOrderTraverse(Node node) &#123;</span><br><span class="line">        if (node == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(node.e);         // 打印根节点</span><br><span class="line">        preOrderTraverse(node.left);        // 访问左子树</span><br><span class="line">        preOrderTraverse(node.right);       // 访问右子树</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//    @Override</span><br><span class="line">//    public String toString() &#123;</span><br><span class="line">//        StringBuilder res = new StringBuilder();</span><br><span class="line">//        generateStringBST(root, 0, res);</span><br><span class="line">//        return res.toString();</span><br><span class="line">//    &#125;</span><br><span class="line">//</span><br><span class="line">//    // 生成以node为根节点，深度为depth的描述二叉树的字符串 在先序遍历的基础上</span><br><span class="line">//    private void generateStringBST(Node node, int depth, StringBuilder res) &#123;</span><br><span class="line">//        if (node == null) &#123;</span><br><span class="line">//            res.append(generateDepth(depth) + &quot;null\n&quot;);</span><br><span class="line">//            return;</span><br><span class="line">//        &#125;</span><br><span class="line">//        res.append(generateDepth(depth) + node.e + &quot;\n&quot;);</span><br><span class="line">//        generateStringBST(node.left, depth + 1, res);</span><br><span class="line">//        generateStringBST(node.right, depth + 1, res);</span><br><span class="line">//    &#125;</span><br><span class="line">//</span><br><span class="line">//    // 深度描述字符串 深度1：-&gt; 深度2：-&gt;-&gt;</span><br><span class="line">//    private String generateDepth(int depth) &#123;</span><br><span class="line">//        StringBuilder res = new StringBuilder();</span><br><span class="line">//        for (int i = 0; i &lt; depth; ++i) &#123;</span><br><span class="line">//            res.append(&quot;-&gt;&quot;);</span><br><span class="line">//        &#125;</span><br><span class="line">//        return res.toString();</span><br><span class="line">//    &#125;</span><br><span class="line"></span><br><span class="line">    // 中序遍历</span><br><span class="line">    public void inOrderTraverse()&#123;</span><br><span class="line">        inOrderTraverse(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 递归宏观语义：求以node为根节点的二分搜索树的中序遍历</span><br><span class="line">    private void inOrderTraverse(Node node) &#123;</span><br><span class="line">        if (node == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        inOrderTraverse(node.left);  // 访问左子树</span><br><span class="line">        System.out.println(node.e);  // 访问根</span><br><span class="line">        inOrderTraverse(node.right); // 访问右子树</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 后序遍历</span><br><span class="line">    public void postOrderTraverse()&#123;</span><br><span class="line">        postOrderTraverse(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 递归宏观语义：求以node为根节点的二分搜索树的后序遍历</span><br><span class="line">    private void postOrderTraverse(Node node) &#123;</span><br><span class="line">        if (node == null) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        postOrderTraverse(node.left);  // 访问左子树</span><br><span class="line">        postOrderTraverse(node.right); // 访问右子树</span><br><span class="line">        System.out.println(node.e);  // 访问根</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 层次遍历(广度优先算法)</span><br><span class="line">    public void leverOrderTraverse()&#123;</span><br><span class="line">        Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);    // 先将根节点入队</span><br><span class="line">        while (!queue.isEmpty()) &#123;  // 队不空</span><br><span class="line">            Node cur = queue.remove();  // 出队</span><br><span class="line">            System.out.println(cur.e);  // 打印</span><br><span class="line">            if (cur.left != null) &#123;     // 左孩子不空 入队</span><br><span class="line">                queue.add(cur.left);</span><br><span class="line">            &#125;</span><br><span class="line">            if (cur.right != null) &#123;    // 右孩子不空入队</span><br><span class="line">                queue.add(cur.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 寻找二分搜索树中的最小元素</span><br><span class="line">    public E minNum()&#123;</span><br><span class="line">        if (size == 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;BST is empty.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return minNum(root).e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 递归宏观语义：返回以node为根的二分搜索树中的最小值的节点</span><br><span class="line">    private Node minNum(Node node) &#123;</span><br><span class="line">        if (node.left == null) &#123;</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">        return minNum(node.left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 寻找二分搜索树中的最大元素</span><br><span class="line">    public E maxNum()&#123;</span><br><span class="line">        if (size == 0) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;BST is empty.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return maxNum(root).e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 递归宏观语义：返回以node为根的二分搜索树中的最大值的节点</span><br><span class="line">    private Node maxNum(Node node) &#123;</span><br><span class="line">        if (node.right == null) &#123;</span><br><span class="line">            return node;</span><br><span class="line">        &#125;</span><br><span class="line">        return maxNum(node.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 删除二分搜索树的最小值所在的节点，并返回最小值</span><br><span class="line">    public E removeMin()&#123;</span><br><span class="line">        E res = minNum();</span><br><span class="line">        root = removeMin(root);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 递归宏观语义：删掉以node为根节点的二分搜索树的最小值</span><br><span class="line">    //              返回删掉最小值后 新的二分索搜树的根</span><br><span class="line">    private Node removeMin(Node node)&#123;</span><br><span class="line">        if (node.left == null) &#123;    // 递归到最底层</span><br><span class="line">            Node rightNode = node.right;</span><br><span class="line">            node.right = null;</span><br><span class="line">            size--;</span><br><span class="line">            return rightNode;</span><br><span class="line">        &#125;</span><br><span class="line">        node.left = removeMin(node.left);</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 删除二分搜索树的最大值所在的节点，并返回最大值</span><br><span class="line">    public E removeMax()&#123;</span><br><span class="line">        E res = maxNum();</span><br><span class="line">        root = removeMax(root);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 递归宏观语义：删掉以node为根节点的二分搜索树的最大值</span><br><span class="line">    //              返回删掉最大值后 新的二分索搜树的根</span><br><span class="line">    private Node removeMax(Node node)&#123;</span><br><span class="line">        if (node.right == null) &#123;    // 递归到最底层</span><br><span class="line">            Node leftNode = node.left;</span><br><span class="line">            node.left = null;</span><br><span class="line">            size--;</span><br><span class="line">            return leftNode;</span><br><span class="line">        &#125;</span><br><span class="line">        node.right = removeMax(node.right);</span><br><span class="line">        return node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] nums = &#123;1, 2, 5, 3, -1&#125;;</span><br><span class="line">        BST&lt;Integer&gt; bst = new BST&lt;&gt;();</span><br><span class="line">        for (int num : nums) &#123;</span><br><span class="line">            bst.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        bst.leverOrderTraverse();</span><br><span class="line">        System.out.println(&quot;min:&quot; + bst.minNum());</span><br><span class="line">        System.out.println(&quot;max:&quot; + bst.maxNum());</span><br><span class="line">        bst.removeMin();</span><br><span class="line">        System.out.println(&quot;min:&quot; + bst.minNum());</span><br><span class="line">        System.out.println(&quot;max:&quot; + bst.maxNum());</span><br><span class="line">        bst.leverOrderTraverse();</span><br><span class="line">        bst.removeMax();</span><br><span class="line">        System.out.println(&quot;min:&quot; + bst.minNum());</span><br><span class="line">        System.out.println(&quot;max:&quot; + bst.maxNum());</span><br><span class="line">        bst.leverOrderTraverse();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></the>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>栈与递归紧密的联系 </title>
      <link href="/2018/11/18/%E6%A0%88%E4%B8%8E%E9%80%92%E5%BD%92%E7%B4%A7%E5%AF%86%E7%9A%84%E8%81%94%E7%B3%BB/"/>
      <url>/2018/11/18/%E6%A0%88%E4%B8%8E%E9%80%92%E5%BD%92%E7%B4%A7%E5%AF%86%E7%9A%84%E8%81%94%E7%B3%BB/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""> </excerpt></p><blockquote><p>系统栈与递归之间的联系 ,以及用栈来模拟系统栈写出非递归程序</p></blockquote><a id="more"></a><the rest="" of="" contents="" |="" 余下全文=""><h2 id="系统栈与递归之间的关系"><a href="#系统栈与递归之间的关系" class="headerlink" title="系统栈与递归之间的关系"></a>系统栈与递归之间的关系</h2><p><strong><code>图解系统栈与递归之间的关系：</code></strong></p><div align="center" style="zoom: 70%; margin:  0px auto;"><img src="/2018/11/18/栈与递归紧密的联系/Stack01.png" alt="原理"></div><div align="center" style="zoom: 70%; margin:  0px auto;"><img src="/2018/11/18/栈与递归紧密的联系/Stack02.png" alt="原理"></div><div align="center" style="zoom: 70%; margin:  0px auto;"><img src="/2018/11/18/栈与递归紧密的联系/Stack03.png" alt="原理"></div><div align="center" style="zoom: 70%; margin:  0px auto;"><img src="/2018/11/18/栈与递归紧密的联系/Stack04.png" alt="原理"></div><div align="center" style="zoom: 70%; margin:  0px auto;"><img src="/2018/11/18/栈与递归紧密的联系/Stack05.png" alt="原理"></div><div align="center" style="zoom: 70%; margin:  0px auto;"><img src="/2018/11/18/栈与递归紧密的联系/Stack06.png" alt="原理"></div><div align="center" style="zoom: 70%; margin:  0px auto;"><img src="/2018/11/18/栈与递归紧密的联系/Stack07.png" alt="原理"></div><div align="center" style="zoom: 70%; margin:  0px auto;"><img src="/2018/11/18/栈与递归紧密的联系/Stack08.png" alt="原理"></div><div align="center" style="zoom: 70%; margin:  0px auto;"><img src="/2018/11/18/栈与递归紧密的联系/Stack09.png" alt="原理"></div><div align="center" style="zoom: 70%; margin:  0px auto;"><img src="/2018/11/18/栈与递归紧密的联系/Stack10.png" alt="原理"></div><div align="center" style="zoom: 70%; margin:  0px auto;"><img src="/2018/11/18/栈与递归紧密的联系/Stack11.png" alt="原理"></div><h2 id="用栈来模拟系统栈-写出非递归程序"><a href="#用栈来模拟系统栈-写出非递归程序" class="headerlink" title="用栈来模拟系统栈 写出非递归程序"></a>用栈来模拟系统栈 写出非递归程序</h2><p>举个栗子 leetcode 144 Binary Tree Preorder Traversal:<a href="https://leetcode.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">题目链接</a><br><strong><code>递归遍历写法 AC:</code></strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; array = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        preorderTraversal( root , array);</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preorderTraversal</span><span class="params">(TreeNode root, List&lt;Integer&gt; array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            array.add(root.val);</span><br><span class="line">            preorderTraversal(root.left, array);</span><br><span class="line">            preorderTraversal(root.right, array);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong><code>用栈来模拟系统栈 非递归 AC (推荐)：</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指令</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Command</span></span>&#123;</span><br><span class="line">    String s;   <span class="comment">// go:访问   print：打印</span></span><br><span class="line">    TreeNode node;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Command</span><span class="params">(String s, TreeNode node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">        <span class="keyword">this</span>.node = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();  </span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Command&gt; stack = <span class="keyword">new</span> Stack&lt;Command&gt;();</span><br><span class="line">        stack.push(<span class="keyword">new</span> Command(<span class="string">"go"</span>, root));        </span><br><span class="line">        <span class="keyword">while</span> (stack.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            Command com = stack.pop();</span><br><span class="line">            <span class="keyword">if</span> (com.s.equals(<span class="string">"print"</span>)) &#123;</span><br><span class="line">                res.add(com.node.val);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">assert</span>(com.s.equals(<span class="string">"go"</span>));     </span><br><span class="line">                <span class="keyword">if</span> (com.node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    stack.push(<span class="keyword">new</span> Command(<span class="string">"go"</span>, com.node.right));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (com.node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    stack.push(<span class="keyword">new</span> Command(<span class="string">"go"</span>, com.node.left));</span><br><span class="line">                &#125;</span><br><span class="line">                stack.push(<span class="keyword">new</span> Command(<span class="string">"print"</span>, com.node));    <span class="comment">// 更改此句的位置 变成中序  后序</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>leetcode   94. Binary Tree Inorder Traversal:<a href="https://leetcode.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener">题目链接</a></p><p>leetcode   145. Binary Tree Postorder Traversal:<a href="https://leetcode.com/problems/binary-tree-postorder-traversal/" target="_blank" rel="noopener">题目链接</a></p></the>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Recursive </tag>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>144. Binary Tree Preorder Traversal</title>
      <link href="/2018/11/18/144-Binary-Tree-Preorder-Traversal/"/>
      <url>/2018/11/18/144-Binary-Tree-Preorder-Traversal/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="144"><li>Binary Tree Preorder Traversal:<a href="https://leetcode.com/problems/binary-tree-preorder-traversal/" target="_blank" rel="noopener">题目链接</a></li></ol><h2 id="方法1：递归遍历"><a href="#方法1：递归遍历" class="headerlink" title="方法1：递归遍历"></a>方法1：递归遍历</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    </span><br><span class="line">    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; array = new ArrayList&lt;Integer&gt;();</span><br><span class="line">        preorderTraversal( root , array);</span><br><span class="line">        return array;</span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    public void preorderTraversal(TreeNode root, List&lt;Integer&gt; array) &#123;</span><br><span class="line">        if (root != null) &#123;</span><br><span class="line">            array.add(root.val);</span><br><span class="line">            preorderTraversal(root.left, array);</span><br><span class="line">            preorderTraversal(root.right, array);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
            <tag> Recursive </tag>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>71. Simplify Path</title>
      <link href="/2018/11/10/71-Simplify-Path/"/>
      <url>/2018/11/10/71-Simplify-Path/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="71"><li>Simplify Path:<a href="https://leetcode.com/problems/simplify-path/description/" target="_blank" rel="noopener">题目链接</a></li></ol><h2 id="方法1：Stack"><a href="#方法1：Stack" class="headerlink" title="方法1：Stack"></a>方法1：Stack</h2><p><strong><code>基本思想：</code></strong><br><strong><code>/</code></strong>:表示的时分隔符<br><strong><code>.</code></strong>:表示当前路径<br><strong><code>..</code></strong>:表示上一层路径</p><blockquote><p>For example,<br>path = “/home/“, =&gt; “/home”<br>path = “/a/./b/../../c/“, =&gt; “/c”<br>path = “/a/../../b/../c//.//“, =&gt; “/c”<br>path = “/a//b////c/d//././/..”, =&gt; “/a/b/c”</p></blockquote><p>可以用split(“/“)以”/“分隔，举个列子：<br>“/a//b////c/d//././/..”  —&gt;   [, a, , b, , , , c, d, , ., ., , ..]<br>遍历，如果遇到<strong><code>&quot;&quot;</code></strong>,<strong><code>.</code></strong> 直接跳过，遇上<strong><code>&quot;..&quot;</code></strong>出栈,最后将栈内元素从栈底向栈顶打印</p><p><strong><code>AC代码：</code></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.Stack;</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    // 时间复杂度(N)  空间复杂度O(m) m:path.length</span><br><span class="line">    public String simplifyPath(String path) &#123;</span><br><span class="line">        Stack&lt;String&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">        String[] arr = path.split(&quot;/&quot;);   // 将path以“/”划分的结果放到arr[]字符串数组中</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; arr.length; ++i) &#123;  // 遍历</span><br><span class="line">            if ((arr[i].equals(&quot;&quot;) || arr[i].equals(&quot;.&quot;))) &#123;  // 如果遇上&quot;&quot; || &quot;.&quot; 跳过</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if (!arr[i].equals(&quot;..&quot;))&#123;                        // 遇上路径名  入栈</span><br><span class="line">                stack.push(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            if (arr[i].equals(&quot;..&quot;) &amp;&amp; stack.size() != 0) &#123;   // 遇上&quot;..&quot; 将栈顶元素出栈</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringBuffer sb = new StringBuffer();</span><br><span class="line">        for (String s : stack) &#123;                              // 从栈底遍历栈  不是从栈顶出栈的方式</span><br><span class="line">            sb.append(&quot;/&quot; + s);</span><br><span class="line">        &#125;</span><br><span class="line">        return stack.size() == 0 ? &quot;/&quot; : sb.toString();       // 如果栈空 返回 &quot;/&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(new Solution().simplifyPath(&quot;/.&quot;));</span><br><span class="line">        System.out.println(new Solution().simplifyPath(&quot;/a/../../b/../c//.//&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/71.%20Simplify%20Path" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>20. Valid Parentheses</title>
      <link href="/2018/11/09/20-Valid-Parentheses/"/>
      <url>/2018/11/09/20-Valid-Parentheses/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="20"><li>Valid Parentheses:<a href="https://leetcode.com/problems/valid-parentheses/description/" target="_blank" rel="noopener">题目链接</a></li></ol><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2><p>见官方解析：<a href="https://leetcode.com/problems/valid-parentheses/solution/" target="_blank" rel="noopener">点击这里</a></p><p><strong><code>AC代码：</code></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 时间复杂度O(N)   空间复杂度O(s.length)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] arr = s.toCharArray();</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i= <span class="number">0</span>; i&lt;arr.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == <span class="string">'('</span> || arr[i] == <span class="string">'&#123;'</span> || arr[i] == <span class="string">'['</span>) &#123;</span><br><span class="line">                stack.push(arr[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (stack.size() == <span class="number">0</span>)&#123; <span class="comment">// 这里要注意 防止了 只出现 &#123; [ (这种情况</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">char</span> p = stack.pop();</span><br><span class="line">                <span class="keyword">char</span> match;</span><br><span class="line">                <span class="keyword">if</span> (arr[i] == <span class="string">')'</span>) &#123;</span><br><span class="line">                    match = <span class="string">'('</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] == <span class="string">']'</span>) &#123;</span><br><span class="line">                    match = <span class="string">'['</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    match = <span class="string">'&#123;'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (match != p) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后栈不空说明不匹配</span></span><br><span class="line">        <span class="keyword">if</span> (stack.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution().isValid(<span class="string">"()[]&#123;&#125;"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/20.%20Valid%20Parentheses" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>队列详解</title>
      <link href="/2018/10/22/%E9%98%9F%E5%88%97%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/10/22/%E9%98%9F%E5%88%97%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><blockquote><font style="font-weight: bold; color: #FF0000;">栈的特点：先进先出  First In First Out(FIFO)</font><br><font style="font-weight: bold; color: #FF0000;">一种操作受限的线性表，只允许在队头删除元素，队尾插入元素</font><br><font style="font-weight: bold; color: #FF0000;">相比于数组，队列对应的操作是数组的子集</font> </blockquote><h2 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h2><p><strong><code>基本思想：</code></strong>分配一块连续的存储单元存放队列中的元素，并设下头指针front：<strong><code>指向队首元素</code></strong>，尾指针rear:<strong><code>指向队尾元素的后一个元素</code></strong></p><blockquote><p>也可以front指向队首元素的前一个元素，rear指向队尾元素，但是在进行操作时需要相应的变化</p></blockquote><p><strong><code>节点定义：</code></strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INITSIZE 5                <span class="comment">// 顺序队列初始容量</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> E int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 不能动态增长的节点定义</span></span><br><span class="line"><span class="comment">typedef struct &#123;</span></span><br><span class="line"><span class="comment">    int data[INITSIZE];</span></span><br><span class="line"><span class="comment">    int front;</span></span><br><span class="line"><span class="comment">    int rear;</span></span><br><span class="line"><span class="comment">&#125; SeqQueue;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以动态增长的节点定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    E *data;                     <span class="comment">// 数组空间基址</span></span><br><span class="line">    <span class="keyword">int</span> capacity;                <span class="comment">// 顺序队列的容量</span></span><br><span class="line">    <span class="keyword">int</span> front;                   <span class="comment">// 队首指针：指向队首</span></span><br><span class="line">    <span class="keyword">int</span> rear;                    <span class="comment">// 队尾指针：指向队尾的后一个位置</span></span><br><span class="line">&#125; SeqQueue;</span><br></pre></td></tr></table></figure></p><blockquote><p><strong><code>初始化及一些其他操作：</code></strong> </p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化队列</span></span><br><span class="line"><span class="function">SeqQueue *<span class="title">initQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SeqQueue *<span class="built_in">queue</span> = (SeqQueue *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SeqQueue));</span><br><span class="line">    <span class="built_in">queue</span>-&gt;data = (E *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(E) * INITSIZE);</span><br><span class="line">    <span class="built_in">queue</span>-&gt;capacity = INITSIZE;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front = <span class="built_in">queue</span>-&gt;rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取顺序队列的容量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getCapacity</span><span class="params">(SeqQueue *<span class="built_in">queue</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回顺序队列是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isEmpty</span><span class="params">(SeqQueue *<span class="built_in">queue</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;front == <span class="built_in">queue</span>-&gt;rear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取队列实际元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">(SeqQueue *<span class="built_in">queue</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;rear - <span class="built_in">queue</span>-&gt;front;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印顺序队列信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMessage</span><span class="params">(SeqQueue *<span class="built_in">queue</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Queue:size = %d  , capacity = %d \n"</span>, getSize(<span class="built_in">queue</span>), getCapacity(<span class="built_in">queue</span>));</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"printMessage failed. Queue is empty.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"front ["</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="built_in">queue</span>-&gt;front; i &lt; <span class="built_in">queue</span>-&gt;rear; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, <span class="built_in">queue</span>-&gt;data[i]);</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="built_in">queue</span>-&gt;rear - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">", "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"] rear\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>入队：</code></strong> 如果队列满则动态增长数组空间(队满：<strong><code>rear == capacity</code></strong>)</p></blockquote><div align="center" style="zoom: 70%; margin:  0px auto;"><img src="/2018/10/22/队列详解/seqQueue_1.png" alt="原理"></div>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将数组空间的容量扩容成newCapacity大小 O(N)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(SeqQueue *<span class="built_in">queue</span>, <span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    E *newDate = (E *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(E) * newCapacity);</span><br><span class="line">    <span class="keyword">int</span> i,j = <span class="built_in">queue</span>-&gt;front;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; getSize(<span class="built_in">queue</span>); ++i) &#123;</span><br><span class="line">        newDate[i] = <span class="built_in">queue</span>-&gt;data[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;data = newDate;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;rear = getSize(<span class="built_in">queue</span>);</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front = <span class="number">0</span>;  <span class="comment">// rear重新赋值的操作要放在front前</span></span><br><span class="line">    <span class="built_in">queue</span>-&gt;capacity = newCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队 入队跟尾指针有关</span></span><br><span class="line"><span class="comment">// 不算resize操作  O(1)  其实算上resize的话(并不是每次都会触发resize) 用均摊复杂度来看也是O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(SeqQueue *<span class="built_in">queue</span>, E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">queue</span>-&gt;rear == <span class="built_in">queue</span>-&gt;capacity) &#123; <span class="comment">// 队列满</span></span><br><span class="line">        resize(<span class="built_in">queue</span>, <span class="number">2</span> * <span class="built_in">queue</span>-&gt;capacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;data[<span class="built_in">queue</span>-&gt;rear] = e;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;rear++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>出队：</code></strong> 如果队列空则不能出队</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 出队 只跟队头指针有关</span></span><br><span class="line"><span class="comment">// 不算resize操作  O(1)  其实算上resize的话(并不是每次都会触发resize) 用均摊复杂度来看也是O(1)</span></span><br><span class="line"><span class="function">E <span class="title">dequeue</span><span class="params">(SeqQueue *<span class="built_in">queue</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"dequeue failed. Queue is empty.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-9999999</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    E res = <span class="built_in">queue</span>-&gt;data[<span class="built_in">queue</span>-&gt;front];</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态缩减数组</span></span><br><span class="line">    <span class="comment">// 为了防止复杂度震荡 设为元素个数为1/4时才缩减至一半 getSize(queue) == queue-&gt;capacity / 4 &amp;&amp; queue-&gt;capacity / 2 != 0</span></span><br><span class="line">    <span class="keyword">if</span> (getSize(<span class="built_in">queue</span>) == <span class="built_in">queue</span>-&gt;capacity / <span class="number">2</span>) &#123;</span><br><span class="line">        resize(<span class="built_in">queue</span>, <span class="built_in">queue</span>-&gt;capacity / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>读取队头元素：</code></strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取队头元素 O(1)</span></span><br><span class="line"><span class="function">E <span class="title">getFront</span><span class="params">(SeqQueue *<span class="built_in">queue</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"getFront failed. Queue is empty.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-9999999</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;data[<span class="built_in">queue</span>-&gt;front];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>顺序队列的缺点：</code></strong>队尾溢出，但是实际上数组仍有空间，从而引出了循环队列</p></blockquote><h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><p>为了解决队尾溢出而实际上数组仍然有空余空间的问题，一般在队列的顺序存储结构中采用循环队列的方式:rear和front到达数组端点时，能折回到数组开始处，即相当于将数组头尾相接，想象成环状，如图所示。当插人和删除操作的作用单元达到数组的末端后,用公式“Rear(或Front)%数组长度”取余运算就可以实现折返到起始单元</p><div align="center" style="zoom: 70%; margin:  0px auto;"><img src="/2018/10/22/队列详解/Queue_2.jpg" alt="原理"></div>  <p><strong><code>判断队满还是对空的3种方法：</code></strong></p><ol><li>牺牲一个单元来区分队空和队满，入队时少用一个队列单元(上图的d2) <strong><code>选用</code></strong></li><li>类型中增设表示元素个数的数据成员.对空为size==0,队满为size==MAXSIZE，这两种情况都有front == rear</li><li>类型中增设tag成员，出队是tag==0，若因出队导致则为队空；入队时tag == 1，若因入队导致，则为队满</li></ol><div align="center" style="zoom: 70%; margin:  0px auto;"><img src="/2018/10/22/队列详解/Queue_3.png" alt="原理"></div> <blockquote><p><strong><code>节点定义和相关操作</code></strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INITSIZE 5                <span class="comment">// 队列初始容量</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> E int</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// 不能动态增长的节点定义</span></span><br><span class="line"><span class="comment">typedef struct &#123;</span></span><br><span class="line"><span class="comment">    int data[INITSIZE];</span></span><br><span class="line"><span class="comment">    int front;</span></span><br><span class="line"><span class="comment">    int rear;</span></span><br><span class="line"><span class="comment">&#125; LoopQueue;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以动态增长的节点定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    E *data;                     <span class="comment">// 数组空间基址</span></span><br><span class="line">    <span class="keyword">int</span> capacity;                <span class="comment">// 队列的容量</span></span><br><span class="line">    <span class="keyword">int</span> front;                   <span class="comment">// 队首指针：指向队首</span></span><br><span class="line">    <span class="keyword">int</span> rear;                    <span class="comment">// 队尾指针：指向队尾的后一个位置</span></span><br><span class="line">&#125; LoopQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化队列</span></span><br><span class="line"><span class="function">LoopQueue *<span class="title">initQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LoopQueue *<span class="built_in">queue</span> = (LoopQueue *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LoopQueue));</span><br><span class="line">    <span class="built_in">queue</span>-&gt;data = (E *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(E) * INITSIZE);</span><br><span class="line">    <span class="built_in">queue</span>-&gt;capacity = INITSIZE;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front = <span class="built_in">queue</span>-&gt;rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取循环队列的容量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getCapacity</span><span class="params">(LoopQueue *<span class="built_in">queue</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;capacity - <span class="number">1</span>;  <span class="comment">// 牺牲一个空间来区分队空和队满</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回循环队列是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isEmpty</span><span class="params">(LoopQueue *<span class="built_in">queue</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;front == <span class="built_in">queue</span>-&gt;rear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取队列实际元素个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">(LoopQueue *<span class="built_in">queue</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">queue</span>-&gt;rear + <span class="built_in">queue</span>-&gt;capacity - <span class="built_in">queue</span>-&gt;front) % <span class="built_in">queue</span>-&gt;capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印循环队列信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMessage</span><span class="params">(LoopQueue *<span class="built_in">queue</span>)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Queue:size = %d  , capacity = %d \n"</span>, getSize(<span class="built_in">queue</span>), getCapacity(<span class="built_in">queue</span>));</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"printMessage failed. Queue is empty.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d  %d\n"</span>, <span class="built_in">queue</span>-&gt;front, <span class="built_in">queue</span>-&gt;rear);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"front ["</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="built_in">queue</span>-&gt;front; i &lt; <span class="built_in">queue</span>-&gt;rear; ++i) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, <span class="built_in">queue</span>-&gt;data[i]);</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="built_in">queue</span>-&gt;rear - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">", "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"] rear\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>入队：</code></strong>先判断是否满 </p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将数组空间的容量扩容成newCapacity大小 O(N)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(LoopQueue *<span class="built_in">queue</span>, <span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    E *newDate = (E *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(E) * newCapacity + <span class="number">1</span>); <span class="comment">// 牺牲一个空间来区分队空和队满 所以补上一个空间</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; getSize(<span class="built_in">queue</span>); ++i) &#123;</span><br><span class="line">        newDate[i] = <span class="built_in">queue</span>-&gt;data[(i + <span class="built_in">queue</span>-&gt;front) % <span class="built_in">queue</span>-&gt;capacity];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;data = newDate;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;rear = getSize(<span class="built_in">queue</span>);</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;capacity = newCapacity + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队 入队跟尾指针有关</span></span><br><span class="line"><span class="comment">// 不算resize操作  O(1)  其实算上resize的话(并不是每次都会触发resize) 用均摊复杂度来看也是O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(LoopQueue *<span class="built_in">queue</span>, E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">queue</span>-&gt;rear + <span class="number">1</span>) % <span class="built_in">queue</span>-&gt;capacity == <span class="built_in">queue</span>-&gt;front) &#123; <span class="comment">// 队列满</span></span><br><span class="line">        resize(<span class="built_in">queue</span>, <span class="number">2</span> * <span class="built_in">queue</span>-&gt;capacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;data[<span class="built_in">queue</span>-&gt;rear] = e;</span><br><span class="line">    <span class="built_in">queue</span>-&gt;rear = (<span class="built_in">queue</span>-&gt;rear + <span class="number">1</span>) % <span class="built_in">queue</span>-&gt;capacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>出队：</code></strong>先判断是否空</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 出队 只跟队头指针有关</span></span><br><span class="line"><span class="comment">// 不算resize操作  O(1)  其实算上resize的话(并不是每次都会触发resize) 用均摊复杂度来看也是O(1)</span></span><br><span class="line"><span class="function">E <span class="title">dequeue</span><span class="params">(LoopQueue *<span class="built_in">queue</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"dequeue failed. Queue is empty.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-9999999</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    E res = <span class="built_in">queue</span>-&gt;data[<span class="built_in">queue</span>-&gt;front];</span><br><span class="line">    <span class="built_in">queue</span>-&gt;front = (<span class="built_in">queue</span>-&gt;front + <span class="number">1</span>) % <span class="built_in">queue</span>-&gt;capacity;</span><br><span class="line">    <span class="comment">// 动态缩减数组</span></span><br><span class="line">    <span class="comment">// 为了防止复杂度震荡 设为元素个数为1/4时才缩减至一半 getSize(queue) == queue-&gt;capacity / 4 &amp;&amp; queue-&gt;capacity / 2 != 0</span></span><br><span class="line">    <span class="keyword">if</span> (getSize(<span class="built_in">queue</span>) == <span class="built_in">queue</span>-&gt;capacity / <span class="number">2</span>) &#123;</span><br><span class="line">        resize(<span class="built_in">queue</span>, <span class="built_in">queue</span>-&gt;capacity / <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>获取队头元素：</code></strong></p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取队头元素 O(1)</span></span><br><span class="line"><span class="function">E <span class="title">getFront</span><span class="params">(LoopQueue *<span class="built_in">queue</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(<span class="built_in">queue</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"getFront failed. Queue is empty.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-9999999</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">queue</span>-&gt;data[<span class="built_in">queue</span>-&gt;front];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ps: 只能使用数组长度-1个空间</p><h2 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h2><font style="font-weight: bold; color: #FF0000;">链式队列 一般定义为带头结点的单链表</font>  <p>为什么要带头结点？如图</p><div align="center" style="zoom: 70%; margin:  0px auto;"><img src="/2018/10/22/队列详解/LinkedList_1.png" alt="原理"></div> <div align="center" style="zoom: 74%; margin:  0px auto;"><img src="/2018/10/22/队列详解/LinkedList_2.png" alt="原理"></div> <p><strong><code>结点定义：</code></strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> E int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span>       <span class="comment">// 链式队列节点</span></span><br><span class="line">    E data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; LinkNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    LinkNode *front;        <span class="comment">// 队头指针</span></span><br><span class="line">    LinkNode *rear;         <span class="comment">// 队尾指针</span></span><br><span class="line">    <span class="keyword">int</span> size;               <span class="comment">// 队列中元素个数  加入size变量可以使求长度操作的复杂度从O(N)降为O(1)</span></span><br><span class="line">    <span class="comment">// 不需要遍历求队列长度 只需要花费一点时间维护size</span></span><br><span class="line">&#125; LinkedQueue;</span><br></pre></td></tr></table></figure></p><p><strong><code>创建队列及相关操作：</code></strong></p><div align="center" style="zoom: 70%; margin:  0px auto;"><img src="/2018/10/22/队列详解/Queue_4.png" alt="原理"></div><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建队列</span></span><br><span class="line"><span class="function">LinkedQueue *<span class="title">createQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LinkedQueue *pQ = (LinkedQueue *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkedQueue));</span><br><span class="line">    pQ-&gt;front = pQ-&gt;rear = (LinkNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode));</span><br><span class="line">    pQ-&gt;rear-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    pQ-&gt;size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> pQ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取队列大小 O(1) 如果不加入size 则需要遍历链式队列求其容量大小需要O(N)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">(LinkedQueue *pQ)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pQ-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回是否为空</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isEmpty</span><span class="params">(LinkedQueue *pQ)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// return pQ-&gt;front == pQ-&gt;rear  // 不加入size判断是否为空</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> == pQ-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMessage</span><span class="params">(LinkedQueue *pQ)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(pQ)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"printMessage failed. LinkedQueue is empty.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"LinkedQueue: front "</span>);</span><br><span class="line">    LinkNode * curNode = pQ-&gt;front-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (curNode!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d -&gt; "</span>, curNode-&gt;data);</span><br><span class="line">        curNode = curNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"rear \n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><strong><code>入队：</code></strong><br><div align="center" style="zoom: 70%; margin:  0px auto;"><img src="/2018/10/22/队列详解/Queue_5.png" alt="原理"></div><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入队  时间复杂度O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enQueue</span><span class="params">(LinkedQueue *pQ, E e)</span> </span>&#123;</span><br><span class="line">    LinkNode *newNode = (LinkNode *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkNode)); <span class="comment">// 建新节点newNode</span></span><br><span class="line">    newNode-&gt;data = e;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    pQ-&gt;rear-&gt;next = newNode; <span class="comment">// 将newNode挂到rear后面</span></span><br><span class="line">    pQ-&gt;rear = newNode;</span><br><span class="line">    pQ-&gt;size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><strong><code>出队：</code></strong><br><div align="center" style="zoom: 70%; margin:  0px auto;"><img src="/2018/10/22/队列详解/Queue_6.png" alt="原理"></div> <div align="center" style="zoom: 70%; margin:  0px auto;"><img src="/2018/10/22/队列详解/LinkedList_3.png" alt="原理"></div> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 出队  O(1)</span></span><br><span class="line"><span class="function">E <span class="title">deQueue</span><span class="params">(LinkedQueue *pQ)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isEmpty(pQ)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"deQueue failed. LinkedQueue is empty.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-9999999</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkNode *delNode = pQ-&gt;front-&gt;next;</span><br><span class="line">    E res = delNode-&gt;data;</span><br><span class="line">    pQ-&gt;front-&gt;next = delNode-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (pQ-&gt;rear == delNode) &#123;                <span class="comment">// 如果队列此时只有一个节点 出队后</span></span><br><span class="line">        pQ-&gt;rear = pQ-&gt;front; <span class="comment">// front 和 rear都指向 NULL</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(delNode);</span><br><span class="line">    pQ-&gt;size--;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>得到队头元素：</code></strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到队头元素 O(1)</span></span><br><span class="line"><span class="function">E <span class="title">getFront</span><span class="params">(LinkedQueue *pQ)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(isEmpty(pQ))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"getFront failed. LinkedQueue is empty.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-9999999</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pQ-&gt;front-&gt;next-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="队列的基本应用-广度优先遍历"><a href="#队列的基本应用-广度优先遍历" class="headerlink" title="队列的基本应用-广度优先遍历"></a>队列的基本应用-广度优先遍历</h2><ol><li><span style="color:red">树：层序遍历</span></li><li><span style="color:red">图：对无权图用广度优先遍历 就是最短路径</span></li></ol><blockquote><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/03_Queue" target="_blank" rel="noopener">源代码链接</a></p></blockquote></the>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C </tag>
            
            <tag> Queue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>19. Remove Nth Node From End of List</title>
      <link href="/2018/10/20/19-Remove-Nth-Node-From-End-of-List/"/>
      <url>/2018/10/20/19-Remove-Nth-Node-From-End-of-List/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="19"><li>Remove Nth Node From End of List:<a href="https://leetcode.com/problems/remove-nth-node-from-end-of-list/description/" target="_blank" rel="noopener">题目链接</a></li></ol><h2 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h2><p><strong><code>基本思想：</code></strong> 指针p，q指向头节点，将q往后移动k位，当q不为空时，p，q同时往后移，当q为空时，此时p在倒数第k位上</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">假设k = 2</span><br><span class="line">        dummyHead -&gt; 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; NULL</span><br><span class="line">初始：     p、q</span><br><span class="line">q移k位:     p           q</span><br><span class="line">只要q不空，p、q后移    p          q</span><br><span class="line">                          p         q</span><br><span class="line">                                p        q</span><br><span class="line">此时p就在倒数第k位                    p          q</span><br></pre></td></tr></table></figure><p><strong><code>AC代码：</code></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 时间复杂度O(n)  空间O(1)</span><br><span class="line">struct ListNode* removeNthFromEnd(struct ListNode* head, int n) &#123;</span><br><span class="line">    if (head == NULL || n &lt;= 0) &#123;</span><br><span class="line">        return head;</span><br><span class="line">    &#125;</span><br><span class="line">    struct ListNode * dummyHead = (struct ListNode *) malloc (sizeof(struct ListNode));</span><br><span class="line">    dummyHead-&gt;next = head;</span><br><span class="line"></span><br><span class="line">    int i = 0;</span><br><span class="line">    struct ListNode * p = dummyHead, *q = dummyHead, *pre = dummyHead;</span><br><span class="line">    // 找到q的位置</span><br><span class="line">    while (i &lt; n &amp;&amp; q) &#123;</span><br><span class="line">        q = q-&gt;next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    // q不空p、q同时后移 pre是p的前驱</span><br><span class="line">    while (q != NULL) &#123;</span><br><span class="line">        pre = p;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        q = q-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pre-&gt;next = p-&gt;next;</span><br><span class="line">    free(p);</span><br><span class="line">    p = NULL;</span><br><span class="line">    return dummyHead-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/19.%20Remove%20Nth%20Node%20From%20End%20of%20List" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C实现 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>160. Intersection of Two Linked Lists</title>
      <link href="/2018/10/17/160-Intersection-of-Two-Linked-Lists/"/>
      <url>/2018/10/17/160-Intersection-of-Two-Linked-Lists/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="160"><li>Intersection of Two Linked Lists:<a href="https://leetcode.com/problems/intersection-of-two-linked-lists/description/" target="_blank" rel="noopener">题目链接</a></li></ol><h2 id="方法1：-推荐"><a href="#方法1：-推荐" class="headerlink" title="方法1：(推荐)"></a>方法1：(推荐)</h2><p><strong><code>基本思想：</code></strong>curA指向A当前节点，curB指向B当前节点，只要A从a1开始遍历，b从<strong><code>b2</code></strong>开始遍历只要curA==curB，则说明找到了公共节点，那么重点就是怎么让b从b2开始，curA遍历A只要curA不为空就继续遍历，如果curA为空，则将B赋值给CurA，同理curB遍历B只要curB不为空就继续遍历，如果curB为空，则将A赋值给curB这样可以使其同步</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A:          a1 → a2</span><br><span class="line">                   ↘</span><br><span class="line">                     c1 → c2 → c3</span><br><span class="line">                   ↗            </span><br><span class="line">B:     b1 → b2 → b3</span><br></pre></td></tr></table></figure><p><strong><code>AC代码：</code></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 时间复杂度O(N)  空间复杂度0(1)</span><br><span class="line">struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) &#123;</span><br><span class="line">    if (NULL == headA || NULL == headB) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct ListNode *curA = headA, *curB = headB;</span><br><span class="line">    while (curA != curB) &#123;</span><br><span class="line">        curA = curA == NULL ? headB : curA-&gt;next;</span><br><span class="line">        curB = curB == NULL ? headA : curB-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return curA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="方法2："><a href="#方法2：" class="headerlink" title="方法2："></a>方法2：</h2><p><strong><code>基本思想;</code></strong>先遍历链表A，计算出A的长度lenA，同理计算lenB，用dist保存| lenA-lenB |，将较长的链表存放在lonHead，lonHead进行dist次lonHead = lonHead-&gt;next次操作，此时两个链表已经保持相对位置，开始遍历只要发现存在节点相等则说明有公共节点</p><p><strong><code>AC代码：</code></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 时间复杂度O(N+M) N：headA的长度  M：headB的长度  空间复杂度0(1)</span><br><span class="line">struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) &#123;</span><br><span class="line">    if (NULL == headA || NULL == headB) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int lenA = lengthList(headA), lenB = lengthList(headB),  dist = 0;</span><br><span class="line">    struct ListNode * lonHead = NULL, * shoHead = NULL;</span><br><span class="line">    // 确定 headA  headB谁长  长多少</span><br><span class="line">    if (lenA &gt; lenB) &#123;</span><br><span class="line">        lonHead = headA;</span><br><span class="line">        shoHead = headB;</span><br><span class="line">        dist = lenA - lenB;</span><br><span class="line">    &#125; else&#123;</span><br><span class="line">        lonHead =  headB;</span><br><span class="line">        shoHead =  headA;</span><br><span class="line">        dist = lenB - lenA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 将较长的链表与较短的统一一下相对位置</span><br><span class="line">    while (dist--)&#123;</span><br><span class="line">        lonHead = lonHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    // 只要发现较长链表中有节点和较短链表相等 则说明有公共节点</span><br><span class="line">    while (lonHead != NULL) &#123;</span><br><span class="line">        if (lonHead == shoHead) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            lonHead = lonHead-&gt;next;</span><br><span class="line">            shoHead = shoHead-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return lonHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C实现 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>25. Reverse Nodes in k-Group</title>
      <link href="/2018/10/11/25-Reverse-Nodes-in-k-Group/"/>
      <url>/2018/10/11/25-Reverse-Nodes-in-k-Group/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="25"><li>Reverse Nodes in k-Group:<a href="https://leetcode.com/problems/reverse-nodes-in-k-group/description/" target="_blank" rel="noopener">题目链接</a></li></ol><p>跟leetcode 92. Reverse Linked List II 一样的做法  <a href="https://xerdemo.github.io/2018/10/04/92-Reverse-Linked-List-II/">解答：戳我</a></p><h2 id="方法1：穿针引线"><a href="#方法1：穿针引线" class="headerlink" title="方法1：穿针引线"></a>方法1：穿针引线</h2><ul><li>pre:指向带翻转节点之前的一个节点 </li><li>curNode: 当前指向的节点  简称c</li><li>nextNode: 当前指向的下一个节点    简称n</li><li>pCount:用来遍历从pre开始 后面的节点数是不是&gt;=k 如果小于k退出 大于等于k翻转</li></ul><p><strong><code>基本思想：</code></strong>先找到带翻转节点的前驱pre所在的位置，每次将curNode放在nextNode的后面，将nextNode放在pre的后面 如下所示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">k = 2 </span><br><span class="line"></span><br><span class="line">初始： dummyHead --&gt; 1 --&gt; 2 --&gt; 3 --&gt; 4 --&gt; 5</span><br><span class="line">            pre     c     n</span><br><span class="line"></span><br><span class="line">一次： dummyHead --&gt; 2 --&gt; 1 --&gt; 3 --&gt; 4 --&gt; 5</span><br><span class="line">            pre           c     n</span><br><span class="line"></span><br><span class="line">二次： dummyHead --&gt; 3 --&gt; 2 --&gt; 1 --&gt; 4 --&gt; 5</span><br><span class="line">            pre                 c     n</span><br><span class="line"></span><br><span class="line">三次： dummyHead --&gt; 3 --&gt; 2 --&gt; 1 --&gt; 4 --&gt; 5</span><br><span class="line">                                pre    4到5不满足k=3 退出</span><br></pre></td></tr></table></figure></p><p><strong><code>AC代码:</code></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 时间复杂度O(N)   空间复杂度O(1)</span><br><span class="line">struct ListNode* reverseKGroup(struct ListNode* head, int k) &#123;</span><br><span class="line">    struct ListNode *dummyHead = (struct ListNode *) malloc(sizeof(struct ListNode));</span><br><span class="line">    dummyHead-&gt;next = head;</span><br><span class="line">    struct ListNode *pre = dummyHead, *curNode = NULL,*pCount =NULL, *nextNode = NULL;</span><br><span class="line">    while (1)&#123;</span><br><span class="line">        int i = 0;</span><br><span class="line">        pCount = pre;          // pCount只是用来遍历从pre开始往后数满不满足K个而已</span><br><span class="line">        while (i&lt; k &amp;&amp; pCount!=NULL)&#123;</span><br><span class="line">            pCount = pCount-&gt;next;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (NULL == pCount)&#123;  // 遍历到链表尾了</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        curNode = pre-&gt;next;  // 找到curNode的位置</span><br><span class="line">        for (i = 0; i &lt; k - 1 &amp;&amp; curNode != NULL; ++i) &#123;    // 开始翻转</span><br><span class="line">            nextNode = curNode-&gt;next;</span><br><span class="line">            curNode-&gt;next = nextNode-&gt;next;</span><br><span class="line">            nextNode-&gt;next = pre-&gt;next;</span><br><span class="line">            pre-&gt;next = nextNode;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = curNode;              // 更新pre的位置</span><br><span class="line">    &#125;</span><br><span class="line">    return dummyHead-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/25.%20Reverse%20Nodes%20in%20k-Group" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C实现 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>24. Swap Nodes in Pairs</title>
      <link href="/2018/10/09/24-Swap-Nodes-in-Pairs/"/>
      <url>/2018/10/09/24-Swap-Nodes-in-Pairs/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="24"><li>Swap Nodes in Pairs:<a href="https://leetcode.com/problems/swap-nodes-in-pairs/description/" target="_blank" rel="noopener">题目链接</a></li></ol><h2 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 时间复杂度O(N)  空间复杂度O(1)</span><br><span class="line">struct ListNode *swapPairs(struct ListNode *head) &#123;</span><br><span class="line">    // 建立头结点  为了统一操作 (交换第一个与第二个节点时)</span><br><span class="line">    struct ListNode *dummyHead = (struct ListNode *) malloc(sizeof(struct ListNode));</span><br><span class="line">    dummyHead-&gt;next = head;</span><br><span class="line"></span><br><span class="line">    struct ListNode *pre = dummyHead;               // 交换的两个节点之前的节点</span><br><span class="line">    while (pre-&gt;next != NULL &amp;&amp; pre-&gt;next-&gt;next != NULL) &#123;</span><br><span class="line">        struct ListNode *node1 = pre-&gt;next;         // 需要交换的节点</span><br><span class="line">        struct ListNode *node2 = node1-&gt;next;       // 需要交换的节点</span><br><span class="line">        struct ListNode *nextNode = node2-&gt;next;    // 交换的两个节点之后的节点</span><br><span class="line">        // 交换操作</span><br><span class="line">        node2-&gt;next = node1;</span><br><span class="line">        node1-&gt;next = nextNode;</span><br><span class="line">        pre-&gt;next = node2;</span><br><span class="line">        pre = node1;                                // 更新pre的位置</span><br><span class="line">    &#125;</span><br><span class="line">    return dummyHead-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/24.%20Swap%20Nodes%20in%20Pairs" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C实现 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>21. Merge Two Sorted Lists</title>
      <link href="/2018/10/08/21-Merge-Two-Sorted-Lists/"/>
      <url>/2018/10/08/21-Merge-Two-Sorted-Lists/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="21"><li>Merge Two Sorted Lists:<a href="https://leetcode.com/problems/merge-two-sorted-lists/description/" target="_blank" rel="noopener">题目链接</a></li></ol><h2 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h2><p>ps：需要额外的空间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// 时间复杂度O(max(m,n))   空间复杂度O(m+n)   m:l1.length  n:l2.length</span><br><span class="line">struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2) &#123;</span><br><span class="line">    // 建头结点  新建一个链表来存放答案</span><br><span class="line">    struct ListNode *dummy = (struct ListNode *) malloc(sizeof(struct ListNode));</span><br><span class="line">    dummy-&gt;next = NULL;</span><br><span class="line">    // curNode_1：指向l1当前节点  curNode_2：指向l2当前节点   tail:指向新建链表dumm的最后一个节点</span><br><span class="line">    struct ListNode *curNode_1 = l1, *curNode_2 = l2,*tail = dummy, *newNode = NULL;</span><br><span class="line">    // l1和l2当前节点都不为NULL</span><br><span class="line">    while (curNode_1 != NULL &amp;&amp; curNode_2!= NULL) &#123;</span><br><span class="line">        newNode = (struct ListNode *) malloc(sizeof(struct ListNode));</span><br><span class="line">        // 将curNode_1-&gt;val的值挂到dumm链表的最后一个节点上</span><br><span class="line">        if (curNode_1-&gt;val &lt;= curNode_2-&gt;val) &#123;</span><br><span class="line">            newNode-&gt;val = curNode_1-&gt;val;</span><br><span class="line">            newNode-&gt;next = NULL;</span><br><span class="line">            tail-&gt;next = newNode;</span><br><span class="line">            tail = newNode;</span><br><span class="line">            curNode_1 = curNode_1-&gt;next;        // 更新curNode_1的位置</span><br><span class="line">        &#125; else&#123;  // 将curNode_2-&gt;val的值挂到dumm链表的最后一个节点上</span><br><span class="line">            newNode-&gt;val = curNode_2-&gt;val;</span><br><span class="line">            newNode-&gt;next = NULL;</span><br><span class="line">            tail-&gt;next = newNode;</span><br><span class="line">            tail = newNode;</span><br><span class="line">            curNode_2 = curNode_2-&gt;next;       // 更新curNode_2的位置</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果l2空  将l1剩余节点直接挂到dumm的最后一个节点</span><br><span class="line">    if (curNode_1 != NULL) &#123;</span><br><span class="line">        tail-&gt;next = curNode_1;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果l1空  将l2剩余节点直接挂到dumm的最后一个节点</span><br><span class="line">    if (curNode_2 != NULL) &#123;</span><br><span class="line">        tail-&gt;next = curNode_2;</span><br><span class="line">    &#125;</span><br><span class="line">    return dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h2><p>不需要额外的空间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 时间复杂度O(max(m,n))   空间复杂度O(1)      m:l1.length  n:l2.length</span><br><span class="line">struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2) &#123;</span><br><span class="line">    // 建头结点  不需要另外创建链表存放答案</span><br><span class="line">    struct ListNode *dummy = (struct ListNode *) malloc(sizeof(struct ListNode));</span><br><span class="line">    dummy-&gt;next = l1;</span><br><span class="line">    struct ListNode *curNode_1 = l1, *curNode_2 = l2,*tail = dummy;</span><br><span class="line">    // l1和l2当前节点都不为NULL</span><br><span class="line">    while (curNode_1 != NULL &amp;&amp; curNode_2!= NULL) &#123;</span><br><span class="line">        if (curNode_1-&gt;val &lt;= curNode_2-&gt;val) &#123;</span><br><span class="line">            tail-&gt;next = curNode_1;</span><br><span class="line">            tail = curNode_1;</span><br><span class="line">            curNode_1 = curNode_1-&gt;next;</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            tail-&gt;next = curNode_2;</span><br><span class="line">            tail = curNode_2;</span><br><span class="line">            curNode_2 = curNode_2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (curNode_1 != NULL) &#123;</span><br><span class="line">        tail-&gt;next = curNode_1;</span><br><span class="line">    &#125;</span><br><span class="line">    if (curNode_2 != NULL) &#123;</span><br><span class="line">        tail-&gt;next = curNode_2;</span><br><span class="line">    &#125;</span><br><span class="line">    return dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/21.%20Merge%20Two%20Sorted%20Lists" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C实现 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>82. Remove Duplicates from Sorted List II</title>
      <link href="/2018/10/08/82-Remove-Duplicates-from-Sorted-List-II/"/>
      <url>/2018/10/08/82-Remove-Duplicates-from-Sorted-List-II/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="82"><li>Remove Duplicates from Sorted List II:<a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/description/" target="_blank" rel="noopener">题目链接</a></li></ol><h2 id="方法1：双指针"><a href="#方法1：双指针" class="headerlink" title="方法1：双指针"></a>方法1：双指针</h2><p><strong><code>基本思想：</code></strong>用两个指针，一个快指针fast用来寻找重复元素的最后一个元素，漫指针fast用来链接重复元素之前的元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     struct ListNode *next;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">// 时间复杂度O(N)  空间复杂度O(1)  双指针</span><br><span class="line">struct ListNode* deleteDuplicates(struct ListNode* head) &#123;</span><br><span class="line">   struct ListNode *dummy = (struct ListNode *) malloc(sizeof(struct ListNode));</span><br><span class="line">    dummy-&gt;next = head;</span><br><span class="line">    // fast : 用来找到重复元素中 的最后一个元素</span><br><span class="line">    // slow : 指向重复元素之前的元素</span><br><span class="line">    struct ListNode *fast = head, *slow = dummy;</span><br><span class="line">    while (fast) &#123;</span><br><span class="line">        while (fast-&gt;next != NULL &amp;&amp; fast-&gt;val == fast-&gt;next-&gt;val) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if (slow-&gt;next != fast) &#123;</span><br><span class="line">            slow-&gt;next = fast-&gt;next;</span><br><span class="line">            fast = slow-&gt;next;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/82.%20Remove%20Duplicates%20from%20Sorted%20List%20II" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C实现 </tag>
            
            <tag> 链表 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>203. Remove Linked List Elements</title>
      <link href="/2018/10/07/203-Remove-Linked-List-Elements/"/>
      <url>/2018/10/07/203-Remove-Linked-List-Elements/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="203"><li>Remove Linked List Elements:<a href="https://leetcode.com/problems/remove-linked-list-elements/description/" target="_blank" rel="noopener">题目链接</a></li></ol><p><strong><code>基本思想：</code></strong></p><ul><li>curNode: 当前节点  简称c</li><li>nextNode:当前节点的下一个节点  简称n<blockquote><p>之所以建虚拟的头结点：如果第一个元素就是要删除的元素，没有前驱节点要另外讨论，故用虚拟的头结点作为其前驱节点 ，统一操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">删除的元素 val = 6</span><br><span class="line"></span><br><span class="line">dummyHead --&gt; 1 --&gt; 2 --&gt; 6 --&gt; 3 --&gt; 4 --&gt; 5 --&gt; 6</span><br><span class="line">    c         n    </span><br><span class="line">              c     n  </span><br><span class="line">                    c     n</span><br><span class="line">                                c     n</span><br><span class="line">                                      c     n</span><br><span class="line">                                            c     n</span><br><span class="line">                                                       c==NULL </span><br><span class="line"></span><br><span class="line">如果当前节点curNode的下一个节点nextNode的数据域和val相等 则将curNode指向nextNode的下一个节点,nextNode重新指向curNode的下一个节点，否则将curNode往后移，nextNode往后移</span><br></pre></td></tr></table></figure></blockquote></li></ul><h2 id="方法1：带头结点"><a href="#方法1：带头结点" class="headerlink" title="方法1：带头结点"></a>方法1：带头结点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 时间复杂度O(N)   空间复杂度O(1)</span><br><span class="line">struct ListNode  *dummyHead = (struct ListNode  *) malloc(sizeof(struct ListNode ));</span><br><span class="line">    dummyHead-&gt;next = head;</span><br><span class="line">    struct ListNode *curNode = dummyHead;</span><br><span class="line">    while (curNode != NULL &amp;&amp; curNode-&gt;next != NULL) &#123;</span><br><span class="line">        struct ListNode *nextNode = curNode-&gt;next;</span><br><span class="line">        if (nextNode-&gt;val == val) &#123;</span><br><span class="line">            curNode-&gt;next = nextNode-&gt;next;</span><br><span class="line">            free(nextNode);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            curNode = curNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dummyHead-&gt;next;</span><br></pre></td></tr></table></figure><h2 id="方法2：不带头结点"><a href="#方法2：不带头结点" class="headerlink" title="方法2：不带头结点"></a>方法2：不带头结点</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// 时间复杂度O(N)   空间复杂度O(1)   不带头结点</span><br><span class="line">struct ListNode *removeElements(struct ListNode *head, int val) &#123;</span><br><span class="line">    if (head==NULL)&#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    while (head != NULL &amp;&amp; head-&gt;val == val)&#123;           // 注意这里是while  比如 1  1 这种情况</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    struct ListNode *curNode = head;</span><br><span class="line">    while (curNode != NULL &amp;&amp; curNode-&gt;next != NULL) &#123;</span><br><span class="line">        struct ListNode *nextNode = curNode-&gt;next;</span><br><span class="line">        if (nextNode-&gt;val == val) &#123;</span><br><span class="line">            curNode-&gt;next = nextNode-&gt;next;</span><br><span class="line">            free(nextNode);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            curNode = curNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法3：递归求解"><a href="#方法3：递归求解" class="headerlink" title="方法3：递归求解"></a>方法3：递归求解</h2><p><div align="center" style="zoom: 50%; margin:  0px auto;"><img src="/2018/10/07/203-Remove-Linked-List-Elements/leetcode_203_1.png" alt="原理"></div><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 时间复杂度O(N)   空间复杂度O(N)   递归求解</span><br><span class="line">// 返回从head开始去除val的链表</span><br><span class="line">struct ListNode *removeElements(struct ListNode *head, int val) &#123;</span><br><span class="line">    if (NULL == head)&#123;      // 递归出口</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    head-&gt;next = removeElements(head-&gt;next, val);</span><br><span class="line">    return head-&gt;val == val ? head-&gt;next : head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/203.%20Remove%20Linked%20List%20Elements" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C实现 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>445. Add Two Numbers II</title>
      <link href="/2018/10/07/445-Add-Two-Numbers-II/"/>
      <url>/2018/10/07/445-Add-Two-Numbers-II/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="445"><li>Add Two Numbers II:<a href="https://leetcode.com/problems/add-two-numbers-ii/description/" target="_blank" rel="noopener">题目链接</a></li></ol><p><strong><code>基本思想：</code></strong>题目要求不能用逆转链表的方法，那么就用栈充当容器相当于逆转了链表，从各位开始算起，模拟<a href="https://leetcode.com/problems/add-two-numbers/solution/" target="_blank" rel="noopener">手算的过程</a></p><h2 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     struct ListNode *next;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    struct ListNode * pTop;</span><br><span class="line">&#125;LinkStack;</span><br><span class="line"></span><br><span class="line">LinkStack * createStack()&#123;</span><br><span class="line">    LinkStack *pS = (LinkStack *) malloc(sizeof(LinkStack));</span><br><span class="line">    pS-&gt;pTop = NULL;</span><br><span class="line">    return pS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void push(LinkStack * pS, int val)&#123;</span><br><span class="line">    struct ListNode *pNew = (struct ListNode *) malloc(sizeof(struct ListNode ));</span><br><span class="line">    pNew-&gt;val = val;</span><br><span class="line">    pNew-&gt;next = pS-&gt;pTop;</span><br><span class="line">    pS-&gt;pTop = pNew;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int pop(LinkStack * pS)&#123;</span><br><span class="line">    struct ListNode *pTemp = pS-&gt;pTop;</span><br><span class="line">    int popData = pTemp-&gt;val;</span><br><span class="line">    pS-&gt;pTop = pTemp-&gt;next;</span><br><span class="line">    free(pTemp);</span><br><span class="line">    return popData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int emptyStack(LinkStack * pS)&#123;</span><br><span class="line">    return NULL == pS-&gt;pTop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct ListNode *addTwoNumbers(struct ListNode *l1, struct ListNode *l2) &#123;</span><br><span class="line">    LinkStack *stack_1 = createStack();             // 此栈存放 l1链表</span><br><span class="line">    LinkStack *stack_2 = createStack();             // 此栈存放 l2链表</span><br><span class="line">    LinkStack *stack_sum = createStack();           // 此栈存放结果</span><br><span class="line">    // 建虚拟头结点 指针域记得置NULL</span><br><span class="line">    struct ListNode *dummy = (struct ListNode *) malloc(sizeof(struct ListNode));</span><br><span class="line">    dummy-&gt;next = NULL;</span><br><span class="line">    struct ListNode *curNode_1 = l1, *curNode_2 = l2, *pTail = dummy;</span><br><span class="line">    // 将l1中所有节点 入栈 7 2 4 3 入栈变成 3 4 2 7</span><br><span class="line">    while (curNode_1) &#123;</span><br><span class="line">        push(stack_1, curNode_1-&gt;val);</span><br><span class="line">        curNode_1 = curNode_1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    // 将l2中所有节点 入栈</span><br><span class="line">    while (curNode_2) &#123;</span><br><span class="line">        push(stack_2, curNode_2-&gt;val);</span><br><span class="line">        curNode_2 = curNode_2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int sum = 0, carry = 0;</span><br><span class="line">    // 两个栈都不为空 则将其栈顶元素 + 进位 入stack_sum栈</span><br><span class="line">    while (!emptyStack(stack_1) &amp;&amp; !emptyStack(stack_2)) &#123;</span><br><span class="line">        sum = pop(stack_1) + pop(stack_2) + carry;</span><br><span class="line">        carry = sum / 10;</span><br><span class="line">        push(stack_sum, sum % 10);</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果stack_1不空  stack_2空</span><br><span class="line">    while (!emptyStack(stack_1)) &#123;</span><br><span class="line">        sum = pop(stack_1) + carry;</span><br><span class="line">        carry = sum / 10;</span><br><span class="line">        push(stack_sum, sum % 10);</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果stack_2不空  stack_1空</span><br><span class="line">    while (!emptyStack(stack_2)) &#123;</span><br><span class="line">        sum = pop(stack_2) + carry;</span><br><span class="line">        carry = sum / 10;</span><br><span class="line">        push(stack_sum, sum % 10);</span><br><span class="line">    &#125;</span><br><span class="line">    // 当遍历到最后两个数 相加时 其值 &gt;= 10</span><br><span class="line">    if (carry &gt; 0) &#123;</span><br><span class="line">        push(stack_sum, carry);</span><br><span class="line">    &#125;</span><br><span class="line">    // 将stack_sum中的元素出栈 加入到链表dummy中 从 7 0 8 7变成 7 8 0 7</span><br><span class="line">    while (!emptyStack(stack_sum))&#123;</span><br><span class="line">        struct ListNode *pNew = (struct ListNode *) malloc(sizeof(struct ListNode));</span><br><span class="line">        pNew-&gt;val = pop(stack_sum);</span><br><span class="line">        pNew-&gt;next = NULL;</span><br><span class="line">        pTail-&gt;next = pNew;</span><br><span class="line">        pTail = pNew;</span><br><span class="line">    &#125;</span><br><span class="line">    return dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法2：在之前的基础上-优化"><a href="#方法2：在之前的基础上-优化" class="headerlink" title="方法2：在之前的基础上 优化"></a>方法2：在之前的基础上 优化</h2><ol><li>不需要利用stack_sum 直接使用从头部插入节点的建立链表方式</li><li>将两个栈空 一个栈空  最后两个数进位为1 等情况整合起来</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     struct ListNode *next;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">typedef struct &#123;</span><br><span class="line">    struct ListNode * pTop;</span><br><span class="line">&#125;LinkStack;</span><br><span class="line"></span><br><span class="line">LinkStack * createStack()&#123;</span><br><span class="line">    LinkStack *pS = (LinkStack *) malloc(sizeof(LinkStack));</span><br><span class="line">    pS-&gt;pTop = NULL;</span><br><span class="line">    return pS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void push(LinkStack * pS, int val)&#123;</span><br><span class="line">    struct ListNode *pNew = (struct ListNode *) malloc(sizeof(struct ListNode ));</span><br><span class="line">    pNew-&gt;val = val;</span><br><span class="line">    pNew-&gt;next = pS-&gt;pTop;</span><br><span class="line">    pS-&gt;pTop = pNew;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int pop(LinkStack * pS)&#123;</span><br><span class="line">    struct ListNode *pTemp = pS-&gt;pTop;</span><br><span class="line">    int popData = pTemp-&gt;val;</span><br><span class="line">    pS-&gt;pTop = pTemp-&gt;next;</span><br><span class="line">    free(pTemp);</span><br><span class="line">    return popData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int emptyStack(LinkStack * pS)&#123;</span><br><span class="line">    return NULL == pS-&gt;pTop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2) &#123;</span><br><span class="line">    LinkStack *stack_1 = createStack();             // 此栈存放 l1链表</span><br><span class="line">    LinkStack *stack_2 = createStack();             // 此栈存放 l2链表</span><br><span class="line">    // 建虚拟头结点 指针域记得置NULL</span><br><span class="line">    struct ListNode *dummy = (struct ListNode *) malloc(sizeof(struct ListNode));</span><br><span class="line">    dummy-&gt;next = NULL;</span><br><span class="line">    struct ListNode *curNode_1 = l1, *curNode_2 = l2, *pTail = dummy;</span><br><span class="line">    // 将l1中所有节点 入栈 7 2 4 3 入栈变成 3 4 2 7</span><br><span class="line">    while (curNode_1) &#123;</span><br><span class="line">        push(stack_1, curNode_1-&gt;val);</span><br><span class="line">        curNode_1 = curNode_1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    // 将l2中所有节点 入栈</span><br><span class="line">    while (curNode_2) &#123;</span><br><span class="line">        push(stack_2, curNode_2-&gt;val);</span><br><span class="line">        curNode_2 = curNode_2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int sum = 0, carry = 0;</span><br><span class="line">    // 改进： 将两个栈空 一个栈空  最后两个数进位为1 等情况整合起来</span><br><span class="line">    while (!emptyStack(stack_1) || !emptyStack(stack_2) || carry != 0) &#123;</span><br><span class="line">        int val_1 = emptyStack(stack_1) ? 0 : pop(stack_1);</span><br><span class="line">        int val_2 = emptyStack(stack_2) ? 0 : pop(stack_2);</span><br><span class="line">        sum = val_1 + val_2 + carry;</span><br><span class="line">        carry = sum / 10;</span><br><span class="line">        struct ListNode *pNew = (struct ListNode *) malloc(sizeof(struct ListNode));</span><br><span class="line">        pNew-&gt;val = sum % 10;</span><br><span class="line">        pNew-&gt;next = dummy-&gt;next;</span><br><span class="line">        dummy-&gt;next = pNew;</span><br><span class="line">    &#125;</span><br><span class="line">    return dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法3：利用两个栈-头插法的链表"><a href="#方法3：利用两个栈-头插法的链表" class="headerlink" title="方法3：利用两个栈 + 头插法的链表"></a>方法3：利用两个栈 + 头插法的链表</h2><p><strong><code>基本思想：</code></strong> 将两个链表分别压入栈中，然后出栈将结果用头插法放到结果链表中<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">pTop</span>;</span></span><br><span class="line">&#125;LinkStack;</span><br><span class="line"></span><br><span class="line"><span class="function">LinkStack * <span class="title">createStack</span><span class="params">()</span></span>&#123;</span><br><span class="line">    LinkStack *pS = (LinkStack *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkStack));</span><br><span class="line">    pS-&gt;pTop = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> pS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(LinkStack * pS, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">pNew</span> = (<span class="title">struct</span> <span class="title">ListNode</span> *) <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span> ));</span></span><br><span class="line">    pNew-&gt;val = val;</span><br><span class="line">    pNew-&gt;next = pS-&gt;pTop;</span><br><span class="line">    pS-&gt;pTop = pNew;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(LinkStack * pS)</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">pTemp</span> = <span class="title">pS</span>-&gt;<span class="title">pTop</span>;</span></span><br><span class="line">    <span class="keyword">int</span> popData = pTemp-&gt;val;</span><br><span class="line">    pS-&gt;pTop = pTemp-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(pTemp);</span><br><span class="line">    <span class="keyword">return</span> popData;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">emptyStack</span><span class="params">(LinkStack * pS)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span> == pS-&gt;pTop;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct ListNode* <span class="title">addTwoNumbers</span><span class="params">(struct ListNode* l1, struct ListNode* l2)</span></span>&#123;</span><br><span class="line">    LinkStack * stack1 = createStack();</span><br><span class="line">    LinkStack * stack2 = createStack();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">head</span> = (<span class="title">struct</span> <span class="title">ListNode</span>* ) <span class="title">malloc</span> (<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    head = <span class="literal">NULL</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>, carry = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">cur1</span> = <span class="title">l1</span>, * <span class="title">cur2</span> = <span class="title">l2</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (cur1 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        push(stack1, cur1-&gt;val);</span><br><span class="line">        cur1 = cur1-&gt;next;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (cur2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        push(stack2, cur2-&gt;val);</span><br><span class="line">        cur2 = cur2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// printf("1------------\n");</span></span><br><span class="line">    <span class="keyword">while</span> (emptyStack(stack1) == <span class="number">0</span> &amp;&amp; emptyStack(stack2) == <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="comment">// printf("22222------------\n");</span></span><br><span class="line">        <span class="keyword">int</span> top1 = pop(stack1);</span><br><span class="line">        <span class="keyword">int</span> top2 = pop(stack2);</span><br><span class="line">        sum = top1 + top2 + carry;</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">newNode</span> = (<span class="title">struct</span> <span class="title">ListNode</span>* ) <span class="title">malloc</span> (<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">        newNode-&gt;val = sum % <span class="number">10</span>;</span><br><span class="line">        newNode-&gt;next = head;</span><br><span class="line">        head = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (emptyStack(stack1) == <span class="number">0</span> ) &#123;</span><br><span class="line">        <span class="keyword">int</span> top1 = pop(stack1);</span><br><span class="line">        sum = top1 + carry;</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">newNode</span> = (<span class="title">struct</span> <span class="title">ListNode</span>* ) <span class="title">malloc</span> (<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">        newNode-&gt;val = sum % <span class="number">10</span>;</span><br><span class="line">        newNode-&gt;next = head;</span><br><span class="line">        head = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">     <span class="keyword">while</span> ( emptyStack(stack2) == <span class="number">0</span>) &#123;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">int</span> top2 = pop(stack2);</span><br><span class="line">        sum = top2 + carry;</span><br><span class="line">        carry = sum / <span class="number">10</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">newNode</span> = (<span class="title">struct</span> <span class="title">ListNode</span>* ) <span class="title">malloc</span> (<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">        newNode-&gt;val = sum % <span class="number">10</span>;</span><br><span class="line">        newNode-&gt;next = head;</span><br><span class="line">        head = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">newNode</span> = (<span class="title">struct</span> <span class="title">ListNode</span>* ) <span class="title">malloc</span> (<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">        newNode-&gt;val =carry;</span><br><span class="line">        newNode-&gt;next = head;</span><br><span class="line">        head = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/445.%20Add%20Two%20Numbers%20II" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C实现 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2. Add Two Numbers</title>
      <link href="/2018/10/06/2-Add-Two-Numbers/"/>
      <url>/2018/10/06/2-Add-Two-Numbers/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="2"><li>Add Two Numbers:<a href="https://leetcode.com/problems/add-two-numbers/description/" target="_blank" rel="noopener">题目链接</a></li></ol><p><strong><code>官方详细解析：</code></strong> &nbsp;<a href="https://leetcode.com/problems/add-two-numbers/solution/" target="_blank" rel="noopener">传送门</a></p><h2 id="方法1："><a href="#方法1：" class="headerlink" title="方法1："></a>方法1：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">// 时间复杂度O(max(n, m)) n:l1.length m:l2.length  空间复杂度O(max(m,n))</span><br><span class="line">struct ListNode *addTwoNumbers(struct ListNode *l1, struct ListNode *l2) &#123;</span><br><span class="line">    // 创建一个带头结点dummy的链表来存放结果</span><br><span class="line">    LinkNode *dummy = (LinkNode *) malloc(sizeof(LinkNode));</span><br><span class="line">    int sum = 0, carry = 0;</span><br><span class="line">    LinkNode *curNode_1 = l1, *curNode_2 = l2, *newNode = NULL, *tail = NULL;</span><br><span class="line">    tail = dummy;</span><br><span class="line">    tail-&gt;next = NULL;</span><br><span class="line">    // 遍历l1和l2 ,curNode_1是l1当前所在节点 ,l2同理;</span><br><span class="line">    while (curNode_1 &amp;&amp; curNode_2)&#123;</span><br><span class="line">        sum = curNode_1-&gt;val + curNode_2-&gt;val + carry;  // 当前对应两节点的值 + 进位</span><br><span class="line">        carry = sum / 10;</span><br><span class="line">        // 创建新的节点来存放sum % 10 如果是12则只保留2 carry = 1,并将此节点挂到tail的指针域并更新tail的位置</span><br><span class="line">        newNode = (LinkNode *) malloc(sizeof(LinkNode));</span><br><span class="line">        newNode-&gt;val = sum % 10;</span><br><span class="line">        newNode-&gt;next = NULL;</span><br><span class="line">        tail-&gt;next = newNode;</span><br><span class="line">        tail = newNode;</span><br><span class="line">        // 更新curNode_1和curNode_2的位置</span><br><span class="line">        curNode_1 = curNode_1-&gt;next;</span><br><span class="line">        curNode_2 = curNode_2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果l2已经空了</span><br><span class="line">    while (curNode_1)&#123;</span><br><span class="line">        sum = curNode_1-&gt;val + carry;</span><br><span class="line">        newNode = (LinkNode *) malloc(sizeof(LinkNode));</span><br><span class="line">        newNode-&gt;val = sum % 10;</span><br><span class="line">        newNode-&gt;next = NULL;</span><br><span class="line">        carry = sum / 10;</span><br><span class="line">        tail-&gt;next = newNode;</span><br><span class="line">        tail = newNode;</span><br><span class="line">        curNode_1 = curNode_1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    // 如果l1已经空了</span><br><span class="line">    while (curNode_2)&#123;</span><br><span class="line">        sum = curNode_2-&gt;val + carry;</span><br><span class="line">        newNode = (LinkNode *) malloc(sizeof(LinkNode));</span><br><span class="line">        newNode-&gt;val = sum % 10;</span><br><span class="line">        newNode-&gt;next = NULL;</span><br><span class="line">        carry = sum / 10;</span><br><span class="line">        tail-&gt;next = newNode;</span><br><span class="line">        tail = newNode;</span><br><span class="line">        curNode_2 = curNode_2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    // 两个链表最后两节点相加时&gt;=10 创建一个节点保存进位</span><br><span class="line">    if (carry &gt; 0)&#123;</span><br><span class="line">        newNode = (LinkNode *) malloc(sizeof(LinkNode));</span><br><span class="line">        newNode-&gt;val = carry;</span><br><span class="line">        newNode-&gt;next = NULL;</span><br><span class="line">        tail-&gt;next = newNode;</span><br><span class="line">        tail = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    return dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法2：优化"><a href="#方法2：优化" class="headerlink" title="方法2：优化"></a>方法2：优化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">struct ListNode *addTwoNumbers(struct ListNode *l1, struct ListNode *l2) &#123;</span><br><span class="line">    // 创建一个带头结点dummy的链表来存放结果</span><br><span class="line">    struct ListNode *dummy = (struct ListNode *) malloc(sizeof(struct ListNode));</span><br><span class="line">    int sum = 0, carry = 0;</span><br><span class="line">    struct ListNode *curNode_1 = l1, *curNode_2 = l2, *newNode = NULL, *tail = dummy;</span><br><span class="line">    tail-&gt;next = NULL;</span><br><span class="line">  // 将多种情况 合并在一起解决</span><br><span class="line">    while (curNode_1 || curNode_2 || carry != 0) &#123;</span><br><span class="line">        int val_1 = curNode_1 == NULL ? 0 : curNode_1-&gt;val;</span><br><span class="line">        int val_2 = curNode_2 == NULL ? 0 : curNode_2-&gt;val;</span><br><span class="line">        sum = val_1 + val_2 + carry;            // 当前对应两节点的值 + 进位</span><br><span class="line">        carry = sum / 10;</span><br><span class="line"></span><br><span class="line">        // 创建新的节点来存放sum % 10 如果是12则只保留2 carry = 1,并将此节点挂到tail的指针域并更新tail的位置</span><br><span class="line">        newNode = (struct ListNode *) malloc(sizeof(struct ListNode));</span><br><span class="line">        newNode-&gt;val = sum % 10;</span><br><span class="line">        newNode-&gt;next = NULL;</span><br><span class="line">        tail-&gt;next = newNode;</span><br><span class="line">        tail = newNode;</span><br><span class="line">        printf(&quot;push: %d \n&quot;, newNode-&gt;val);</span><br><span class="line">        // 更新curNode_1和curNode_2的位置</span><br><span class="line">        if (curNode_1) &#123;</span><br><span class="line">            curNode_1 = curNode_1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if (curNode_2) &#123;</span><br><span class="line">            curNode_2 = curNode_2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/2.%20Add%20Two%20Numbers" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C实现 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>328. Odd Even Linked List</title>
      <link href="/2018/10/05/328-Odd-Even-Linked-List/"/>
      <url>/2018/10/05/328-Odd-Even-Linked-List/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="328"><li>Odd Even Linked List:<a href="https://leetcode.com/problems/odd-even-linked-list/description/" target="_blank" rel="noopener">题目链接</a><br>相似题目86. Partition List:<a href="https://leetcode.com/problems/partition-list/description/" target="_blank" rel="noopener">题目链接</a></li></ol><p><strong><code>基本思想:</code></strong>在遍历head的同时，创建两个链表，(dummy_1)用来存放位置为奇数的节点，(dummy_2)用来存放位置为偶数的节点，最后将dummy_2的最后一个节点指针域置为NULL，被链接到dummy_1的最后一个节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 时间复杂度O(N)  空间复杂度O(1)</span><br><span class="line">LinkNode * oddEvenList(struct ListNode* head) &#123;</span><br><span class="line">    LinkNode *dummy_1 = (LinkNode *) malloc(sizeof(LinkNode));     // 设立带头结点的链表 存放位置为奇数的节点</span><br><span class="line">    LinkNode *dummy_2 = (LinkNode *) malloc(sizeof(LinkNode));     // 设立带头结点的链表 存放位置为偶数的节点</span><br><span class="line">    LinkNode *curNode_1 = dummy_1, *curNode_2 = dummy_2;</span><br><span class="line">    int count = 1;                                                 // 计数器</span><br><span class="line">    while (head) &#123;</span><br><span class="line">        if (0 != count % 2) &#123;</span><br><span class="line">            curNode_1-&gt;next = head;</span><br><span class="line">            curNode_1 = head;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            curNode_2-&gt;next = head;</span><br><span class="line">            curNode_2 = head;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    curNode_2-&gt;next = NULL;          // dummy_2要接在dummy_1的后面，当然要将整体的最后一个元素的指针域置为NULL</span><br><span class="line">    curNode_1-&gt;next = dummy_2-&gt;next;</span><br><span class="line">    return dummy_1-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/328.%20Odd%20Even%20Linked%20List" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C实现 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>86. Partition List</title>
      <link href="/2018/10/05/86-Partition-List/"/>
      <url>/2018/10/05/86-Partition-List/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="86"><li>Partition List:<a href="https://leetcode.com/problems/partition-list/description/" target="_blank" rel="noopener">题目链接</a></li></ol><p><strong><code>基本思想:</code></strong>在遍历head的同时，创建两个链表，(dummy_1)用来存放小于x的节点，(dummy_2)用来存放大于等于x的节点，最后将dummy_2的最后一个节点指针域置为NULL，被链接到dummy_1的最后一个节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 时间复杂度O(N)  空间复杂度O(1)</span><br><span class="line">struct ListNode *partition(struct ListNode *head, int x) &#123;</span><br><span class="line">    LinkNode *dummy_1 = (LinkNode *) malloc(sizeof(LinkNode));      // 设立带头结点的链表 存放小于x的节点</span><br><span class="line">    LinkNode *dummy_2 = (LinkNode *) malloc(sizeof(LinkNode));      // 设立带头结点的链表 存放大于等于x的节点</span><br><span class="line">    LinkNode *curNode_1 = dummy_1, *curNode_2 = dummy_2;</span><br><span class="line">    while (head) &#123;</span><br><span class="line">        if (head-&gt;val &lt; x) &#123;</span><br><span class="line">            curNode_1-&gt;next = head;</span><br><span class="line">            curNode_1 = head;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            curNode_2-&gt;next = head;</span><br><span class="line">            curNode_2 = head;</span><br><span class="line">        &#125;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    curNode_2-&gt;next = NULL;           // dummy_2要接在dummy_1的后面，当然要将整体的最后一个元素的指针域置为NULL</span><br><span class="line">    curNode_1-&gt;next = dummy_2-&gt;next;</span><br><span class="line">    return dummy_1-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/86.%20Partition%20List" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C实现 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>83. Remove Duplicates from Sorted List</title>
      <link href="/2018/10/05/83-Remove-Duplicates-from-Sorted-List/"/>
      <url>/2018/10/05/83-Remove-Duplicates-from-Sorted-List/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="83"><li>Remove Duplicates from Sorted List:<a href="https://leetcode.com/problems/remove-duplicates-from-sorted-list/description/" target="_blank" rel="noopener">题目链接</a></li></ol><h2 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 时间复杂度O(N)  空间复杂度O(1)</span><br><span class="line">struct ListNode *deleteDuplicates(struct ListNode *head) &#123;</span><br><span class="line">    if (head == NULL) &#123;</span><br><span class="line">        return NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkNode *curNode = head;                         // 当前所在点</span><br><span class="line">    LinkNode *nextNode = head-&gt;next;                  // 当前节点的下一个节点</span><br><span class="line">    while (curNode &amp;&amp; nextNode)&#123;</span><br><span class="line">        if (curNode-&gt;val == nextNode-&gt;val)&#123;           // 两者数据域相等</span><br><span class="line">            curNode-&gt;next = nextNode-&gt;next;</span><br><span class="line">            nextNode = nextNode-&gt;next;</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            curNode = nextNode;</span><br><span class="line">            nextNode = nextNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法2：双指针"><a href="#方法2：双指针" class="headerlink" title="方法2：双指针"></a>方法2：双指针</h2><p>与方法1相比慢一点<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 时间复杂度O(N)  空间复杂度O(1)   双指针</span><br><span class="line">struct ListNode *deleteDuplicates(struct ListNode *head) &#123;</span><br><span class="line">    struct ListNode *dummy = (struct ListNode *) malloc(sizeof(struct ListNode));</span><br><span class="line">    dummy-&gt;next = head;</span><br><span class="line">    // fast : 最后一个重复元素的最后一个元素</span><br><span class="line">    // slow : 链接重复元素之前的元素</span><br><span class="line">    struct ListNode *fast = head, *slow = dummy;</span><br><span class="line">    while (fast)&#123;</span><br><span class="line">        while (fast-&gt;next != NULL &amp;&amp; fast-&gt;next-&gt;val == fast-&gt;val) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if (slow-&gt;next != fast) &#123;</span><br><span class="line">            slow-&gt;next = fast;</span><br><span class="line">            slow = fast;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    return dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/83.%20Remove%20Duplicates%20from%20Sorted%20List" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C实现 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>92. Reverse Linked List II</title>
      <link href="/2018/10/04/92-Reverse-Linked-List-II/"/>
      <url>/2018/10/04/92-Reverse-Linked-List-II/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="92"><li>Reverse Linked List II:<a href="https://leetcode.com/problems/reverse-linked-list-ii/description/" target="_blank" rel="noopener">题目链接</a></li></ol><h2 id="方法1：穿针引线"><a href="#方法1：穿针引线" class="headerlink" title="方法1：穿针引线"></a>方法1：穿针引线</h2><ul><li>pre:指向[m, n]这段链表之前的一个节点</li><li>curNode: 当前指向的节点  简称c</li><li>nextNode: 当前指向的下一个节点    简称n</li></ul><p><strong><code>基本思想：</code></strong>先找到m节点的前驱pre所在的位置，每次将curNode放在nextNode的后面，将nextNode放在pre的后面 如下所示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">m = 2， n = 4 将[m,n]的元素逆转</span><br><span class="line"></span><br><span class="line">初始： dummyHead --&gt; 1 --&gt; 2 --&gt; 3 --&gt; 4 --&gt; 5</span><br><span class="line">                    pre   c     n</span><br><span class="line"></span><br><span class="line">一次： dummyHead --&gt; 1 --&gt; 3 --&gt; 2 --&gt; 4 --&gt; 5</span><br><span class="line">                    pre         c     n</span><br><span class="line"></span><br><span class="line">二次： dummyHead --&gt; 1 --&gt; 4 --&gt; 3 --&gt; 2 --&gt; 5</span><br><span class="line">                    pre               c     n</span><br><span class="line"></span><br><span class="line">// 注意在这里我只需要提前遍历一趟链表找到m前驱的位置并不需要找去n的位置，进而找到m的位置然后在做n-m次图示操作就行</span><br></pre></td></tr></table></figure></p><p><strong><code>AC代码:</code></strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度O(N)   空间复杂度O(1)</span></span><br><span class="line"><span class="function">struct ListNode *<span class="title">reverseBetween</span><span class="params">(struct ListNode *head, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 假设：1 -&gt; 2  -&gt; 3  -&gt; 4  -&gt; 5    m = 1, n = 2  不设头结点 要找到1的前驱 pre只能从head开始</span></span><br><span class="line">    <span class="comment">// 不能等于null否则pre-&gt;next无效，无法后移  即 pre = 1 、start = 1 、 end = 2</span></span><br><span class="line">    <span class="comment">// 为了在m=1时统一操作就跟单链表的插入删除一样  加上头结点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">dummyHead</span> = (<span class="title">struct</span> <span class="title">ListNode</span> *) <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    dummyHead-&gt;next = head;</span><br><span class="line">    <span class="keyword">if</span>(m == n)&#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">pre</span> = <span class="title">dummyHead</span>, *<span class="title">curNode</span> = <span class="title">NULL</span>, *<span class="title">nextNode</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (pre != <span class="literal">NULL</span> &amp;&amp; i &lt; m - <span class="number">1</span>) &#123;                <span class="comment">// 找到pre的位置</span></span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == pre) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    curNode = pre-&gt;next;                              <span class="comment">// 确定curNode的位置</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n - m &amp;&amp; curNode != <span class="literal">NULL</span>; ++i) &#123;  <span class="comment">// 开始reverse</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"aaaa\n"</span>);</span><br><span class="line">        nextNode = curNode-&gt;next;</span><br><span class="line">        curNode-&gt;next = nextNode-&gt;next;</span><br><span class="line">        nextNode-&gt;next = pre-&gt;next;                   <span class="comment">// 注意这里不要写成了nextNode&gt;next = curNode</span></span><br><span class="line">        pre-&gt;next = nextNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/92.%20Reverse%20Linked%20List%20II" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C实现 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 206. Reverse Linked List</title>
      <link href="/2018/09/16/leetcode-206-Reverse-Linked-List/"/>
      <url>/2018/09/16/leetcode-206-Reverse-Linked-List/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="206"><li>Reverse Linked List:<a href="https://leetcode.com/problems/reverse-linked-list/description/" target="_blank" rel="noopener">题目链接</a>  </li></ol><h2 id="方法1：反转指针-推荐"><a href="#方法1：反转指针-推荐" class="headerlink" title="方法1：反转指针  (推荐)"></a>方法1：反转指针  (推荐)</h2><p><strong><code>基本思想：</code></strong> 从开始节点开始将其指针域指向其前驱，这时为了防止断链需要一个指针nextNode记住当前节点的后继节点</p><ol><li>第一个节点的指针域应置为NULL，作为反转链表后的表尾</li><li>处理完最后一个节点时，要将头结点指向它</li></ol><ul><li>cur:指向当前所在节点   初始化：head  </li><li>pre:cur的前驱节点     初始化：NULL</li><li>nextNode: cur的后继节点    简称q   </li></ul><div align="center" style="zoom: 70%; margin:  0px auto;"><img src="/2018/09/16/leetcode-206-Reverse-Linked-List/leetcode_206_1.png" alt="原理"></div><p><strong><code>AC代码：</code></strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度O(N)  空间复杂度O(1)</span></span><br><span class="line"><span class="function">struct ListNode* <span class="title">reverseList</span><span class="params">(struct ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">dummyHead</span> = (<span class="title">struct</span> <span class="title">ListNode</span> *) <span class="title">malloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    dummyHead-&gt;next = head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>*<span class="title">curNode</span> = <span class="title">dummyHead</span>-&gt;<span class="title">next</span>, *<span class="title">pre</span> = <span class="title">NULL</span>, *<span class="title">nextNode</span> = <span class="title">NULL</span>;</span>   <span class="comment">// 注意*pre = NULL 方便将第一个有效节点的指针域置为NULL(新的表尾)</span></span><br><span class="line">    <span class="keyword">while</span> (curNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        nextNode = curNode-&gt;next;</span><br><span class="line">        curNode-&gt;next = pre;            <span class="comment">// 反转指针</span></span><br><span class="line">        pre = curNode;                  <span class="comment">// 更新pre</span></span><br><span class="line">        curNode = nextNode;             <span class="comment">// 更新curNode</span></span><br><span class="line">    &#125;</span><br><span class="line">    dummyHead-&gt;next = pre;              <span class="comment">// 此时pre指向链表最后一个元素 将反转后的链表挂到头结点后面</span></span><br><span class="line">    <span class="keyword">return</span> dummyHead-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="方法2：头插法"><a href="#方法2：头插法" class="headerlink" title="方法2：头插法"></a>方法2：头插法</h2><p><strong><code>基本思想：</code></strong>将头节点摘下，然后从开始节点开始，依次前插到头结点后面(头插法建立链表,栈)，直到最后一个节点为止，注意这里将节点插入到头结点后，开始节点前</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">初始时：dummy -&gt; <span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">3</span> -&gt; <span class="number">4</span> -&gt; <span class="number">5</span></span><br><span class="line">dummy -&gt; <span class="literal">NULL</span>  先将头指针的指针域置为<span class="literal">NULL</span>   剩下的链表为： <span class="number">1</span> -&gt; <span class="number">2</span> -&gt; <span class="number">3</span> -&gt; <span class="number">4</span> -&gt; <span class="number">5</span></span><br><span class="line">dummy -&gt; <span class="number">1</span>                          依次前插到头结点后面</span><br><span class="line">dummy -&gt; <span class="number">2</span> -&gt; <span class="number">1</span></span><br><span class="line">dummy -&gt; <span class="number">3</span> -&gt; <span class="number">2</span> -&gt; <span class="number">1</span></span><br><span class="line">dummy -&gt; <span class="number">4</span> -&gt; <span class="number">3</span> -&gt; <span class="number">2</span> -&gt; <span class="number">1</span></span><br><span class="line">dummy -&gt; <span class="number">5</span> -&gt; <span class="number">4</span> -&gt; <span class="number">3</span> -&gt; <span class="number">2</span> -&gt; <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong><code>AC代码：</code></strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度O(N)  空间复杂度O(1)  头插法(栈)</span></span><br><span class="line"><span class="function">struct ListNode* <span class="title">reverseList</span><span class="params">(struct ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">dummy</span> = (<span class="title">struct</span> <span class="title">ListNode</span>*) <span class="title">malloc</span> (<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">ListNode</span>));</span></span><br><span class="line">    dummy-&gt;next = head;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">curNode</span> = <span class="title">dummy</span>-&gt;<span class="title">next</span> , *<span class="title">nextNode</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    dummy-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (curNode != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        nextNode = curNode-&gt;next;</span><br><span class="line">        curNode-&gt;next = dummy-&gt;next;</span><br><span class="line">        dummy-&gt;next = curNode;</span><br><span class="line">        curNode = nextNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="方法3：递归"><a href="#方法3：递归" class="headerlink" title="方法3：递归"></a>方法3：递归</h2><p><strong><code>AC代码：</code></strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度O(N)  空间复杂度O(N)</span></span><br><span class="line"><span class="function">struct ListNode* <span class="title">reverseList</span><span class="params">(struct ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next==<span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> * <span class="title">newHead</span> = <span class="title">reverseList</span>(<span class="title">head</span>-&gt;<span class="title">next</span>);</span></span><br><span class="line">    <span class="comment">// head-&gt;next此刻指向head后面的链表的尾节点</span></span><br><span class="line">    <span class="comment">// head-&gt;next-&gt;next = head把head节点放在了尾部</span></span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/206.%20Reverse%20Linked%20List" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C实现 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 16.3Sum closest</title>
      <link href="/2018/09/08/leetcode-16-3Sum-closest/"/>
      <url>/2018/09/08/leetcode-16-3Sum-closest/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="3"><li>sum closest:<a href="https://leetcode.com/problems/3sum-closest/description/" target="_blank" rel="noopener">题目链接</a></li></ol><p>在之前<a href="https://xerdemo.github.io/2018/09/06/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-15-3Sum/">3Sum</a>的基础上加上了一个条件</p><h2 id="方法1：双指针"><a href="#方法1：双指针" class="headerlink" title="方法1：双指针"></a>方法1：双指针</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class Solution1 &#123;</span><br><span class="line">    // 时间复杂度O(N^2)  </span><br><span class="line">    public int threeSumClosest(int[] nums, int target) &#123;</span><br><span class="line">        int res = 99999999;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        for (int i = 0; i &lt; nums.length - 2; ++i) &#123;</span><br><span class="line">            int left = i + 1, right = nums.length - 1;</span><br><span class="line">            while (left &lt; right)&#123;</span><br><span class="line">                int sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">                if (Math.abs(sum - target) &lt;= Math.abs(res-target))&#123;</span><br><span class="line">                    res = sum;</span><br><span class="line">                &#125;</span><br><span class="line">                if (sum &gt; target)&#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;else if(sum &lt; target)&#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    return sum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] nums = &#123;-1, 2, 1, -4&#125;;</span><br><span class="line">        int target = 1;</span><br><span class="line">        System.out.println(new Solution1().threeSumClosest(nums,target));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法2：-优化"><a href="#方法2：-优化" class="headerlink" title="方法2： 优化"></a>方法2： 优化</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class Solution2 &#123;</span><br><span class="line">    // 时间复杂度O(N^2)</span><br><span class="line">    public int threeSumClosest(int[] nums, int target) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        int res = Integer.MAX_VALUE - 999999;</span><br><span class="line">        int left, right;</span><br><span class="line">        for (int i = 0; i &lt; nums.length - 1; i++) &#123;</span><br><span class="line">            left = i + 1;</span><br><span class="line">            right = nums.length - 1;</span><br><span class="line">            while (left &lt; right) &#123;</span><br><span class="line">                int sum = nums[left] + nums[right] + nums[i];</span><br><span class="line">                if (sum == target) return target;</span><br><span class="line">                else if (sum &gt; target) &#123;</span><br><span class="line">                    while (left &lt; right &amp;&amp; nums[left] + nums[right] + nums[i] &gt; target) right--;</span><br><span class="line">                    if (Math.abs(nums[i] + nums[left] + nums[right + 1] - target) &lt; Math.abs(res - target))</span><br><span class="line">                        res = nums[i] + nums[left] + nums[right + 1];</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    while (left &lt; right &amp;&amp; nums[left] + nums[right] + nums[i] &lt; target) left++;</span><br><span class="line">                    if (Math.abs(nums[i] + nums[left - 1] + nums[right] - target) &lt; Math.abs(res - target))</span><br><span class="line">                        res = nums[i] + nums[left - 1] + nums[right];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] nums = &#123;-4, -3, -2, 0, 2, 2, 3, 4&#125;;</span><br><span class="line">        int target = 1;</span><br><span class="line">        System.out.println(new Solution2().threeSumClosest(nums, target));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/16.%203Sum%20Closest" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> java实现 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 18. 4Sum</title>
      <link href="/2018/09/07/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-18-4Sum/"/>
      <url>/2018/09/07/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-18-4Sum/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="18"><li>4Sum:<a href="https://leetcode.com/problems/4sum/description/" target="_blank" rel="noopener">题目链接</a></li></ol><p>在<a href="https://xerdemo.github.io/2018/09/05/leetcode-1-Two-Sum/">2Sum</a>  <a href="https://xerdemo.github.io/2018/09/06/leetcode-15-3Sum/">3Sum</a>的基础上进行升级</p><h2 id="解法1：双指针"><a href="#解法1：双指针" class="headerlink" title="解法1：双指针"></a>解法1：双指针</h2><p><strong><code>基本思想：</code></strong> 用四个指针i，j，left，right分别指向排好序后，从左往右对应nums[i] + nums[j] + nums[left] + nums[right] == target;<br>用for循环遍历指针i，其有效范围[i,nums.length-4] 注意是左闭右闭区间，如果是左闭右开则是[i,nums.length-3)<br>用for循环遍历指针j，其有效范围[i+1, nums.length-3]<br>再用双指针方法在[j+1,nums.length-1]范围寻找left，right使得nums[i] + nums[j] + nums[left] + nums[right] == target</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class Solution1 &#123;</span><br><span class="line">    // 时间复杂度O(n^3)  双指针</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123;</span><br><span class="line">        Arrays.sort(nums);            // 按从小到大 排序  nums[i] &lt;= nums[j] &lt;= nums[left] &lt;= nums[right]</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        // 遍历第一个指针i 范围[0,nums.length-4]</span><br><span class="line">        for (int i = 0; i &lt; nums.length - 3; ++i) &#123;</span><br><span class="line">            if (nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] &gt; target) &#123;      // 如果四个最小的元素都比target大</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (nums[i] + nums[nums.length - 1] + nums[nums.length - 2] + nums[nums.length - 3] &lt; target) &#123;</span><br><span class="line">                // nums[i]和三个最大元素的和都比target小  i++</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            // 选取第一个元素时 如果发现存在两个或以上的nums[i]相等，选取最后一个，防止在res中出现重复结果</span><br><span class="line">            if (i == 0 || (i &gt; 0 &amp;&amp; nums[i] != nums[i - 1])) &#123;</span><br><span class="line">                // 遍历第二个指针j 范围[i+1, nums.length-3]</span><br><span class="line">                for (int j = i + 1; j &lt; nums.length - 2; ++j) &#123;</span><br><span class="line">                    if (nums[i] + nums[j] + nums[j + 1] + nums[j + 2] &gt; target) &#123;  // 说明第二个元素nums[j]太大</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (nums[i] + nums[j] + nums[nums.length - 1] + nums[nums.length - 2] &lt; target) &#123;</span><br><span class="line">                        // 说明nums[j] 太小 j++</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;</span><br><span class="line">                    // 在[i+1,nums.length-3]从如果出现连续nums[j]相等 取最后一个 预防在res中出现重复元素</span><br><span class="line">                    if (j == i + 1 || (j &gt; i + 1 &amp;&amp; nums[j] != nums[j - 1])) &#123;</span><br><span class="line">                        // 使用双指针</span><br><span class="line">                        int left = j + 1;</span><br><span class="line">                        int right = nums.length - 1;</span><br><span class="line">                        while (left &lt; right) &#123;</span><br><span class="line">                            int sum = nums[i] + nums[j] + nums[left] + nums[right];</span><br><span class="line">                            if (sum == target) &#123;</span><br><span class="line">                                // 取连续相等nums[left]中的最后一个</span><br><span class="line">                                while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) &#123;</span><br><span class="line">                                    left++;</span><br><span class="line">                                &#125;</span><br><span class="line">                                // 取连续相等nums[right]中的从右往左的最后一个</span><br><span class="line">                                while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) &#123;</span><br><span class="line">                                    right--;</span><br><span class="line">                                &#125;</span><br><span class="line">                                List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">                                list.add(nums[i]);</span><br><span class="line">                                list.add(nums[j]);</span><br><span class="line">                                list.add(nums[left++]);</span><br><span class="line">                                list.add(nums[right--]);</span><br><span class="line">                                res.add(list);</span><br><span class="line">                            &#125; else if (sum &gt; target) &#123;</span><br><span class="line">                                right--;</span><br><span class="line">                            &#125; else &#123;</span><br><span class="line">                                left++;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] nums = &#123;-1, 0, 1, 2, -1, -4&#125;;</span><br><span class="line">        int target = -1;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = new Solution1().fourSum(nums, target);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/18.%204Sum" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> java实现 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 15. 3Sum</title>
      <link href="/2018/09/06/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-15-3Sum/"/>
      <url>/2018/09/06/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-15-3Sum/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="15"><li>3Sum:<a href="https://leetcode.com/problems/3sum/description/" target="_blank" rel="noopener">题目链接</a></li></ol><p><strong><code>基本思想：</code></strong> 先对数组排序 ，用一个for循环寻找第一个元素(索引为i)，在用双指针在[i+1,nums.length-1]寻找第二个元素(索引left)，第三个元素(索引right) .<br>如果nums[i] + nums[left] + nums[right] == 0 说明找到了<br>如果nums[i] + nums[left] + nums[right] &lt; 0 left++<br>如果nums[i] + nums[left] + nums[right] &gt; 0 right–</p><h2 id="方法1："><a href="#方法1：" class="headerlink" title="方法1："></a>方法1：</h2><p>注意此方法超时了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class Solution1 &#123;</span><br><span class="line">    // 时间复杂度O(Nlog2^N) + O(N^2)      排序 + 双指针</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; nums.length - 2; ++i) &#123;</span><br><span class="line">            int left = i + 1;</span><br><span class="line">            int right = nums.length - 1;</span><br><span class="line">            // 在[i+1,nums.length-1] 用双指针搜索另外两个元素</span><br><span class="line">            while (left &lt; right) &#123;</span><br><span class="line">                int sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">                if (sum == 0) &#123;</span><br><span class="line">                    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">                    list.add(nums[i]);</span><br><span class="line">                    list.add(nums[left++]);</span><br><span class="line">                    list.add(nums[right--]);</span><br><span class="line">                    res.add(list);</span><br><span class="line">                &#125; else if (sum &lt; 0) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;List&lt;Integer&gt;&gt; set = new HashSet&lt;&gt;(res);    // set用来给结果 去重</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;(set); // 将set转list</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] nums = &#123;-1, 0, 1, 2, -1, -4&#125;;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = new Solution1().threeSum(nums);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="方法2：sorting-twoPoint-推荐"><a href="#方法2：sorting-twoPoint-推荐" class="headerlink" title="方法2：sorting + twoPoint(推荐)"></a>方法2：sorting + twoPoint(推荐)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class Solution2 &#123;</span><br><span class="line">    // 时间复杂度O(Nlog2^N) + O(N^2)      排序 + 双指针</span><br><span class="line">    // 优化Solution1  不需要set去重 直接在找的时候重复元素不添加到res中</span><br><span class="line">    // 选取的三个元素 索引从左到右  分别为 i 、left 、right(nums[i] &lt;= nums[left] &lt;= nums[rigt])</span><br><span class="line">    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);                               // 先将数组按从小到大排序</span><br><span class="line">        for (int i = 0; i &lt; nums.length - 2; ++i) &#123;</span><br><span class="line">            if (nums[i] &gt; 0) &#123;                           // 最小的元素都大于0 结束</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (nums[i] + nums[nums.length-1] + nums[nums.length-2] &lt; 0) &#123;   // 说明第一个元素nums[i]太小了</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if (i == 0 || (i &gt; 0 &amp;&amp; nums[i] != nums[i - 1])) &#123;      // 防止res中有重复的结果</span><br><span class="line">                int left = i + 1;</span><br><span class="line">                int right = nums.length - 1;</span><br><span class="line">                while (left &lt; right) &#123;</span><br><span class="line">                    int sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">                    if (sum == 0) &#123;</span><br><span class="line">                        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">                        while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) &#123;   // 防止res中有重复的结果</span><br><span class="line">                            left++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) &#123; // 防止res中有重复的结果</span><br><span class="line">                            right--;</span><br><span class="line">                        &#125;</span><br><span class="line">                        list.add(nums[i]);</span><br><span class="line">                        list.add(nums[left++]);</span><br><span class="line">                        list.add(nums[right--]);</span><br><span class="line">                        res.add(list);</span><br><span class="line">                    &#125; else if (sum &lt; 0) &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        right--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] nums = &#123;-1, 0, 1, 2, -1, -4&#125;;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = new Solution2().threeSum(nums);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/15.%203Sum" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> java实现 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 1. Two Sum</title>
      <link href="/2018/09/05/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-1-Two-Sum/"/>
      <url>/2018/09/05/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-1-Two-Sum/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol><li>Two Sum:<a href="https://leetcode.com/problems/two-sum/description/" target="_blank" rel="noopener">题目链接</a></li></ol><h2 id="方法1：双指针"><a href="#方法1：双指针" class="headerlink" title="方法1：双指针"></a>方法1：双指针</h2><p><strong><code>基本思路：</code></strong> 先对数组进行排序，然后一个指针left指向数组第一个元素，一个指针right指向数组最后一个元素,将两者相加，只有可能有三种情况</p><ol><li>nums[left] + nums[right] == target      找到了</li><li>nums[left] + nums[right] &lt; target       因为数组是有序状态 将left++  及增大两者的和</li><li>nums[left] + nums[right] &gt; target       因为数组是有序状态 将right– 及减小两者的和</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line">public class Solution1 &#123;</span><br><span class="line">    // 时间复杂度O（Nlog2^N）</span><br><span class="line">    public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">        int[] tempArr = Arrays.copyOf(nums, nums.length);</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        int[] res = new int[2];</span><br><span class="line">        int left = 0, right = nums.length - 1;</span><br><span class="line">        while (left &lt; right) &#123;</span><br><span class="line">            int sum = nums[left] + nums[right];</span><br><span class="line">            if (sum == target) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125; else if (sum &lt; target) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 这里nums[left] + nums[right] 已经等于 target 但是不能直接返回 left，right 因为我们将数组排过序</span><br><span class="line">        // 查找left</span><br><span class="line">        for (int i = 0; i &lt; tempArr.length; ++i) &#123;</span><br><span class="line">            if (tempArr[i] == nums[left]) &#123;</span><br><span class="line">                res[0] = i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 查找right</span><br><span class="line">        for (int i = tempArr.length-1; i&gt;=0; --i) &#123;</span><br><span class="line">            if (tempArr[i] == nums[right]) &#123;</span><br><span class="line">                res[1] = i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果left &gt; right 交换</span><br><span class="line">        if (res[0] &gt; res[1])&#123;</span><br><span class="line">            int t = res[0];</span><br><span class="line">            res[0] = res[1];</span><br><span class="line">            res[1] = t;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] nums = &#123;-1, -2, -3, -4, -5&#125;;</span><br><span class="line">        int target = -8;</span><br><span class="line">        System.out.println(Arrays.toString(new Solution1().twoSum(nums, target)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法2：二分搜索"><a href="#方法2：二分搜索" class="headerlink" title="方法2：二分搜索"></a>方法2：二分搜索</h2><p><strong><code>基本思路：</code></strong> 先将数组排序，遍历数组，当前指向元素left，如果用二分搜索法在[left, right]中发现target-nums[left]存在说明找到了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line">public class Solution2 &#123;</span><br><span class="line">    // 二分搜索非递归</span><br><span class="line">    public int BinarySearch1(int[] nums, int left, int right, int target) &#123;</span><br><span class="line">        while (left &lt;= right) &#123;</span><br><span class="line">            int mid = left + (right - left) / 2;</span><br><span class="line">            if (nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + 1;</span><br><span class="line">            &#125; else if (nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;      // 没找到：-1</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 二分搜索递归</span><br><span class="line">    public int BinarySearch2(int[] nums, int left, int right, int target) &#123;</span><br><span class="line">        if (left &gt; right) &#123;</span><br><span class="line">            return -1;  // 没找到</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int mid = left + (right - left) / 2;</span><br><span class="line">        if (nums[mid] &lt; target)&#123;</span><br><span class="line">            return BinarySearch2(nums, mid + 1, right, target);</span><br><span class="line">        &#125;else if (nums[mid] &gt; target)&#123;</span><br><span class="line">            return BinarySearch2(nums, left, mid - 1, target);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 时间复杂度O(Nlog2^N)</span><br><span class="line">    public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">        int[] tempArr = Arrays.copyOf(nums, nums.length);</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        int[] res = new int[2];</span><br><span class="line"></span><br><span class="line">        int left = 0, right = 0;</span><br><span class="line">        for (; left &lt; nums.length; ++left) &#123;</span><br><span class="line">            right = BinarySearch1(nums, left + 1, nums.length - 1, target - nums[left]);</span><br><span class="line">            if (right != -1) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for (int i = 0; i &lt; tempArr.length; ++i) &#123;</span><br><span class="line">            if (tempArr[i] == nums[left]) &#123;</span><br><span class="line">                res[0] = i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = tempArr.length - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">            if (tempArr[i] == nums[right]) &#123;</span><br><span class="line">                res[1] = i;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (res[0] &gt; res[1]) &#123;</span><br><span class="line">            int t = res[0];</span><br><span class="line">            res[0] = res[1];</span><br><span class="line">            res[1] = t;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] nums = &#123;-1, -2, -3, -4, -5&#125;;</span><br><span class="line">        int target = -8;</span><br><span class="line">        System.out.println(Arrays.toString(new Solution2().twoSum(nums, target)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法3：-利用map-推荐"><a href="#方法3：-利用map-推荐" class="headerlink" title="方法3： 利用map (推荐)"></a>方法3： 利用map (推荐)</h2><p><strong><code>基本思路：</code></strong> 利用map，key存放元素的值 ，value存放元素的索引 ,遍历数组，当前指向元素索引为i，如果在数组中发现map的key中包含target - nums[i]，说明找到了.否则将该元素添加进map中，继续查找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class Solution3 &#123;</span><br><span class="line">    // 时间复杂度O(N)</span><br><span class="line">    public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">        int[] res = new int[2];</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        for (int i = 0; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            if (map.containsKey(target - nums[i])) &#123;</span><br><span class="line">                res[1] = i;</span><br><span class="line">                res[0] = map.get(target - nums[i]);</span><br><span class="line">                break;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                map.put(nums[i], i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] nums = &#123;3, 2, 4&#125;;</span><br><span class="line">        int target = 6;</span><br><span class="line">        System.out.println(Arrays.toString(new Solution3().twoSum(nums, target)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>pS:</code></strong> 在查找问题 而且数组有序 要想到 二分和双指针<br><a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/1.%20Two%20Sum" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> java实现 </tag>
            
            <tag> map </tag>
            
            <tag> 二分搜索 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 451. Sort Characters By Frequency</title>
      <link href="/2018/09/05/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-451-Sort-Characters-By-Frequency/"/>
      <url>/2018/09/05/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-451-Sort-Characters-By-Frequency/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="451"><li>Sort Characters By Frequency:<a href="https://leetcode.com/problems/sort-characters-by-frequency/description/" target="_blank" rel="noopener">题目链接</a></li></ol><p><strong><code>图解思路：</code></strong></p><div align="center" style="zoom: 70%; margin:  0px auto;"><img src="/2018/09/05/LeetCode解题/01-Array/leetcode-451-Sort-Characters-By-Frequency/leetcode_451_1.png" alt="原理"></div><h2 id="方法1：利用HashMap"><a href="#方法1：利用HashMap" class="headerlink" title="方法1：利用HashMap"></a>方法1：利用HashMap</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class Solution1 &#123;</span><br><span class="line">    public String frequencySort(String s) &#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        int max = 0;</span><br><span class="line">        // 将s加入到map中 并记录次数</span><br><span class="line">        for (Character c : s.toCharArray()) &#123;</span><br><span class="line">            map.put(c, map.getOrDefault(c, 0) + 1);</span><br><span class="line">            max = Math.max(max, map.get(c));</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Character&gt;[] lists = new List[max + 1];    // 建立链表数量(并不是指真正的链表)  体会+1  lists[0]并没有作用</span><br><span class="line">        // 遍历key  将剩余的元素链到对应位置</span><br><span class="line">        for (Character c : map.keySet()) &#123;</span><br><span class="line">            int index = map.get(c);                     // 链表下标 也对应的是该字母出现的个数</span><br><span class="line">            while (map.get(c) &gt; 0) &#123;</span><br><span class="line">                if (lists[index] == null) &#123;</span><br><span class="line">                    lists[index] = new ArrayList&lt;&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">                lists[index].add(c);</span><br><span class="line">                map.put(c, map.get(c) - 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringBuffer res = new StringBuffer();          // 将答案放在res中</span><br><span class="line">        // 从lists[max] 开始往 lists[1] 遍历 (1-max中可能出现k，使得lists[k] =null 比如本例中lists[3] = null)</span><br><span class="line">        // lists的索引是该字母出现的次数</span><br><span class="line">        for (int i = max; i &gt; 0; --i) &#123;</span><br><span class="line">            if (lists[i] != null) &#123;</span><br><span class="line">                for (int j = 0; j &lt; lists[i].size(); ++j) &#123;</span><br><span class="line">                    res.append(lists[i].get(j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String s = &quot;aaabcc&quot;;</span><br><span class="line">        System.out.println(new Solution1().frequencySort(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法2：利用Hash-Table"><a href="#方法2：利用Hash-Table" class="headerlink" title="方法2：利用Hash Table"></a>方法2：利用Hash Table</h2><p>写法跟利用HashMap的一样，只是利用的是哈希表(数组)</p><p><strong><code>int[26]</code></strong> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for Letters <strong><code>&#39;a&#39; - &#39;z&#39;</code></strong> or <strong><code>&#39;A&#39; - &#39;Z&#39;</code></strong><br><strong><code>int[128]</code></strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for <strong><code>ASCII</code></strong><br><strong><code>int[256]</code></strong> &nbsp;&nbsp;&nbsp;&nbsp;  for <strong><code>Extended ASCII</code></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class Solution2 &#123;</span><br><span class="line">    public String frequencySort(String s) &#123;</span><br><span class="line">        int[] hash = new int[256];</span><br><span class="line">        int max = 0;</span><br><span class="line">        for (Character c : s.toCharArray()) &#123;</span><br><span class="line">            hash[c]++;</span><br><span class="line">            max = Math.max(max, hash[c]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Character&gt;[] buckets = new List[max + 1];</span><br><span class="line">        for (int i = 0; i &lt; hash.length; ++i) &#123;</span><br><span class="line">            int index = hash[i];</span><br><span class="line">            while (hash[i] &gt; 0) &#123;</span><br><span class="line">                if (buckets[index] == null) &#123;</span><br><span class="line">                    buckets[index] = new ArrayList&lt;&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">                buckets[index].add((char) i);</span><br><span class="line">                hash[i]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringBuffer res = new StringBuffer();</span><br><span class="line">        for (int i = max; i &gt; 0; --i) &#123;</span><br><span class="line">            if (buckets[i] != null) &#123;</span><br><span class="line">                for (int j = 0; j &lt; buckets[i].size(); ++j) &#123;</span><br><span class="line">                    res.append(buckets[i].get(j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res.toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String s = &quot;aaaabcc&quot;;</span><br><span class="line">        System.out.println(new Solution2().frequencySort(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/451.%20Sort%20Characters%20By%20Frequency" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java实现 </tag>
            
            <tag> map </tag>
            
            <tag> Hash Table </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 205. Isomorphic Strings</title>
      <link href="/2018/09/05/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-205-Isomorphic-Strings/"/>
      <url>/2018/09/05/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-205-Isomorphic-Strings/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="205"><li>Isomorphic Strings:<a href="https://leetcode.com/problems/isomorphic-strings/description/" target="_blank" rel="noopener">题目链接</a></li></ol><h2 id="方法1：map"><a href="#方法1：map" class="headerlink" title="方法1：map"></a>方法1：map</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class Solution1 &#123;</span><br><span class="line">    // 时间复杂度O(N)</span><br><span class="line">    public boolean isIsomorphic(String s, String t) &#123;</span><br><span class="line">        Map&lt;Character, Character&gt; map = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        if (s.length() != t.length()) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            char chs = s.charAt(i);</span><br><span class="line">            char cht = t.charAt(i);</span><br><span class="line"></span><br><span class="line">            if (map.containsKey(chs)) &#123;</span><br><span class="line">                if (!map.get(chs).equals(cht)) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (map.containsValue(cht))&#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">                map.put(chs, cht);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String s = &quot;egg&quot;;</span><br><span class="line">        String t = &quot;add&quot;;</span><br><span class="line">        System.out.println(new Solution1().isIsomorphic(s, t));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/205.%20Isomorphic%20Strings" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java实现 </tag>
            
            <tag> map </tag>
            
            <tag> Hash Table </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 290. Word Pattern</title>
      <link href="/2018/09/04/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-290-Word-Pattern/"/>
      <url>/2018/09/04/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-290-Word-Pattern/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="290"><li>Word Pattern:<a href="https://leetcode.com/problems/word-pattern/description/" target="_blank" rel="noopener">题目链接</a></li></ol><h2 id="方法1：HashMap"><a href="#方法1：HashMap" class="headerlink" title="方法1：HashMap"></a>方法1：HashMap</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class Solution1 &#123;</span><br><span class="line">    public boolean wordPattern(String pattern, String str) &#123;</span><br><span class="line">        Map&lt;Character, String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        String[] res = str.split(&quot; &quot;);</span><br><span class="line"></span><br><span class="line">        if (pattern.length() != res.length)&#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i=0;i&lt;pattern.length();++i) &#123;</span><br><span class="line">            if (map.containsKey(pattern.charAt(i)))&#123;</span><br><span class="line">                if (!map.get(pattern.charAt(i)).equals(res[i])) &#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                if (map.containsValue(res[i]))&#123;</span><br><span class="line">                    return false;</span><br><span class="line">                &#125;</span><br><span class="line">                map.put(pattern.charAt(i), res[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String pattern = &quot;abba&quot;;</span><br><span class="line">        String str = &quot;dog cat cat dog&quot;;</span><br><span class="line">        System.out.println(new Solution1().wordPattern(pattern, str));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/290.%20Word%20Pattern" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java实现 </tag>
            
            <tag> map </tag>
            
            <tag> Hash Table </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 202. Happy Number</title>
      <link href="/2018/09/04/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-202-Happy-Number/"/>
      <url>/2018/09/04/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-202-Happy-Number/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="202"><li>Happy Number:<a href="https://leetcode.com/problems/happy-number/description/" target="_blank" rel="noopener">题目链接</a></li></ol><h2 id="方法1：利用HashSet"><a href="#方法1：利用HashSet" class="headerlink" title="方法1：利用HashSet"></a>方法1：利用HashSet</h2><p><strong><code>基本思路：</code></strong>首先这个题目是要将数字的每一位分离出来，用sum记录此次该数每个数字的平方和是多少，如果该数重复出现及sum重复，说明肯定不是happy number，用HashSet来记录sum</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class Solution1 &#123;</span><br><span class="line">    // 时间复杂度 O(N^2)  空间复杂度(m)  m:set的大小</span><br><span class="line">    public boolean isHappy(int n) &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = new HashSet&lt;&gt;();       // 记录sum</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            int sum = 0;</span><br><span class="line">            // 分离数位</span><br><span class="line">            while (n &gt; 0) &#123;</span><br><span class="line">                int k = n % 10;</span><br><span class="line">                sum += Math.pow(k, 2);</span><br><span class="line">                n /= 10;</span><br><span class="line">            &#125;</span><br><span class="line">            n = sum;</span><br><span class="line">            // 如果sum == 1 说明是happy number</span><br><span class="line">            if (sum == 1)&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果set包含sum 说明不是</span><br><span class="line">            if (set.contains(sum))&#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;else&#123;  // set不含sum 添加进set 继续</span><br><span class="line">                set.add(sum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int n = 19;</span><br><span class="line">        System.out.println(new Solution1().isHappy(n));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/202.%20Happy%20Number" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java实现 </tag>
            
            <tag> Hash Table </tag>
            
            <tag> set </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 242. Valid Anagram</title>
      <link href="/2018/09/02/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-242-Valid-Anagram/"/>
      <url>/2018/09/02/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-242-Valid-Anagram/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="242"><li>Valid Anagram:<a href="https://leetcode.com/problems/valid-anagram/solution/" target="_blank" rel="noopener">题目链接</a></li></ol><h2 id="方法1：hash-table"><a href="#方法1：hash-table" class="headerlink" title="方法1：hash table"></a>方法1：hash table</h2><p>利用一个哈希表来记录字符串中对应字符出现的频率</p><p><strong><code>int[26]</code></strong> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for Letters <strong><code>&#39;a&#39; - &#39;z&#39;</code></strong> or <strong><code>&#39;A&#39; - &#39;Z&#39;</code></strong><br><strong><code>int[128]</code></strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for <strong><code>ASCII</code></strong><br><strong><code>int[256]</code></strong> &nbsp;&nbsp;&nbsp;&nbsp;  for <strong><code>Extended ASCII</code></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class Solution1 &#123;</span><br><span class="line">    // 时间复杂度O(N)</span><br><span class="line">    public boolean isAnagram(String s, String t) &#123;</span><br><span class="line">        int[] hash = new int[256];      //来存放该字符出现的频率</span><br><span class="line">        // 统计t中字符出现的频率  hash[&apos;a&apos;] = hash[97]</span><br><span class="line">        for (char ch : t.toCharArray()) &#123;</span><br><span class="line">            hash[ch]++;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果两者长度不相等 说明肯定不是</span><br><span class="line">        if (s.length() != t.length()) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        // 遍历s</span><br><span class="line">        for (int i = 0; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            if (hash[s.charAt(i)] &gt; 0) &#123;     // s.charAt(i)当前出现频率 &gt; 0 说明s中与t都有该字符</span><br><span class="line">                hash[s.charAt(i)]--;         // 对应频率减1</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String s = &quot;anagram&quot;;</span><br><span class="line">        String t = &quot;nagaram&quot;;</span><br><span class="line">        System.out.println(new Solution1().isAnagram(s, t));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法2："><a href="#方法2：" class="headerlink" title="方法2："></a>方法2：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line">public class Solution2 &#123;</span><br><span class="line">    public boolean isAnagram(String s, String t) &#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        for (char ch : t.toCharArray()) &#123;</span><br><span class="line">            map.put(ch, map.getOrDefault(ch, 0) + 1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (s.length() != t.length()) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            if (map.containsKey(s.charAt(i)) &amp;&amp; map.get(s.charAt(i)) &gt; 0) &#123;</span><br><span class="line">                map.put(s.charAt(i), map.get(s.charAt(i)) - 1);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String s = &quot;anagram&quot;;</span><br><span class="line">        String t = &quot;nagaram&quot;;</span><br><span class="line">        System.out.println(new Solution1().isAnagram(s, t));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/242.%20Valid%20Anagram" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java实现 </tag>
            
            <tag> map </tag>
            
            <tag> Hash Table </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>备份win10系统</title>
      <link href="/2018/09/01/%E5%A4%87%E4%BB%BDwin10%E7%B3%BB%E7%BB%9F/"/>
      <url>/2018/09/01/%E5%A4%87%E4%BB%BDwin10%E7%B3%BB%E7%BB%9F/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>本文将介绍如何冷备份当前状态的windows系统(就是备份你目前所使用的windows系统，比如你现在安装了很多软件，可以完美的备份，并还原你备份时系统的状态，我是win10的)<a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="备份win10"><a href="#备份win10" class="headerlink" title="备份win10"></a>备份win10</h2><ol><li>找到 更新和安全 -&gt; 恢复 -&gt; 立即重新启动 -&gt; 疑难解答 -&gt; 高级选项 -&gt; 命令提示符</li><li>开始用dism 命令备份</li><li>初始备份（例如：把C分区的系统备份到E分区的根目录中，备份文件名为 Win10.wim）：<blockquote><p>Dism /Capture-Image /ImageFile:E:\Win10.wim /CaptureDir:C:\ /Name:Win10 </p></blockquote></li><li>增量备份（例如：把 C 分区的系统增量备份到 E:\Win10.wim 中）也就是在之前备份的基础上，在备份当前win10的状态：<blockquote><p> Dism /Append-Image /ImageFile:E:\Win10.wim /CaptureDir:C:\ /Name:Win10</p></blockquote><h2 id="恢复备份"><a href="#恢复备份" class="headerlink" title="恢复备份"></a>恢复备份</h2></li><li>找到 更新和安全 -&gt; 恢复 -&gt; 立即重新启动 -&gt; 疑难解答 -&gt; 高级选项 -&gt; 命令提示符</li><li>使用diskpart命令 格式化C盘</li><li>键入 Diskpart 进入 Diskpart 的命令环境，其提示符为 DISKPART&gt;。</li><li>输入 list volume   // 显示所有卷</li><li>输入 select volume 卷号(我的是6) </li><li>输入 format quick 格式化</li><li>exit 退出diskpart</li><li>执行Dism /Apply-Image /ImageFile:E:\Win10.wim /Index:2 /ApplyDir:C:\</li></ol><p><a href="https://answers.microsoft.com/zh-hans/windows/forum/windows_10-update/%E7%94%A8-dism/a3ea0d10-036c-41ff-8bb9-350c2bda525b" target="_blank" rel="noopener">帮助连接</a></p></the>]]></content>
      
      <categories>
          
          <category> windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 备份 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 350. Intersection of Two Arrays II</title>
      <link href="/2018/09/01/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-350-Intersection-of-Two-Arrays-II/"/>
      <url>/2018/09/01/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-350-Intersection-of-Two-Arrays-II/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="350"><li>Intersection of Two Arrays II:<a href="https://leetcode.com/problems/intersection-of-two-arrays-ii/description/" target="_blank" rel="noopener">题目链接</a></li></ol><h2 id="方法1：利用map"><a href="#方法1：利用map" class="headerlink" title="方法1：利用map"></a>方法1：利用map</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class Solution1 &#123;</span><br><span class="line">    // 时间复杂度O(N)   利用map 跟个数有关</span><br><span class="line">    public int[] intersection(int[] nums1, int[] nums2) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); // 用来存放 nums2</span><br><span class="line">        for (int x:nums2)&#123;                           // 将nums2添加到map</span><br><span class="line">            map.put(x, map.getOrDefault(x, 0) + 1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        // 遍历nums1 看map中是否含有此元素</span><br><span class="line">        for (int i =0; i&lt;nums1.length; ++i) &#123;</span><br><span class="line">            if (map.containsKey(nums1[i]) &amp;&amp; map.get(nums1[i]) &gt; 0) &#123;</span><br><span class="line">                list.add(nums1[i]);</span><br><span class="line">                map.put(nums1[i], map.get(nums1[i]) - 1);    // 该元素对应次数-1</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 将list转为数组</span><br><span class="line">        int[] res = new int[list.size()];</span><br><span class="line">        int index = 0;</span><br><span class="line">        for (int x: list)&#123;</span><br><span class="line">            res[index++] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] nums1 = &#123;1, 2, 2, 1&#125;;</span><br><span class="line">        int[] nums2 = &#123;2, 2&#125;;</span><br><span class="line">        int[] res = (new Solution1()).intersection(nums1, nums2);</span><br><span class="line">        System.out.println(Arrays.toString(res));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法2-双指针"><a href="#方法2-双指针" class="headerlink" title="方法2:双指针"></a>方法2:双指针</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class Solution2 &#123;</span><br><span class="line">    // 时间复杂度O(nlog2^n)   双指针</span><br><span class="line">    public int[] intersection(int[] nums1, int[] nums2) &#123;</span><br><span class="line">        // 先对两个数组 进行排序</span><br><span class="line">        Arrays.sort(nums1);</span><br><span class="line">        Arrays.sort(nums2);</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();  // 存放答案</span><br><span class="line">        int i = 0, j = 0;</span><br><span class="line">        while (i &lt; nums1.length &amp;&amp; j &lt; nums2.length) &#123;</span><br><span class="line">            if (nums1[i] == nums2[j]) &#123;</span><br><span class="line">                list.add(nums1[i]);</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; else if (nums1[i] &lt; nums2[j]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 将set转为数组</span><br><span class="line">        int[] res = new int[list.size()];</span><br><span class="line">        int index = 0;</span><br><span class="line">        for (Integer x : list) &#123;</span><br><span class="line">            res[index++] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] nums1 = &#123;1, 2, 2, 1&#125;;</span><br><span class="line">        int[] nums2 = &#123;2, 2&#125;;</span><br><span class="line">        int[] res = (new Solution1()).intersection(nums1, nums2);</span><br><span class="line">        System.out.println(Arrays.toString(res));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/349.%20Intersection%20of%20Two%20Arrays" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> java实现 </tag>
            
            <tag> map </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 349. Intersection of Two Arrays</title>
      <link href="/2018/08/31/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-349-Intersection-of-Two-Arrays/"/>
      <url>/2018/08/31/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-349-Intersection-of-Two-Arrays/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="349"><li>Intersection of Two Arrays:<a href="https://leetcode.com/problems/intersection-of-two-arrays/description/" target="_blank" rel="noopener">题目链接</a></li></ol><h2 id="方法1-利用set"><a href="#方法1-利用set" class="headerlink" title="方法1:利用set"></a>方法1:利用set</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class Solution1 &#123;</span><br><span class="line">    // 时间复杂度O(N)  空间复杂度O(N):两个set+res[]</span><br><span class="line">    public int[] intersection(int[] nums1, int[] nums2) &#123;</span><br><span class="line">        Set&lt;Integer&gt; set = new HashSet&lt;&gt;();        // 用来存放 nums2</span><br><span class="line">        for (int x:nums2)&#123;                         // 将nums2添加到set(此时nums2的重复元素被过滤)</span><br><span class="line">            set.add(x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;Integer&gt; resultSet = new HashSet&lt;&gt;();  // 存放两数组之间的公共元素(重复的会被过滤)</span><br><span class="line">        // 遍历nums1 看set中是否含有此元素</span><br><span class="line">        for (int i =0; i&lt;nums1.length; ++i) &#123;</span><br><span class="line">            if (set.contains(nums1[i])) &#123;</span><br><span class="line">                resultSet.add(nums1[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 将resultSet转为数组</span><br><span class="line">        int[] res = new int[resultSet.size()];</span><br><span class="line">        int index = 0;</span><br><span class="line">        for (int x: resultSet)&#123;</span><br><span class="line">            res[index++] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] nums1 = &#123;1, 2, 2, 1&#125;;</span><br><span class="line">        int[] nums2 = &#123;2, 2&#125;;</span><br><span class="line">        int[] res = (new Solution1()).intersection(nums1, nums2);</span><br><span class="line">        System.out.println(Arrays.toString(res));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法2：双指针"><a href="#方法2：双指针" class="headerlink" title="方法2：双指针"></a>方法2：双指针</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class Solution2 &#123;</span><br><span class="line">    // 时间复杂度O(nlog2^n)   双指针</span><br><span class="line">    public int[] intersection(int[] nums1, int[] nums2) &#123;</span><br><span class="line">        // 先对两个数组 进行排序</span><br><span class="line">        Arrays.sort(nums1);</span><br><span class="line">        Arrays.sort(nums2);</span><br><span class="line"></span><br><span class="line">        Set&lt;Integer&gt; set = new HashSet&lt;&gt;(); // 存放答案(会过滤掉重复的元素)</span><br><span class="line">        int i = 0, j = 0;</span><br><span class="line">        while (i &lt; nums1.length &amp;&amp; j &lt; nums2.length) &#123;</span><br><span class="line">            if (nums1[i] == nums2[j]) &#123;</span><br><span class="line">                set.add(nums1[i]);</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; else if (nums1[i] &lt; nums2[j]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 将set转为数组</span><br><span class="line">        int[] res = new int[set.size()];</span><br><span class="line">        int index = 0;</span><br><span class="line">        for (Integer x : set) &#123;</span><br><span class="line">            res[index++] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] nums1 = &#123;1, 2, 2, 1&#125;;</span><br><span class="line">        int[] nums2 = &#123;2, 2&#125;;</span><br><span class="line">        int[] res = (new Solution1()).intersection(nums1, nums2);</span><br><span class="line">        System.out.println(Arrays.toString(res));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/349.%20Intersection%20of%20Two%20Arrays" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> java实现 </tag>
            
            <tag> set </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>双指针总结篇</title>
      <link href="/2018/08/31/%E5%8F%8C%E6%8C%87%E9%92%88%E6%80%BB%E7%BB%93%E7%AF%87/"/>
      <url>/2018/08/31/%E5%8F%8C%E6%8C%87%E9%92%88%E6%80%BB%E7%BB%93%E7%AF%87/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>双指针这种思想对于解决数组类问题是很重要的，一般来讲可以将时间复杂度控制在<strong><code>O(N)</code></strong>,我将其分为三类，<font color="red">双指针之快慢指针、双指针之对撞指针、双指针之滑动窗口</font>。注意这里的指针并不是c语言里面的指针，而是<font color="deeppink">数组下标(索引)</font><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><h2 id="双指针之快慢指针"><a href="#双指针之快慢指针" class="headerlink" title="双指针之快慢指针"></a>双指针之快慢指针</h2><p><strong><code>基本思想：</code></strong>快指针fast,慢指针slow都指向数组第一个元素，其中fast用来遍历整个数组，一旦fast发现满足条件的元素,就与slow指向元素进行某种操作(交换，赋值等等)，slow往后移动，直至快指针fast遍历完整个数组,时间复杂度O(N) </p><p><strong><code>应用场景：</code></strong></p><ol><li>in place (原地解决问题 不需要额外的空间)</li><li>在数组中寻找特定的元素(大于等于小于target,或在某个范围内等等)，将其放到[0,slow)这个左闭右开的区间</li><li>在数组<font color="red">有序</font>的状态 对数组进行去重(去重复元素,不需要额外的空间)</li><li>待补充</li></ol><table><thead><tr><th style="text-align:left">题目</th><th style="text-align:center">类型</th><th style="text-align:left">题目链接</th><th style="text-align:center">详细解答</th></tr></thead><tbody><tr><td style="text-align:left">283.Move Zeroes</td><td style="text-align:center">双指针之快慢指针</td><td style="text-align:left"><a href="https://leetcode.com/problems/move-zeroes/description/" target="_blank" rel="noopener">点击这里</a></td><td style="text-align:center"><a href="https://xerdemo.github.io/2018/08/13/LeetCode%E8%A7%A3%E9%A2%98/leetcode-283-Move-Zeroes/">点击这里</a></td></tr><tr><td style="text-align:left">27.Remove Element</td><td style="text-align:center">双指针之快慢指针</td><td style="text-align:left"><a href="https://leetcode.com/problems/remove-element/description/" target="_blank" rel="noopener">点击这里</a></td><td style="text-align:center"><a href="https://xerdemo.github.io/2018/08/14/LeetCode%E8%A7%A3%E9%A2%98/leetcode-27-Remove-Element/">点击这里</a></td></tr><tr><td style="text-align:left">26.Remove Duplicates from Sorted Array</td><td style="text-align:center">双指针之快慢指针</td><td style="text-align:left"><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/" target="_blank" rel="noopener">点击这里</a></td><td style="text-align:center"><a href="https://xerdemo.github.io/2018/08/14/LeetCode%E8%A7%A3%E9%A2%98/leetcode-26-Remove-Duplicates-from-Sorted-Array/">点击这里</a></td></tr><tr><td style="text-align:left">80.Remove Duplicates from Sorted Array II</td><td style="text-align:center">双指针之快慢指针</td><td style="text-align:left"><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/description/" target="_blank" rel="noopener">点击这里</a></td><td style="text-align:center"><a href="https://xerdemo.github.io/2018/08/14/LeetCode%E8%A7%A3%E9%A2%98/leetcode-80-Remove-Duplicates-from-Sorted-Array-II/">点击这里</a></td></tr></tbody></table><h2 id="双指针之对撞指针"><a href="#双指针之对撞指针" class="headerlink" title="双指针之对撞指针"></a>双指针之对撞指针</h2><p><strong><code>基本思想：</code></strong> 两个指针i，j，i指向数组最左边,j指向数组最右边，i从左往右遍历，j从右往左遍历，当满足某某条件时，进行某某操作，直至两者相遇,时间复杂度<strong><code>O(N)</code></strong></p><p><strong><code>应用场景：</code></strong></p><ol><li>判断一个字符串是否对称、回文数,翻转字符串(也可以交换特定位置的字符)</li><li>数组有序的状态，看哪两数相加，减等等，其结果是否大于等于小于target（N sum类问题）</li><li>二路快速排序</li><li>待补充</li></ol><table><thead><tr><th style="text-align:left">题目</th><th style="text-align:center">类型</th><th style="text-align:left">题目链接</th><th style="text-align:center">详细解答</th></tr></thead><tbody><tr><td style="text-align:left">167. Two Sum II - Input array is sorted</td><td style="text-align:center">双指针之对撞指针</td><td style="text-align:left"><a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/" target="_blank" rel="noopener">点击这里</a></td><td style="text-align:center"><a href="https://xerdemo.github.io/2018/08/19/LeetCode%E8%A7%A3%E9%A2%98/leetcode-167-Two-Sum-II-Input-array-is-sorted/">点击这里</a></td></tr><tr><td style="text-align:left">125. Valid Palindrome</td><td style="text-align:center">双指针之对撞指针</td><td style="text-align:left"><a href="https://leetcode.com/problems/valid-palindrome/description/" target="_blank" rel="noopener">点击这里</a></td><td style="text-align:center"><a href="https://xerdemo.github.io/2018/08/19/leetcode-125-Valid-Palindrome/">点击这里</a></td></tr><tr><td style="text-align:left">344. Reverse String</td><td style="text-align:center">双指针之对撞指针</td><td style="text-align:left"><a href="https://leetcode.com/problems/reverse-string/description/" target="_blank" rel="noopener">点击这里</a></td><td style="text-align:center"><a href="https://xerdemo.github.io/2018/08/20/leetcode-344-Reverse-String/">点击这里</a></td></tr><tr><td style="text-align:left">345. Reverse Vowels of a String</td><td style="text-align:center">双指针之对撞指针</td><td style="text-align:left"><a href="https://leetcode.com/problems/reverse-vowels-of-a-string/description/" target="_blank" rel="noopener">点击这里</a></td><td style="text-align:center"><a href="https://xerdemo.github.io/2018/08/21/leetcode-345-Reverse-Vowels-of-a-String/">点击这里</a></td></tr><tr><td style="text-align:left">11. Container With Most Water</td><td style="text-align:center">双指针之对撞指针</td><td style="text-align:left"><a href="https://leetcode.com/problems/container-with-most-water/description/" target="_blank" rel="noopener">点击这里</a></td><td style="text-align:center"><a href="https://xerdemo.github.io/2018/08/21/leetcode-11-Container-With-Most-Water/">点击这里</a></td></tr></tbody></table><h2 id="双指针之滑动窗口"><a href="#双指针之滑动窗口" class="headerlink" title="双指针之滑动窗口"></a>双指针之滑动窗口</h2><p><strong><code>基本思想：</code></strong>初始时指针left，right都指向数组第一个元素,维持[left,right)这个窗口，                </p><table><thead><tr><th style="text-align:left">题目</th><th style="text-align:center">类型</th><th style="text-align:left">题目链接</th><th style="text-align:center">详细解答</th></tr></thead><tbody><tr><td style="text-align:left">209. Minimum Size Subarray Sum</td><td style="text-align:center">双指针之滑动窗口</td><td style="text-align:left"><a href="https://leetcode.com/problems/minimum-size-subarray-sum/description/" target="_blank" rel="noopener">点击这里</a></td><td style="text-align:center"><a href="https://xerdemo.github.io/2018/08/21/leetcode-209-Minimum-Size-Subarray-Sum/">点击这里</a></td></tr><tr><td style="text-align:left">3. Longest Substring Without Repeating Characters</td><td style="text-align:center">双指针之滑动窗口</td><td style="text-align:left"><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/description/" target="_blank" rel="noopener">点击这里</a></td><td style="text-align:center"><a href="https://xerdemo.github.io/2018/08/22/leetcode-3-Longest-Substring-Without-Repeating-Characters/">点击这里</a></td></tr><tr><td style="text-align:left">438. Find All Anagrams in a String</td><td style="text-align:center">双指针之滑动窗口</td><td style="text-align:left"><a href="https://leetcode.com/problems/find-all-anagrams-in-a-string/description/" target="_blank" rel="noopener">点击这里</a></td><td style="text-align:center"><a href="https://xerdemo.github.io/2018/08/24/leetcode-438-Find-All-Anagrams-in-a-String/">点击这里</a></td></tr><tr><td style="text-align:left">76. Minimum Window Substring</td><td style="text-align:center">双指针之滑动窗口</td><td style="text-align:left"><a href="https://leetcode.com/problems/minimum-window-substring/description/" target="_blank" rel="noopener">点击这里</a></td><td style="text-align:center"><a href="https://xerdemo.github.io/2018/08/25/leetcode-76-Minimum-Window-Substring/">点击这里</a></td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>跟数组有关的时候 并且是查找类型 要想到双指针和二分法</p>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
            <tag> java实现 </tag>
            
            <tag> 数组问题 </tag>
            
            <tag> Thinking </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 76 Minimum Window Substring</title>
      <link href="/2018/08/25/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-76-Minimum-Window-Substring/"/>
      <url>/2018/08/25/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-76-Minimum-Window-Substring/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="76"><li>Minimum Window Substring:<a href="https://leetcode.com/problems/minimum-window-substring/description/" target="_blank" rel="noopener">题目链接</a></li></ol><h2 id="方法1：双指针之滑动窗口"><a href="#方法1：双指针之滑动窗口" class="headerlink" title="方法1：双指针之滑动窗口"></a>方法1：双指针之滑动窗口</h2><blockquote><p>有一个关于此类问题的模板链接:<a href="https://leetcode.com/problems/minimum-window-substring/discuss/26808/Here-is-a-10-line-template-that-can-solve-most-&#39;substring&#39;-problems" target="_blank" rel="noopener">点击这里</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">public class Solution1 &#123;</span><br><span class="line">    // 时间复杂度O(N)   双指针之滑动窗口</span><br><span class="line">    public String minWindow(String s, String t) &#123;</span><br><span class="line">        int[] hash = new int[256];              // 建立哈希表  hash[&apos;a&apos;] 就是hash[97]</span><br><span class="line">        int left = 0, right = 0;                // [left,right)  滑动窗口区间为左闭右开区间</span><br><span class="line">        // 将t中字符出现的次数 加入hash[]</span><br><span class="line">        for (int i = 0; i &lt; t.length(); ++i) &#123;</span><br><span class="line">            hash[t.charAt(i)]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int minLength = Integer.MAX_VALUE;      // 当找到符合答案的滑动窗口时 记录其窗口长度</span><br><span class="line">        int minStart = 0;                       // 当找到符合答案的滑动窗口时 记录其起始位置</span><br><span class="line">        int count = 0;                          // 计数器</span><br><span class="line"></span><br><span class="line">        while (right &lt; s.length()) &#123;</span><br><span class="line">            // 不管if()里面条件是否满足  right指向的当前元素始终频率--（所以只要不是t中的元素出现的频率肯定是负数）  right++</span><br><span class="line">            // 如果right指向当前的元素频率&gt;=1 此元素也在t中  count++</span><br><span class="line">            if (hash[s.charAt(right++)]-- &gt;= 1) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // t中的元素全部找到后</span><br><span class="line">            while (count == t.length())&#123;</span><br><span class="line">                // 更新满足条件的最小滑动区间</span><br><span class="line">                if (right - left &lt; minLength)&#123;</span><br><span class="line">                    minLength = right - left;</span><br><span class="line">                    minStart = left;</span><br><span class="line">                &#125;</span><br><span class="line">                // 不管if()里面条件是否满足 left指向的当前元素始终频率++(不是t中的元素频率最多只能加到0,不会超过0)  left++</span><br><span class="line">                // 如果left指向当前的元素频率 = 0  此元素也在t中   count--</span><br><span class="line">                if (hash[s.charAt(left++)]++&gt;= 0)&#123;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        return minLength == Integer.MAX_VALUE ? &quot;&quot; : s.substring(minStart, minStart + minLength);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String s = &quot;ADOBECODEBANC&quot;;</span><br><span class="line">        String t = &quot;ABC&quot;;</span><br><span class="line">        System.out.println(new Solution1().minWindow(s, t));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/76.%20Minimum%20Window%20Substring" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java实现 </tag>
            
            <tag> 数组问题 </tag>
            
            <tag> 双指针之滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 438 Find All Anagrams in a String</title>
      <link href="/2018/08/24/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-438-Find-All-Anagrams-in-a-String/"/>
      <url>/2018/08/24/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-438-Find-All-Anagrams-in-a-String/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="438"><li>Find All Anagrams in a String:<a href="https://leetcode.com/problems/find-all-anagrams-in-a-string/description/" target="_blank" rel="noopener">题目链接</a></li></ol><h2 id="方法1：双指针之滑动窗口"><a href="#方法1：双指针之滑动窗口" class="headerlink" title="方法1：双指针之滑动窗口"></a>方法1：双指针之滑动窗口</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import java.util.ArrayList;</span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">public class Solution1 &#123;</span><br><span class="line">    // 时间复杂度O(N)</span><br><span class="line">    public List&lt;Integer&gt; findAnagrams(String s, String p) &#123;</span><br><span class="line">        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        int left = 0, right = 0;      // [left, right)  滑动窗口</span><br><span class="line">        int[] hash = new int[128];    // 声明哈希表  128：ASCII  256:扩展的ASCII</span><br><span class="line">        // hash中存放p中字符出现的次数</span><br><span class="line">        for (int i = 0; i&lt;p.length();++i) &#123;</span><br><span class="line">            hash[p.charAt(i)]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int count = 0;                // 计数器</span><br><span class="line">        while (right &lt; s.length()) &#123;</span><br><span class="line">            // 每次都将当前遍历的元素次数-1 ,那么不属于p里面的字符 出现的频率肯定是负数</span><br><span class="line">            // 当发现当前元素频率大于等于1 说明当前元素是p中的某一个  计数器++</span><br><span class="line">            if (hash[s.charAt(right++)]-- &gt;= 1) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果计数器等于p的长度 说明找到了符合条件的答案</span><br><span class="line">            if (count == p.length())&#123;</span><br><span class="line">                res.add(left);</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果发现left所在位置元素的频率&gt;=0 说明是p中的某个元素  (不是p中的元素在第一个if时 频率已经是复述了)</span><br><span class="line">            if (right -left == p.length() &amp;&amp; hash[s.charAt(left++)]++ &gt;= 0)&#123;</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String s = &quot;cbaebabacd&quot;;</span><br><span class="line">        String p = &quot;abc&quot;;</span><br><span class="line">        System.out.println(new Solution1().findAnagrams(s, p));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外一种用map的方法，但是效率不知道为什么非常低<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">public class Solution2 &#123;</span><br><span class="line"></span><br><span class="line">    public List&lt;Integer&gt; findAnagrams(String s, String p) &#123;</span><br><span class="line">        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        Map&lt;Character, Integer&gt; ms = new HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;Character, Integer&gt; mp = new HashMap&lt;&gt;();</span><br><span class="line">        Vector v = new Vector();</span><br><span class="line">        for (int i =0; i&lt;p.length();++i) &#123;</span><br><span class="line">            mp.put(p.charAt(i), mp.getOrDefault(p.charAt(i), 0) + 1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int left = 0, right = 0;</span><br><span class="line">        while (right &lt; s.length())&#123;</span><br><span class="line">            ms.put(s.charAt(right), ms.getOrDefault(s.charAt(right), 0) + 1);</span><br><span class="line">            right++;</span><br><span class="line">            if (right - left == p.length())&#123;</span><br><span class="line">                if (ms.equals(mp)) &#123;</span><br><span class="line">                    list.add(left);</span><br><span class="line">                &#125;</span><br><span class="line">                char ch = s.charAt(left);</span><br><span class="line">                if (ms.get(ch) &gt; 1)&#123;</span><br><span class="line">                    ms.put(ch, ms.get(ch)-1);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    ms.remove(ch);</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String s = &quot;cbaebabacd&quot;;</span><br><span class="line">        String p = &quot;abc&quot;;</span><br><span class="line">        System.out.println(new Solution2().findAnagrams(s, p));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/438.%20Find%20All%20Anagrams%20in%20a%20String" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java实现 </tag>
            
            <tag> 数组问题 </tag>
            
            <tag> 双指针之滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 3 Longest Substring Without Repeating Characters</title>
      <link href="/2018/08/22/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-3-Longest-Substring-Without-Repeating-Characters/"/>
      <url>/2018/08/22/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-3-Longest-Substring-Without-Repeating-Characters/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="3"><li>Longest Substring Without Repeating Characters:<a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/description/" target="_blank" rel="noopener">题目链接</a></li></ol><h2 id="方法1：暴力解法"><a href="#方法1：暴力解法" class="headerlink" title="方法1：暴力解法"></a>方法1：暴力解法</h2><p>利用hashset来判断在[i,j]区间内有无重复元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import java.util.HashSet;</span><br><span class="line">import java.util.Set;</span><br><span class="line"></span><br><span class="line">public class Solution1 &#123;</span><br><span class="line">    // 时间复杂度O(N^2)    空间复杂度O(set的大小*s的大小)</span><br><span class="line">    public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">        int res = Integer.MIN_VALUE;</span><br><span class="line">        for (int i = 0; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            // 创建hashset判断[i,j]之间是否有重复元素</span><br><span class="line">            Set&lt;Character&gt; set = new HashSet();</span><br><span class="line">            for (int j = i; j &lt; s.length(); ++j) &#123;</span><br><span class="line">                if (set.contains(s.charAt(j))) &#123;    // 如果有重复元素 终止当前循环 判断[i+1,j]之间是否有重复元素</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">                set.add(s.charAt(j));               // 如果set中不含当前元素 将当前元素添加进set中</span><br><span class="line">                res = Math.max(j - i + 1, res);     // 更新结果</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res == Integer.MIN_VALUE ? 0 : res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String s = &quot;abcabcbb&quot;;</span><br><span class="line">        System.out.println(new Solution1().lengthOfLongestSubstring(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="方法2：双指针之滑动窗口"><a href="#方法2：双指针之滑动窗口" class="headerlink" title="方法2：双指针之滑动窗口"></a>方法2：双指针之滑动窗口</h2><p>维持一个窗口<strong><code>[left,right)</code></strong>使这个窗口里面的<strong><code>元素不重复</code></strong><br><strong><code>基本思路:</code></strong>[left,right)中没有重复元素，<strong><code>right++</code></strong>,并将该元素对应出现的<strong><code>频率++</code></strong>,直到right对应元素的<strong><code>频率不为0</code></strong>(即在[left,right)中已有该元素)，记录此时在[left,right)区间元素的个数(选取最大值),<strong><code>left</code></strong>对应元素的<strong><code>频率--</code></strong>，并且<strong><code>left++</code></strong>，直到发现此时right对应元素的<strong><code>频率为0</code></strong>  </p><p><strong><code>初始时：</code></strong>left,right都指向第一个元素,此时a,b,c出现的频率都是0</p><div align="center" style="zoom: 70%; margin:  0px auto;"><img src="/2018/08/22/LeetCode解题/01-Array/leetcode-3-Longest-Substring-Without-Repeating-Characters/leetcode_3_1.png" alt="原理"></div><p><strong><code>当遇到重复元素时：</code></strong>如图所示，在right遍历的过程中,[left,right)这个左闭右开区间中，a,b,c出现的次数为 <strong><code>a:1 、b:1 、c:1</code></strong>,此时right指向的元素是a,检测发现a之前在[left,right)中出现过，故将left对应元素的频率- -，left++,此时<strong><code>a:0 、b:1 、c:1</code></strong>,发现right指向的元素频率为0了，right++,对应元素的频率++</p><div align="center" style="zoom: 70%; margin:  0px auto;"><img src="/2018/08/22/LeetCode解题/01-Array/leetcode-3-Longest-Substring-Without-Repeating-Characters/leetcode_3_2.png" alt="原理"></div><p><strong><code>利用HashMap实现：</code></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class Solution2 &#123;</span><br><span class="line">    // 时间复杂度O(N)  </span><br><span class="line">    public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">        int left = 0, right = 0;                        // [left,right):存放无重复元素</span><br><span class="line">        Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        int res = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">        while (right &lt; s.length()) &#123;</span><br><span class="line">            // 如果map中不含当前元素, 将当前元素添加进map,对应频率+1,并且right往后移</span><br><span class="line">            if (right &lt; s.length() &amp;&amp; !map.containsKey(s.charAt(right)))&#123;</span><br><span class="line">                map.put(s.charAt(right++), 1);</span><br><span class="line">            &#125;else&#123;  // 如果map中发现当前元素在[left,right)中已经出现过  将left对应元素频率--，left向后移动</span><br><span class="line">                map.remove(s.charAt(left++));</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res, right - left);   // 更新结果</span><br><span class="line">        &#125;</span><br><span class="line">        return res == Integer.MIN_VALUE ? 0 : res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String s = &quot;abcabcbb&quot;;</span><br><span class="line">        System.out.println(new Solution2().lengthOfLongestSubstring(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong><code>不用HashMap使用哈希表</code></strong>,即<strong><code>数组</code></strong>，解法跟用hashMap的一样，只是利用的是数组来记录频率</p><p><strong><code>int[26]</code></strong> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for Letters <strong><code>&#39;a&#39; - &#39;z&#39;</code></strong> or <strong><code>&#39;A&#39; - &#39;Z&#39;</code></strong><br><strong><code>int[128]</code></strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for <strong><code>ASCII</code></strong><br><strong><code>int[256]</code></strong> &nbsp;&nbsp;&nbsp;&nbsp;  for <strong><code>Extended ASCII</code></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Solution3 &#123;</span><br><span class="line">    // 时间复杂度O(N)  空间复杂度O(M) M:字符集的长度 即声明ascii数组大小</span><br><span class="line">    public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">        int left = 0, right = 0;         // [left,right)</span><br><span class="line">        int[] ascii = new int[256];</span><br><span class="line">        int res = Integer.MIN_VALUE;</span><br><span class="line">        while (right &lt; s.length()) &#123;</span><br><span class="line">            if (right &lt; s.length() &amp;&amp; ascii[s.charAt(right)] == 0) &#123;</span><br><span class="line">                ascii[s.charAt(right++)]++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                ascii[s.charAt(left++)]--;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.max(res, right - left);</span><br><span class="line">        &#125;</span><br><span class="line">        return res == Integer.MIN_VALUE ? 0 : res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String s = &quot;abcabcbb&quot;;</span><br><span class="line">        System.out.println(new Solution3().lengthOfLongestSubstring(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/3.%20Longest%20Substring%20Without%20Repeating%20Characters" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java实现 </tag>
            
            <tag> 数组问题 </tag>
            
            <tag> 双指针之滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 209 Minimum Size Subarray Sum</title>
      <link href="/2018/08/21/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-209-Minimum-Size-Subarray-Sum/"/>
      <url>/2018/08/21/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-209-Minimum-Size-Subarray-Sum/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="209"><li>Minimum Size Subarray Sum:<a href="https://leetcode.com/problems/minimum-size-subarray-sum/description/" target="_blank" rel="noopener">题目链接</a></li></ol><h2 id="方法1：暴力解法"><a href="#方法1：暴力解法" class="headerlink" title="方法1：暴力解法"></a>方法1：暴力解法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public class Solution1 &#123;</span><br><span class="line">    // 暴力破解 时间复杂度O(N^2)  空间复杂度O(1)</span><br><span class="line">    public int minSubArrayLen(int s, int[] nums) &#123;</span><br><span class="line">        int res = Integer.MAX_VALUE;</span><br><span class="line">        for (int i = 0; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            int sum = 0;</span><br><span class="line">            for (int j = i; j &lt; nums.length; ++j) &#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">                if (sum &gt;= s) &#123;</span><br><span class="line">                    res = Math.min(j - i + 1, res);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res == Integer.MAX_VALUE? 0 : res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] nums = &#123;2, 3, 1, 2, 4, 3&#125;;</span><br><span class="line">        int s = 7;</span><br><span class="line">        System.out.println(new Solution1().minSubArrayLen(s, nums));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法2：双指针之滑动窗口"><a href="#方法2：双指针之滑动窗口" class="headerlink" title="方法2：双指针之滑动窗口"></a>方法2：双指针之滑动窗口</h2><p><strong><code>基本思想：</code></strong>维护一个区间[left,right)，使得在这个区间里的和是小于ｓ的，如果加上一个数之后区间和大于等于ｓ了，那么就从区间左边开始删元素，并且边删边判断是不是和依然大于等于ｓ，更新结果．</p><div align="center" style="zoom: 75%; margin:  0px auto;"><img src="/2018/08/21/LeetCode解题/01-Array/leetcode-209-Minimum-Size-Subarray-Sum/leetcode 209_1.png" alt="原理"></div><p>如果<strong><code>sum &gt;= s</code></strong>,记录当前长度即<strong><code>right-left</code></strong>,然后删除[left,right)最左侧元素，left向右移,即<strong><code>sum -=nums[left++]</code></strong>，直到<strong><code>sum &lt; s</code></strong></p><p><strong><code>sum &gt;= s</code></strong></p><div align="center" style="zoom: 75%; margin:  0px auto;"><img src="/2018/08/21/LeetCode解题/01-Array/leetcode-209-Minimum-Size-Subarray-Sum/leetcode 209_2.png" alt="原理"></div><p><strong><code>sum &lt; s</code></strong></p><div align="center" style="zoom: 75%; margin:  0px auto;"><img src="/2018/08/21/LeetCode解题/01-Array/leetcode-209-Minimum-Size-Subarray-Sum/leetcode 209_3.png" alt="原理"></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class Solution2 &#123;</span><br><span class="line">    // 时间复杂度O(N)  空间复杂度O(1)  双指针之滑动窗口</span><br><span class="line">    public int minSubArrayLen(int s, int[] nums) &#123;</span><br><span class="line">        int left = 0, right = 0;       // [left, right) 左闭右开区间 </span><br><span class="line">        int sum = 0;</span><br><span class="line">        int res = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">        while (right &lt; nums.length) &#123;</span><br><span class="line">            sum += nums[right++];</span><br><span class="line">            while (sum &gt;= s)&#123;</span><br><span class="line">                res = Math.min(right - left, res);</span><br><span class="line">                sum -= nums[left++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res == Integer.MAX_VALUE ? 0 : res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] nums = &#123;2, 3, 1, 2, 4, 3&#125;;</span><br><span class="line">        int s = 7;</span><br><span class="line">        System.out.println(new Solution2().minSubArrayLen(s, nums));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/209.%20Minimum%20Size%20Subarray%20Sum" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java实现 </tag>
            
            <tag> 数组问题 </tag>
            
            <tag> 双指针之滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 11  Container With Most Water</title>
      <link href="/2018/08/21/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-11-Container-With-Most-Water/"/>
      <url>/2018/08/21/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-11-Container-With-Most-Water/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="11"><li>Container With Most Water:<a href="https://leetcode.com/problems/container-with-most-water/description/" target="_blank" rel="noopener">题目链接</a></li></ol><h2 id="方法1：暴力解法"><a href="#方法1：暴力解法" class="headerlink" title="方法1：暴力解法"></a>方法1：暴力解法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Solution1 &#123;</span><br><span class="line">    // 时间复杂度 O(N^2)   空间复杂度O(1)  暴力破解法</span><br><span class="line">    public int maxArea(int[] height) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        for (int i = 0; i &lt; height.length; ++i) &#123;</span><br><span class="line">            for (int j = i + 1; j &lt; height.length; ++j) &#123;</span><br><span class="line">                int area = (j - i) * (height[i] &lt; height[j] ? height[i] : height[j]);</span><br><span class="line">                if (area &gt; res)&#123;</span><br><span class="line">                    res = area;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] height = &#123;1, 8, 6, 2, 5, 4, 8, 3, 7&#125;;</span><br><span class="line">        System.out.println(new Solution1().maxArea(height));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法2：双指针之对撞指针"><a href="#方法2：双指针之对撞指针" class="headerlink" title="方法2：双指针之对撞指针"></a>方法2：双指针之对撞指针</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Solution2 &#123;</span><br><span class="line">    // 时间复杂度O(N)   空间复杂度O(1)   双指针之对撞指针</span><br><span class="line">    public int maxArea(int[] height) &#123;</span><br><span class="line">        int i = 0;</span><br><span class="line">        int j = height.length - 1;</span><br><span class="line">        int res = 0;</span><br><span class="line">        // 当i,j还未相遇</span><br><span class="line">        while (i &lt; j) &#123;</span><br><span class="line">            int area = (j - i) * Math.min(height[i], height[j]);  //  计算当前所围面积</span><br><span class="line">            if (height[i] &lt; height[j])&#123;                // 如果是height[i]小了 尝试i++</span><br><span class="line">                i++;</span><br><span class="line">            &#125;else &#123;                                    // 如果是height[j]小了 尝试j--</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            if (res &lt; area) &#123;</span><br><span class="line">                res = area;                             // 更新所围最大面积</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] height = &#123;1, 8, 6, 2, 5, 4, 8, 3, 7&#125;;</span><br><span class="line">        System.out.println(new Solution2().maxArea(height));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/11.%20Container%20With%20Most%20Water" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java实现 </tag>
            
            <tag> 数组问题 </tag>
            
            <tag> 双指针之对撞指针 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 345 Reverse Vowels of a String</title>
      <link href="/2018/08/21/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-345-Reverse-Vowels-of-a-String/"/>
      <url>/2018/08/21/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-345-Reverse-Vowels-of-a-String/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="345"><li>Reverse Vowels of a String:<a href="https://leetcode.com/problems/reverse-vowels-of-a-string/description/" target="_blank" rel="noopener">题目链接</a></li></ol><h2 id="方法1：双指针之对撞指针"><a href="#方法1：双指针之对撞指针" class="headerlink" title="方法1：双指针之对撞指针"></a>方法1：双指针之对撞指针</h2><p><strong><code>基本思想：</code></strong>指针i从左向右扫描，指针j从右向左扫描，，在此过程中发现是元音字母就交换指针i和指针j所指向的内容，不是元音字母，只要i&lt;j即两者不相遇继续进行扫描</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public class Solution1 &#123;</span><br><span class="line">    // 时间复杂度O(N)   空间复杂度O(N)</span><br><span class="line">    public String reverseVowels(String s) &#123;</span><br><span class="line">        char[] res = s.toCharArray();</span><br><span class="line">        String vowels = &quot;aeiouAEIOU&quot;;       // 元音字母</span><br><span class="line">        int i = 0;</span><br><span class="line">        int j = res.length-1;</span><br><span class="line">        // 只要i,j两者还未相遇</span><br><span class="line">        while (i &lt; j)&#123;</span><br><span class="line">            // 如果i指向的不是元音字母 i++; i&lt;j是为了确保在i++的过程中始终满足 i&lt;j</span><br><span class="line">            while (i &lt; j &amp;&amp; !vowels.contains(res[i]+&quot;&quot;)) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果j指向的不是元音字母 j--; i&lt;j是为了确保在j--的过程中始终满足 i&lt;j</span><br><span class="line">            while (i &lt; j &amp;&amp; !vowels.contains(res[j]+&quot;&quot;)) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            // 此时i,j指向的都是元音字母 交换</span><br><span class="line">            char temp = res[i];</span><br><span class="line">            res[i] = res[j];</span><br><span class="line">            res[j] = temp;</span><br><span class="line">            // 如果i,j指向的是元音字母 上面的两个while不会执行 需手动移动i,j指针</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        return new String(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String s = &quot;leetcode&quot;;</span><br><span class="line">        System.out.println(new Solution1().reverseVowels(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/344.%20Reverse%20String" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java实现 </tag>
            
            <tag> 数组问题 </tag>
            
            <tag> 双指针之对撞指针 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 344 Reverse String</title>
      <link href="/2018/08/20/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-344-Reverse-String/"/>
      <url>/2018/08/20/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-344-Reverse-String/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="344"><li>Reverse String:<a href="https://leetcode.com/problems/reverse-string/description/" target="_blank" rel="noopener">题目链接</a></li></ol><h2 id="方法1：双指针之对撞指针"><a href="#方法1：双指针之对撞指针" class="headerlink" title="方法1：双指针之对撞指针"></a>方法1：双指针之对撞指针</h2><p><strong><code>基本思想：</code></strong>指针i从左向右扫描，指针j从右向左扫描，只要i&lt;j即两者不相遇，就交换指针i和指针j所指向的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Solution1 &#123;</span><br><span class="line">    // 时间复杂度O(N)  空间复杂度O(N) 主要是开辟了res数组</span><br><span class="line">    public String reverseString(String s) &#123;</span><br><span class="line">        int i = 0;</span><br><span class="line">        int j = s.length() - 1;</span><br><span class="line">        char[] res = s.toCharArray();</span><br><span class="line">        while (i &lt; j)&#123;</span><br><span class="line">            char temp = res[i];</span><br><span class="line">            res[i] = res[j];</span><br><span class="line">            res[j] = temp;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        return new String(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String s = &quot;A man, a plan, a canal: Panama&quot;;</span><br><span class="line">        System.out.println(new Solution1().reverseString(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/344.%20Reverse%20String" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java实现 </tag>
            
            <tag> 数组问题 </tag>
            
            <tag> 双指针之对撞指针 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 125 Valid Palindrome</title>
      <link href="/2018/08/19/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-125-Valid-Palindrome/"/>
      <url>/2018/08/19/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-125-Valid-Palindrome/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="125"><li>Valid Palindromet:<a href="https://leetcode.com/problems/valid-palindrome/description/" target="_blank" rel="noopener">题目链接</a></li></ol><h2 id="方法1：双指针之对撞指针"><a href="#方法1：双指针之对撞指针" class="headerlink" title="方法1：双指针之对撞指针"></a>方法1：双指针之对撞指针</h2><p><strong><code>基本思想：</code></strong> <strong><code>指针i</code></strong>从左向右扫描，如果遇到的<strong><code>不是</code></strong>字母或者数字<strong><code>i++</code></strong>，<strong><code>指针j</code></strong>从右向左扫描，如果遇到的<strong><code>不是</code></strong>字母或者数字<strong><code>j--</code></strong>，此时i，j指向的是字母或数组，判断两者是否相等，相等继续，不相等说明不是回文数，当i与j相遇时结束</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class Solution1 &#123;</span><br><span class="line">    // 时间复杂度 O(N)   空间复杂度O(1)    双指针之对撞指针</span><br><span class="line">    public boolean isPalindrome(String s) &#123;</span><br><span class="line">        s = s.toLowerCase();</span><br><span class="line">        int i = 0;</span><br><span class="line">        int j = s.length() - 1;</span><br><span class="line">        while (i &lt; j) &#123;        // 两者还未相遇</span><br><span class="line">            // 从i向右扫描   如果不是字母或数字i++; i&lt;j 是为了在i++的过程中 i始终小于j</span><br><span class="line">            while (i &lt; j &amp;&amp; !Character.isLetterOrDigit(s.charAt(i))) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            // 从j向左扫描   如果不是字母或数字j--; i&lt;j 是为了在j--的过程中 i始终小于j</span><br><span class="line">            while (i &lt; j &amp;&amp; !Character.isLetterOrDigit(s.charAt(j))) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果i&gt;=j 说明已经相遇</span><br><span class="line">            if (i &gt;= j) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            // 此时i,j指向的都是字母或数字 看两者是否相等 不等说明不是回文数</span><br><span class="line">            if (s.charAt(i) != s.charAt(j)) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">            // 如果i,j都指向的是数字或字母 上面的两个while不会执行 需要手动的i++,j--</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        String s = &quot;A man, a plan, a canal: Panama&quot;;</span><br><span class="line">        System.out.println(new Solution1().isPalindrome(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/125.%20Valid%20Palindrome" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java实现 </tag>
            
            <tag> 数组问题 </tag>
            
            <tag> 双指针之对撞指针 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 167 Two Sum II - Input array is sorted</title>
      <link href="/2018/08/19/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-167-Two-Sum-II-Input-array-is-sorted/"/>
      <url>/2018/08/19/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-167-Two-Sum-II-Input-array-is-sorted/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="167"><li>Two Sum II - Input array is sorted:<a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/" target="_blank" rel="noopener">题目链接</a></li></ol><h2 id="方法1：暴力解法"><a href="#方法1：暴力解法" class="headerlink" title="方法1：暴力解法"></a>方法1：暴力解法</h2><p><strong><code>暴力解法如下：</code></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class Solution1 &#123;</span><br><span class="line">    // 时间复杂度O(N^2)  空间复杂度O(1)   暴力枚举法</span><br><span class="line">    public static int[] twoSum(int[] numbers, int target) &#123;</span><br><span class="line">        int[] res = new int[2];</span><br><span class="line">        // 双重循环遍历i和i之后的元素是否满足相加等于target</span><br><span class="line">        for (int i = 0; i &lt; numbers.length; ++i) &#123;</span><br><span class="line">            for (int j = i + 1; j &lt; numbers.length; ++j) &#123;</span><br><span class="line">                // 如果满足条件  加入res中</span><br><span class="line">                if (numbers[i] + numbers[j] == target) &#123;</span><br><span class="line">                    res[0] = i + 1;</span><br><span class="line">                    res[1] = j + 1;</span><br><span class="line">                    return res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] numbers = &#123;2, 7, 11, 15&#125;;</span><br><span class="line">        int target = 9;</span><br><span class="line">        System.out.println(Arrays.toString(twoSum(numbers, target)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="方法2：二分查找法"><a href="#方法2：二分查找法" class="headerlink" title="方法2：二分查找法"></a>方法2：二分查找法</h2><p>从题目中提取有效条件，发现输入的数组都是<strong><code>有序</code></strong>的,又是<strong><code>查找</code></strong>两个元素，这不由让我想到了用<strong><code>二分查找法</code></strong>，二分法应用的前提就是<strong><code>连续的存储空间</code></strong>(数组不就是连续的嘛)，<strong><code>元素有序</code></strong><br><strong><code>基本思路：</code></strong> <strong><code>指针i</code></strong>指向当前元素，在<strong><code>[i+1,nums.length-1]</code></strong>这个区间使用<strong><code>二分查找法</code></strong>寻找<strong><code>指针j</code></strong>满足<strong><code>numbers[i] + numbers[j] == target</code></strong></p><blockquote><p><strong><code>二分查找法</code></strong> <strong>递归与非递归形式详解：</strong><a href="https://xerdemo.github.io/2018/07/28/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E9%80%92%E5%BD%92%E4%B8%8E%E9%9D%9E%E9%80%92%E5%BD%92%E5%BD%A2%E5%BC%8F/">点击这里</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">public class Solution2 &#123;</span><br><span class="line">    // 二分查找非递归</span><br><span class="line">    public static int binarySearch(int[] numbers, int left, int right, int target) &#123;</span><br><span class="line">        while (left &lt;= right) &#123;</span><br><span class="line">            int mid = left + (right - left) / 2;</span><br><span class="line">            if (target &gt; numbers[mid]) &#123;</span><br><span class="line">                left = mid + 1;</span><br><span class="line">            &#125; else if (target &lt; numbers[mid]) &#123;</span><br><span class="line">                right = mid - 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;       // 不存在 </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 二分查找递归</span><br><span class="line">    public static int binarySearch2(int[] numbers, int left, int right, int target) &#123;</span><br><span class="line">        if (left &gt; right) &#123;</span><br><span class="line">            return -1;    // 不存在</span><br><span class="line">        &#125;</span><br><span class="line">        int mid = (right - left) / 2 + left;</span><br><span class="line">        if (target &gt; numbers[mid]) &#123;</span><br><span class="line">            return binarySearch2(numbers, mid + 1, right, target);</span><br><span class="line">        &#125; else if (target &lt; numbers[mid]) &#123;</span><br><span class="line">            return binarySearch2(numbers, left, mid - 1, target);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果用的是二分非递归 时间复杂度O(N*log2^N)   空间复杂度O(1)</span><br><span class="line">    // 如果用的是二分递归     时间复杂度O(N*log2^N)   空间复杂度O(log2^N)</span><br><span class="line">    public static int[] twoSum(int[] numbers, int target) &#123;</span><br><span class="line">        int[] res = new int[2];</span><br><span class="line">        for (int i = 0; i &lt; numbers.length - 1; ++i) &#123;</span><br><span class="line">            // j:利用二分查找看[i+1,nums.length-1] 是否存在j满足 numbers[i] + numbers[j] == target</span><br><span class="line">            int j = binarySearch2(numbers, i + 1, numbers.length - 1, target - numbers[i]);</span><br><span class="line">            if (j != -1) &#123;    // 如果存在</span><br><span class="line">                res[0] = i + 1;</span><br><span class="line">                res[1] = j + 1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] numbers = &#123;2, 7, 11, 15&#125;;</span><br><span class="line">        int target = 9;</span><br><span class="line">        System.out.println(Arrays.toString(twoSum(numbers, target)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="方法3：双指针之对撞指针"><a href="#方法3：双指针之对撞指针" class="headerlink" title="方法3：双指针之对撞指针"></a>方法3：双指针之对撞指针</h2><p><strong><code>基本思想：</code></strong> <strong><code>指针i</code></strong>从数组<strong>左侧开始往右侧</strong>移动，<strong><code>指针j</code></strong>从数组<strong>右侧往左侧</strong>移动</p><div align="center" style="zoom: 75%; margin:  0px auto;"><img src="/2018/08/19/LeetCode解题/01-Array/leetcode-167-Two-Sum-II-Input-array-is-sorted/leetcode167_1.png" alt=""></div><p>如果<strong><code>numbers[i] + numbers[j] &gt; target</code></strong>,则说明numbers[j]大了，尝试<strong><code>j--</code></strong>，<strong>减小numbers[j]的值</strong>，注意数组是<strong><code>有序</code></strong>的<br>同理<strong><code>numbers[i] + numbers[j] &lt; target</code></strong>,则说明numbers[i]小了，尝试<strong><code>i++</code></strong>，<strong>加大numbers[i]的值</strong><br>如果<strong><code>numbers[i] + numbers[j] == target</code></strong>，则说明找到了<br>如果<strong><code>i和j相遇</code></strong> <strong>还没有找到</strong>，说明不存在<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class Solution3 &#123;</span><br><span class="line">    // 时间复杂度O(N)  空间复杂度O(1)  双指针之对撞指针</span><br><span class="line">    public static int[] twoSum(int[] numbers, int target) &#123;</span><br><span class="line">        int i = 0;</span><br><span class="line">        int j = numbers.length - 1;</span><br><span class="line">        int[] res = new int[2];</span><br><span class="line">        // 只要i和j没相遇 </span><br><span class="line">        while (i &lt; j) &#123;</span><br><span class="line">            int sum = numbers[i] + numbers[j];</span><br><span class="line">            if (sum &gt; target) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125; else if (sum &lt; target) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                res[0] = i + 1;</span><br><span class="line">                res[1] = j + 1;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] numbers = &#123;2, 7, 11, 15&#125;;</span><br><span class="line">        int target = 9;</span><br><span class="line">        System.out.println(Arrays.toString(twoSum(numbers, target)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="方法4：利用map"><a href="#方法4：利用map" class="headerlink" title="方法4：利用map"></a>方法4：利用map</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line">public class Solution4 &#123;</span><br><span class="line">    // 时间复杂度O(N) 利用hashMap</span><br><span class="line">    public int[] twoSum(int[] numbers, int target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        int[] res = new int[2];</span><br><span class="line">        for (int i = 0; i &lt; numbers.length; ++i) &#123;</span><br><span class="line">            if (map.containsKey(target - numbers[i])) &#123;</span><br><span class="line">                res[0] = map.get(target - numbers[i]) + 1;</span><br><span class="line">                res[1] = i + 1;</span><br><span class="line">                break;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                map.put(numbers[i], i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] numbers = &#123;2, 7, 11, 15&#125;;</span><br><span class="line">        int target = 9;</span><br><span class="line">        System.out.println(Arrays.toString(new Solution4().twoSum(numbers, target)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>pS:</code></strong> <a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/167.%20Two%20Sum%20II%20-%20Input%20array%20is%20sorted" target="_blank" rel="noopener">相关源码链接</a></p>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java实现 </tag>
            
            <tag> 二分查找 </tag>
            
            <tag> 数组问题 </tag>
            
            <tag> 双指针之对撞指针 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 215 Kth Largest Element in an Array</title>
      <link href="/2018/08/18/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-215-Kth-Largest-Element-in-an-Array/"/>
      <url>/2018/08/18/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-215-Kth-Largest-Element-in-an-Array/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="215"><li>Kth Largest Element in an Array:<a href="https://leetcode.com/problems/kth-largest-element-in-an-array/description/" target="_blank" rel="noopener">题目链接</a></li></ol><h2 id="方法1：二路快速排序"><a href="#方法1：二路快速排序" class="headerlink" title="方法1：二路快速排序"></a>方法1：二路快速排序</h2><blockquote><p><strong><code>二路快速算法详情链接:</code></strong>&nbsp;&nbsp;<a href="https://xerdemo.github.io/2018/07/23/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0%E5%8F%8A%E4%BC%98%E5%8C%96/">点击这里</a></p></blockquote><p><strong><code>二路快速排序源码如下：</code></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public class Solution1 &#123;</span><br><span class="line"></span><br><span class="line">    public static void swap(int[] nums, int i, int j) &#123;</span><br><span class="line">        int temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void insertionSort(int[] nums, int left, int right) &#123;</span><br><span class="line">        for (int i = left + 1; i &lt;= right; ++i) &#123;</span><br><span class="line">            int temp = nums[i];</span><br><span class="line">            int j = i;</span><br><span class="line">            for (; j &gt; left &amp;&amp; nums[j - 1] &gt; temp; j--) &#123;</span><br><span class="line">                nums[j] = nums[j - 1];</span><br><span class="line">            &#125;</span><br><span class="line">            nums[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int parttion(int[] nums, int left, int right) &#123;</span><br><span class="line">        // 基准的选取 : 三路取中法</span><br><span class="line">        // 保证nums[left] &lt;= nums[mid] &lt;= nums[right] 最后将nums[left],nums[mid]交换</span><br><span class="line">        int mid = left + (right - left) / 2;</span><br><span class="line">        if (nums[left] &gt; nums[mid]) &#123;</span><br><span class="line">            swap(nums, left, mid);</span><br><span class="line">        &#125;</span><br><span class="line">        if (nums[left] &gt; nums[right]) &#123;</span><br><span class="line">            swap(nums, left, right);</span><br><span class="line">        &#125;</span><br><span class="line">        if (nums[mid] &gt; nums[right]) &#123;</span><br><span class="line">            swap(nums, mid, right);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, left, mid);</span><br><span class="line">        int v = nums[left];</span><br><span class="line"></span><br><span class="line">        int i = left + 1;</span><br><span class="line">        int j = right;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            while (i &lt;= right &amp;&amp; nums[i] &lt; v) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            while (j &gt;= left + 1 &amp;&amp; nums[j] &gt; v) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            if (i &gt; j) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(nums, i++, j--);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, left, j);</span><br><span class="line">        return j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 二路快速排序</span><br><span class="line">    public static int QuickSort(int[] nums, int left, int right, int k) &#123;</span><br><span class="line">        if (left &gt; right) &#123;</span><br><span class="line">            return Integer.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        int p = parttion(nums, left, right);</span><br><span class="line">        // 发现在基准右边就只快排右边 不管左边 同理</span><br><span class="line">        if (nums.length - k == p) &#123;            // 如果p此时指向的位置就是第K大数</span><br><span class="line">            return nums[p];</span><br><span class="line">        &#125; else if (nums.length - k &lt; p) &#123;    // 如果p此时指向的位置 &lt; 第K大数</span><br><span class="line">            return QuickSort(nums, left, p - 1, k);</span><br><span class="line">        &#125; else &#123;                            // 如果p此时指向的位置 &gt; 第K大数</span><br><span class="line">            return QuickSort(nums, p + 1, right, k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int findKthLargest(int[] nums, int k) &#123;</span><br><span class="line">        return QuickSort(nums, 0, nums.length - 1, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] nums = &#123;3, 2, 1, 5, 6, 4&#125;;</span><br><span class="line">        int k = 2;</span><br><span class="line">        System.out.println(findKthLargest(nums, k));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>ps：<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/215.%20Kth%20Largest%20Element%20in%20an%20Array" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java实现 </tag>
            
            <tag> 二路快速排序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 88 Merge Sorted Array</title>
      <link href="/2018/08/17/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-88-Merge-Sorted-Array/"/>
      <url>/2018/08/17/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-88-Merge-Sorted-Array/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="88"><li>Merge Sorted Array:<a href="https://leetcode.com/problems/merge-sorted-array/description/" target="_blank" rel="noopener">题目链接</a></li></ol><p><strong><code>动画演示：</code></strong></p><div align="center" style="zoom: 70%; margin:  0px auto;"><img src="/2018/08/17/LeetCode解题/01-Array/leetcode-88-Merge-Sorted-Array/Animation.gif" alt="原理"></div><p><font style="color: #FF0000; font-weight: bold; font-size: 20px;">pS:这里是从后往前，如果是从前往后会出现元素被覆盖的情况</font><br>比如在图中nums1元素为3 nums2元素为2 2会将3覆盖掉</p><p><strong><code>源码如下：</code></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class Solution1 &#123;</span><br><span class="line"></span><br><span class="line">    public static void merge(int[] nums1, int m, int[] nums2, int n) &#123;</span><br><span class="line">        int i = m - 1;</span><br><span class="line">        int j = n - 1;</span><br><span class="line">        int k = m + n - 1;</span><br><span class="line"></span><br><span class="line">        while (i &gt;= 0 &amp;&amp; j &gt;= 0) &#123;</span><br><span class="line">            if (nums1[i] &lt; nums2[j]) &#123;</span><br><span class="line">                nums1[k--] = nums2[j--];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                nums1[k--] = nums1[i--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 当j遍历完nums2[] i还没遍历完时</span><br><span class="line">        while (i &gt;= 0) &#123;</span><br><span class="line">            nums1[k--] = nums1[i--];</span><br><span class="line">        &#125;</span><br><span class="line">        // 当i遍历完nums1[] j还没遍历完时</span><br><span class="line">        while (j &gt;= 0) &#123;</span><br><span class="line">            nums1[k--] = nums2[j--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] nums1 = &#123;1, 2, 3, 0, 0, 0&#125;;</span><br><span class="line">        int[] nums2 = &#123;2, 5, 6&#125;;</span><br><span class="line">        int m = 3;</span><br><span class="line">        int n = 3;</span><br><span class="line">        merge(nums1, m, nums2, n);</span><br><span class="line">        System.out.println(Arrays.toString(nums1));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>ps：<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/88.%20Merge%20Sorted%20Array" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java实现 </tag>
            
            <tag> 数组问题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 75 Sort Colors</title>
      <link href="/2018/08/17/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-75-Sort-Colors/"/>
      <url>/2018/08/17/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-75-Sort-Colors/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="75"><li>Sort Colors:<a href="https://leetcode.com/problems/sort-colors/description/" target="_blank" rel="noopener">题目链接</a></li></ol><h2 id="方法1：计数排序"><a href="#方法1：计数排序" class="headerlink" title="方法1：计数排序"></a>方法1：计数排序</h2><blockquote><p><strong><code>计数排序算法详情链接:</code></strong>&nbsp;&nbsp;<a href="https://xerdemo.github.io/2018/08/16/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/">点击这里</a></p></blockquote><p><strong><code>计数排序源码如下：</code></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class Solution1 &#123;</span><br><span class="line">    // 时间复杂度O(N)  空间复杂度O(k) 其中K为要排序的数组的范围 O(3)  计数排序</span><br><span class="line">    public static void sortColors(int[] nums) &#123;</span><br><span class="line">        // 1.创建计数数组  并初始化</span><br><span class="line">        int[] count = new int[3];</span><br><span class="line">        // 2.将nums元素存放进对应的count中计算出现次数</span><br><span class="line">        for (int i = 0; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            count[nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        // 3.根据count出现次数来写入原数组nums</span><br><span class="line">        int j = 0;</span><br><span class="line">        for (int i = 0; i &lt; count.length; ++i) &#123;</span><br><span class="line">            while (count[i]-- != 0) &#123;</span><br><span class="line">                nums[j++] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] nums = &#123;2, 0, 2, 1, 1, 0&#125;;</span><br><span class="line">        sortColors(nums);</span><br><span class="line">        System.out.println(Arrays.toString(nums));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="方法2：三路快速排序"><a href="#方法2：三路快速排序" class="headerlink" title="方法2：三路快速排序"></a>方法2：三路快速排序</h2><blockquote><p><strong><code>三路快速算法详情链接:</code></strong>&nbsp;&nbsp;<a href="https://xerdemo.github.io/2018/07/23/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0%E5%8F%8A%E4%BC%98%E5%8C%96/">点击这里</a></p></blockquote><p><strong><code>三路快速排序源码如下：</code></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class Solution2 &#123;</span><br><span class="line">    public static void swap(int[] nums, int i, int j) &#123;</span><br><span class="line">        int t = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void insertionSort(int[] nums, int left, int right) &#123;</span><br><span class="line">        for (int i = left + 1; i &lt;= right; ++i) &#123;</span><br><span class="line">            int temp = nums[i];</span><br><span class="line">            int j = i;</span><br><span class="line">            for (; j &gt; left &amp;&amp; nums[j - 1] &gt; temp; j--) &#123;</span><br><span class="line">                nums[j] = nums[j - 1];</span><br><span class="line">            &#125;</span><br><span class="line">            nums[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void quickSort3ways(int[] nums, int left, int right) &#123;</span><br><span class="line"></span><br><span class="line">        if (right - left &lt;= 15) &#123;</span><br><span class="line">            insertionSort(nums, left, right);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        // 基准的选取 : 三路取中法</span><br><span class="line">        // 保证nums[left] &lt;= nums[mid] &lt;= nums[right] 最后将nums[left],nums[mid]交换</span><br><span class="line">        int mid = left + (right - left) / 2;</span><br><span class="line">        if (nums[left] &gt; nums[mid]) &#123;</span><br><span class="line">            swap(nums, left, mid);</span><br><span class="line">        &#125;</span><br><span class="line">        if (nums[left] &gt; nums[right]) &#123;</span><br><span class="line">            swap(nums, left, right);</span><br><span class="line">        &#125;</span><br><span class="line">        if (nums[mid] &gt; nums[right]) &#123;</span><br><span class="line">            swap(nums, mid, right);</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, left, mid);</span><br><span class="line"></span><br><span class="line">        // 基准的选取 : 随机数法</span><br><span class="line">        // swap(nums, left, (int)Math.random() * (right-left+1) + left );</span><br><span class="line">        int v = nums[left];</span><br><span class="line"></span><br><span class="line">        int lt = left;</span><br><span class="line">        int gt = right + 1;</span><br><span class="line">        int i = left + 1;</span><br><span class="line"></span><br><span class="line">        while (i &lt; gt) &#123;</span><br><span class="line">            if (nums[i] == v) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; else if (nums[i] &lt; v) &#123;</span><br><span class="line">                swap(nums, i++, ++lt);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                swap(nums, i, --gt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums, left, lt--);</span><br><span class="line"></span><br><span class="line">        quickSort3ways(nums, left, lt);</span><br><span class="line">        quickSort3ways(nums, gt, right);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void sortColors(int[] nums) &#123;</span><br><span class="line">        quickSort3ways(nums, 0, nums.length - 1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] nums = &#123;2, 0, 2, 1, 1, 0&#125;;</span><br><span class="line">        sortColors(nums);</span><br><span class="line">        System.out.println(Arrays.toString(nums));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>ps：<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/27.RemoveElement" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java实现 </tag>
            
            <tag> 计数排序 </tag>
            
            <tag> 三路快速排序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>计数排序</title>
      <link href="/2018/08/16/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
      <url>/2018/08/16/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>本文将介绍计数排序<a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>举个栗子来理解计数排序，输入数组<strong><code>arr[5] = {3, 4, 3, 2, 1}</code></strong>进行计数排序，会输出<strong><code>{1, 2, 3, 3, 4}</code></strong>。这个算法由以下步骤组成：</p><ol><li><strong><code>初始化</code></strong>计数数组count[size]，<strong><code>数组大小</code></strong>为数组中<strong><code>size = 最大值 - 最小值 + 1</code></strong></li><li>统计arr数组中每个值为<strong><code>k</code></strong>的元素<strong><code>出现的次数</code></strong>，存入计数数组count的第k项(此处为了节约开辟的数组空间，可以存入数组的<strong><code>k-min</code></strong>项)</li><li>遍历整个计数数组，将count中<strong><code>大于0</code></strong>的数对应原数组的值写回原数组中</li></ol><p><strong><code>例子:</code></strong><br>输入arr[5] = {3, 4, 3, 2, 1}</p><p>实现<strong><code>步骤1</code></strong>最大元素<strong><code>max = 4</code></strong>， 最小<strong><code>min = 1</code></strong>,开辟计数数组<strong><code>count[size]</code></strong> ,<strong><code>size = max - min + 1 = 4</code></strong><br>初始化count[4] = {0, 0, 0, 0} </p><p>实现<strong><code>步骤2</code></strong>，计算出arr中元素对应在count中的出现的次数<br>{<strong><code>3</code></strong>, 4, 3, 2, 1}  -&gt;  {0, 0, <strong><code>1</code></strong>, 0}  (值为3的元素，在count的第3-min项，即<strong><code>第2项</code></strong>，从0开始算)<br>{3, <strong><code>4</code></strong>, 3, 2, 1}  -&gt;  {0, 0, 1, <strong><code>1</code></strong>}<br>{3, 4, <strong><code>3</code></strong>, 2, 1}  -&gt;  {0, 0, <strong><code>2</code></strong>, 1}<br>{3, 4, 3, <strong><code>2</code></strong>, 1}  -&gt;  {0, <strong><code>1</code></strong>, 2, 1}<br>{3, 4, 3, 2, <strong><code>1</code></strong>}  -&gt;  {<strong><code>1</code></strong>, 1, 2, 1} </p><p>实现<strong><code>步骤3</code></strong><br>{<strong><code>1</code></strong>, 1, 2, 1} -&gt; {<strong><code>1</code></strong>, 4, 3, 2, 1}(下标:0+min:1即为对应原数组的值)<br>{0, <strong><code>1</code></strong>, 2, 1} -&gt; {1, <strong><code>2</code></strong>, 3, 2, 1}<br>{0, 0, <strong><code>2</code></strong>, 1} -&gt; {1, 2, <strong><code>3</code></strong>, 2, 1}<br>{0, 0, <strong><code>1</code></strong>, 1} -&gt; {1, 2, 3, <strong><code>3</code></strong>, 1}<br>{0, 0, 0, <strong><code>1</code></strong>} -&gt; {1, 2, 3, 3, <strong><code>4</code></strong>}<br>{0, 0, 0, <strong><code>0</code></strong>} -&gt; {1, 2, 3, 3, 4}</p><p><strong><code>CountSort.c</code></strong>源码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void printArray(int *arr, int n)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    for (i = 0; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d  &quot;, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void countSort(int * arr, int n)</span><br><span class="line">&#123;</span><br><span class="line">    int max = arr[0], min = arr[0],i;</span><br><span class="line">    // 找出数组中的最大值  最小值</span><br><span class="line">    for (i = 0; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        if (arr[i] &lt; min)&#123;</span><br><span class="line">            min = arr[i];       // 更新最小值</span><br><span class="line">        &#125;</span><br><span class="line">        if (arr[i] &gt; max) &#123;</span><br><span class="line">            max = arr[i];       // 更新最大值</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int size = max - min + 1;   // 计数数组count的大小</span><br><span class="line"></span><br><span class="line">    int *count = (int *) malloc(sizeof(int) * size);</span><br><span class="line">    for (i = 0; i&lt; size;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        count[i] = 0;           // 初始化count</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 将arr[]对应的数放入统计数组中  arr[i]-min对应的偏移量</span><br><span class="line">    for (i = 0; i&lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        count[arr[i] - min]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 遍历哈希表，将count数组中大于0的数对应出原数组的值，</span><br><span class="line">    int j = 0;</span><br><span class="line">    for (i = 0; i &lt; size; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        while (count[i]--)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[j++] = i + min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int arr[5] = &#123;3,4,3,2,1&#125;;</span><br><span class="line">    countSort(arr,5);</span><br><span class="line">    printArray(arr, 5);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>时间复杂度:</strong> <strong><code>O(N + k)</code></strong>，n是输入数组长度，k是最大的数的大小。<br><strong>空间复杂度:</strong> <strong><code>O(N + k)</code></strong>，n是输入数组长度，k是最大的数的大小</p><p><strong><code>优点：</code></strong></p><ol><li>无需进行比较，所以时间上快于任何的比较排序。</li><li>适用于数据比较<strong><code>集中</code></strong>,<strong><code>规模小</code></strong>的数据排序 </li></ol><p><strong><code>缺点：</code></strong></p><ol><li>计数排序对于数据<strong><code>范围很大</code></strong>的数组，需要大量时间和内存 </li><li>必须是<strong><code>正整数</code></strong></li></ol><blockquote><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/09_%E6%8E%92%E5%BA%8F/06-CountSortt" target="_blank" rel="noopener">源代码链接</a></p></blockquote></the>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C实现 </tag>
            
            <tag> 排序 </tag>
            
            <tag> 计数排序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 80 Remove Duplicates from Sorted Array II</title>
      <link href="/2018/08/14/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-80-Remove-Duplicates-from-Sorted-Array-II/"/>
      <url>/2018/08/14/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-80-Remove-Duplicates-from-Sorted-Array-II/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""><br>Remove Duplicates from Sorted Array II:<a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/description/" target="_blank" rel="noopener">题目链接</a></the></p><h2 id="解法1：双指针之快慢指针"><a href="#解法1：双指针之快慢指针" class="headerlink" title="解法1：双指针之快慢指针"></a>解法1：双指针之快慢指针</h2><p><strong><code>[0,slow]</code></strong>存放answer(第二个数组)，快指针从索引为1的地方开始遍历，初始时count = 1，已经将数组第一个元素0，计算在[0,slow]这个区间<br><strong><code>当快指针与慢指针指向相同元素时：</code></strong></p><div align="center" style="zoom: 20%; margin:  0px auto;"><img src="/2018/08/14/LeetCode解题/01-Array/leetcode-80-Remove-Duplicates-from-Sorted-Array-II/1.jpg" alt="原理"></div><p>slow往后移，并将fast指向的内容赋给slow，即<strong><code>nums[++slow] = nums[fast]</code></strong>,此时count++，执行此过程的<strong><code>前提是count&lt;2</code></strong>,如果count&gt;=2, 代表[0,slow]中已经有两个该元素了，fast往后移，slow不变</p><p><strong><code>当快指针与慢指针指向不相同元素时：</code></strong></p><p><div align="center" style="zoom: 80%; margin:  0px auto;"><img src="/2018/08/14/LeetCode解题/01-Array/leetcode-80-Remove-Duplicates-from-Sorted-Array-II/2.jpg" alt="原理"></div><br>slow往后移，并将fast指向的内容赋给slow，即<strong><code>nums[++slow] = nums[fast]</code></strong>，并将count置为1，表示[0,slow]中有1个该元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class Solution1 &#123;</span><br><span class="line">    public static int removeDuplicates(int[] nums) &#123;</span><br><span class="line">        if (nums == null || nums.length == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int slow = 0;        // [0,slow] 存放answer</span><br><span class="line">        int count = 1;</span><br><span class="line">        for (int fast = 1; fast &lt; nums.length; ++fast) &#123;</span><br><span class="line">            if (nums[slow] == nums[fast]) &#123;</span><br><span class="line">                if (count &lt; 2) &#123;</span><br><span class="line">                    nums[++slow] = nums[fast];</span><br><span class="line">                    count++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                nums[++slow] = nums[fast];</span><br><span class="line">                count = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return slow + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] nums = &#123;0, 0, 1, 1, 1, 1, 2, 3, 3&#125;;</span><br><span class="line">        System.out.println(removeDuplicates(nums));</span><br><span class="line">        System.out.println(Arrays.toString(nums));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/80.%20Remove%20Duplicates%20from%20Sorted%20Array%20II" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java实现 </tag>
            
            <tag> 数组问题 </tag>
            
            <tag> 双指针之快慢指针 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 26 Remove Duplicates from Sorted Array</title>
      <link href="/2018/08/14/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-26-Remove-Duplicates-from-Sorted-Array/"/>
      <url>/2018/08/14/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-26-Remove-Duplicates-from-Sorted-Array/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""><br>Remove Duplicates from Sorted Arrayt:<a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/" target="_blank" rel="noopener">题目链接</a></the></p><h2 id="方法1：双指针之快慢指针"><a href="#方法1：双指针之快慢指针" class="headerlink" title="方法1：双指针之快慢指针"></a>方法1：双指针之快慢指针</h2><p><strong><code>基本思路：</code></strong>用快指针fast遍历整个数组，发现符合条件的数据放入[0,slow]这个区间,题目有序这个条件很重要</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class Solution1 &#123;</span><br><span class="line">    // 时间复杂度O(N)  空间复杂度O(1)   双指针</span><br><span class="line">    public static int removeDuplicates(int[] nums) &#123;</span><br><span class="line">        if (nums == null || nums.length == 0) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int slow = 0;                 // [0,slow]  存放合法数据(答案)</span><br><span class="line">        // 快指针遍历数组</span><br><span class="line">        for (int fast = 0; fast &lt; nums.length; ++fast) &#123;</span><br><span class="line">            // 当前元素在[0,slow]中未出现，添加到[0,slow)  此处体会数组有序这个条件</span><br><span class="line">            if (nums[slow] != nums[fast]) &#123;</span><br><span class="line">                nums[++slow] = nums[fast];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return slow + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] nums = &#123;0, 0, 1, 1, 1, 2, 2, 3, 3, 4&#125;;</span><br><span class="line">        System.out.println(removeDuplicates(nums));</span><br><span class="line">        System.out.println(Arrays.toString(nums));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ps：<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/26.%20Remove%20Duplicates%20from%20Sorted%20Array" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java实现 </tag>
            
            <tag> 数组问题 </tag>
            
            <tag> 双指针之快慢指针 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 27 Remove Element</title>
      <link href="/2018/08/14/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-27-Remove-Element/"/>
      <url>/2018/08/14/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-27-Remove-Element/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""><br>Remove Element:<a href="https://leetcode.com/problems/remove-element/description/" target="_blank" rel="noopener">题目链接</a></the></p><h2 id="方法1：双指针之快慢指针"><a href="#方法1：双指针之快慢指针" class="headerlink" title="方法1：双指针之快慢指针"></a>方法1：双指针之快慢指针</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class Solution1 &#123;</span><br><span class="line">    // 时间复杂度 O(N)   空间复杂度O(1)   双指针</span><br><span class="line">    public static int removeElement(int[] nums, int val) &#123;</span><br><span class="line">        int slow = 0;                     // 存放不为val元素 区间[0, slow)</span><br><span class="line">        for (int fast = 0; fast &lt; nums.length; ++fast) &#123;</span><br><span class="line">            if (val != nums[fast]) &#123;</span><br><span class="line">                nums[slow++] = nums[fast];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] nums = &#123;0, 1, 2, 2, 3, 0, 4, 2&#125;;</span><br><span class="line">        int val = 2;</span><br><span class="line">        System.out.println(removeElement(nums, val));</span><br><span class="line">        System.out.println(Arrays.toString(nums));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法2：双指针之对撞指针"><a href="#方法2：双指针之对撞指针" class="headerlink" title="方法2：双指针之对撞指针"></a>方法2：双指针之对撞指针</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> * nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = numsSize <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == val) &#123;</span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">            j--;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ps：<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/27.RemoveElement" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java实现 </tag>
            
            <tag> 数组问题 </tag>
            
            <tag> 双指针之快慢指针 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 283. Move Zeroes</title>
      <link href="/2018/08/13/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-283-Move-Zeroes/"/>
      <url>/2018/08/13/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-283-Move-Zeroes/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""><br>Move Zeroes:<a href="https://leetcode.com/problems/move-zeroes/description/" target="_blank" rel="noopener">题目链接</a></the></p><h2 id="解法1：双指针之快慢指针"><a href="#解法1：双指针之快慢指针" class="headerlink" title="解法1：双指针之快慢指针"></a>解法1：双指针之快慢指针</h2><p><strong><code>基本思想：</code></strong>将<strong><code>[0,slow）</code></strong>存放<strong><code>非零</code></strong>元素，<strong><code>[slow,数组长度)</code></strong>存放0，fast用来遍历整个数组，当发现满足条件的元素，放入[0,slow)区间</p><div align="center" style="zoom: 70%; margin:  0px auto;"><img src="/2018/08/13/LeetCode解题/01-Array/leetcode-283-Move-Zeroes/双指针.gif" alt="原理"></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class Solution1 &#123;</span><br><span class="line">    // 时间复杂度 O(N)   空间复杂度O(1)    双指针</span><br><span class="line">    public static void moveZeroes(int[] nums) &#123;</span><br><span class="line">        int slow = 0;        // nums中, [0...slow)的元素均为非0元素</span><br><span class="line">        for (int fast = 0; fast &lt; nums.length; ++fast) &#123;</span><br><span class="line">            if (0 != nums[fast]) &#123;</span><br><span class="line">                nums[slow++] = nums[fast];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // [slow , nums.length) 存放0</span><br><span class="line">        for (int i = slow; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            nums[i] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] nums = &#123;0, 1, 0, 3, 12&#125;;</span><br><span class="line">        moveZeroes(nums);</span><br><span class="line">        System.out.println(Arrays.toString(nums));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解法2-优化解法1"><a href="#解法2-优化解法1" class="headerlink" title="解法2:优化解法1"></a>解法2:优化解法1</h2><p>在解法1的基础上，不需要将[slow , nums.length)单独拿出来赋值为0，在快慢指针进行的过程中，就已经完成了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class Solution2 &#123;</span><br><span class="line">    public static void swap(int[] nums, int i, int j) &#123;</span><br><span class="line">        int t = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 时间复杂度 O(N) 空间复杂度O(1) 双指针</span><br><span class="line">    public static void moveZeroes(int[] nums) &#123;</span><br><span class="line">        int slow = 0;</span><br><span class="line">        for (int fast = 0; fast &lt; nums.length; ++fast) &#123;</span><br><span class="line">            if (0 != nums[fast]) &#123;</span><br><span class="line">                swap(nums, slow++, fast);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] nums = &#123;0, 1, 0, 3, 12&#125;;</span><br><span class="line">        moveZeroes(nums);</span><br><span class="line">        System.out.println(Arrays.toString(nums));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解法3"><a href="#解法3" class="headerlink" title="解法3"></a>解法3</h2><p><strong><code>基本思想：</code></strong>遍历nums[]数组，不等于0的元素，暂存在临时数组res[]中，最后将最终结果再复制给nums[]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">public class Solution3 &#123;</span><br><span class="line">    // 时间复杂度 O(N) 空间复杂度O(N)</span><br><span class="line">    public static void moveZeroes(int[] nums) &#123;</span><br><span class="line">        int[] res = new int[nums.length];</span><br><span class="line"></span><br><span class="line">        int k = 0;</span><br><span class="line">        // 非零元素存到res[]</span><br><span class="line">        for (int i = 0; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            if (0 != nums[i]) &#123;</span><br><span class="line">                res[k++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = k; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            res[i] = 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            nums[i] = res[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        int[] nums = &#123; 0, 1, 0, 3, 12 &#125;;</span><br><span class="line">        moveZeroes(nums);</span><br><span class="line">        System.out.println(Arrays.toString(nums));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ps：<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/283.%20Move%20Zeroes" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java实现 </tag>
            
            <tag> 数组问题 </tag>
            
            <tag> 双指针之快慢指针 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>插入排序</title>
      <link href="/2018/07/31/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
      <url>/2018/07/31/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>本文将介绍插入排序<a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="插入排序基本思想"><a href="#插入排序基本思想" class="headerlink" title="插入排序基本思想"></a>插入排序基本思想</h2><p><strong><code>基本思想：</code></strong>待排序的一组序列分为已经排好序的和未排好序的两个部分；<strong><code>初始状态时</code></strong>，已排序的序列仅包含第一个元素，未排序的序列中元素未除去第一个以外N-1个元素；此后将未排序的元素依次插入到已排序的序列中。如此往复，经过N-1次插入后，未排序序列中元素个数为0，则排序完成。<br>可以把插入排序想象成打扑克时，拿牌的过程，首先右手先拿一张牌，放入左手此时只有一张牌且已经有序，右再拿一张牌，与当前已经有序的牌从右到左进行比较，放到适合的位置，重复此过程直到排序完成。</p><p><strong><code>具体实现：</code></strong></p><ol><li>从第一个元素开始，该元素可以认为已经被排序</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li><li>将新元素插入到该位置后</li><li>重复步骤2~5</li></ol><p><strong><code>动画演示：</code></strong></p><div align="center" style="zoom: 55%; margin:  0px auto;"><img src="/2018/07/31/插入排序/InserionSort.gif" alt="原理"></div><h2 id="插入排序代码"><a href="#插入排序代码" class="headerlink" title="插入排序代码"></a>插入排序代码</h2><p><strong><code>SortHelper.h</code></strong>存放相关工具函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ALGORITHM_SORTHELPER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALGORITHM_SORTHELPER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成有n个元素的随机数组,每个元素的随机范围为[rangeL, rangeR]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">generateRandomArray</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> rangeL, <span class="keyword">int</span> rangeR)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> * arr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span> &amp;&amp; rangeL &lt;= rangeR)</span><br><span class="line">    &#123;</span><br><span class="line">        arr = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);          <span class="comment">// 用malloc 分配数组 是因为不用malloc的话 随着此函数的结束 数组空间会被释放掉</span></span><br><span class="line">        srand(time(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i] = rand() % (rangeR - rangeL + <span class="number">1</span>) + rangeL;  <span class="comment">// 注意区间是[rangeL, rangeR]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换两个数位置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成近乎有序的数组  n数据个数  swapTimes:交换次数  最多只有2*交换次数个元素无序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">generateNearlyOrderArray</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> swapTimes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> *arr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        arr = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        srand(time(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; swapTimes; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x = rand() % n;</span><br><span class="line">            <span class="keyword">int</span> y = rand() % n;</span><br><span class="line">            swap(&amp;arr[x], &amp;arr[y]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成近乎倒序的数组  n数据个数  swapTimes:交换次数  最多只有2*交换次数个元素无序  左闭右开</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">generateNearlyReverseOrderArray</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> swapTimes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> *arr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        arr = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i] = n<span class="number">-1</span>-i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        srand(time(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; swapTimes; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x = rand() % n;</span><br><span class="line">            <span class="keyword">int</span> y = rand() % n;</span><br><span class="line">            swap(&amp;arr[x], &amp;arr[y]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertionSort</span><span class="params">(<span class="keyword">int</span> * arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = left + <span class="number">1</span>; i &lt;= right; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        <span class="keyword">for</span> (j = i; j &gt; left &amp;&amp; arr[j<span class="number">-1</span>] &gt; temp; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void testSort(char * sortName, void(*sort)(int* , int ), int * arr, int n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">clock_t</span> startTime = clock();</span><br><span class="line">    sort(arr, n);</span><br><span class="line">    <span class="keyword">clock_t</span> endTime = clock();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s cost: %lfs\n"</span>,sortName, (<span class="keyword">double</span>)(endTime - startTime) / CLOCKS_PER_SEC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝arr数组</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">copyArray</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> *arr2 = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        arr2[i] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//ALGORITHM_SORTHELPER_H</span></span></span><br></pre></td></tr></table></figure></p><p><strong><code>InsertionSort.c</code></strong>插入排序源码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SortHelper.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertionSort1</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//        for (j = i; j&gt;0; --j)</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            if (arr[j] &lt; arr[j - 1])</span></span><br><span class="line"><span class="comment">//            &#123;</span></span><br><span class="line"><span class="comment">//                swap(&amp;arr[j], &amp;arr[j - 1]);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            else</span></span><br><span class="line"><span class="comment">//            &#123;</span></span><br><span class="line"><span class="comment">//                break;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">// 可以改写成这样  注意i从1开始 j是&gt;0</span></span><br><span class="line">        <span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span> &amp;&amp; arr[j] &lt; arr[j - <span class="number">1</span>]; --j)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(&amp;arr[j], &amp;arr[j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化的插入排序  将交换(每次做三步赋值)   换成了 赋值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertionSort2</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];        <span class="comment">// 取出未排序序列中的第一个元素</span></span><br><span class="line">        <span class="comment">// 在已排序元素中 从后往前扫描  如果发现比temp大 则往后移一位</span></span><br><span class="line">        <span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span> &amp;&amp; arr[j<span class="number">-1</span>] &gt; temp; --j)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[j] = arr[j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j] = temp;            <span class="comment">// temp进入适合的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">100000</span>;</span><br><span class="line">    <span class="comment">// 随机数组   区间[0,n]</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"test RandomArray size = %d [0,%d]\n"</span>, n, n);</span><br><span class="line">    <span class="keyword">int</span> *arr = generateRandomArray(n, <span class="number">0</span>, n);</span><br><span class="line">    <span class="keyword">int</span> *arr1 = copyArray(arr, n);</span><br><span class="line">    testSort(<span class="string">"insertionSort1"</span>, insertionSort1, arr, n);</span><br><span class="line">    testSort(<span class="string">"insertionSort2 "</span>, insertionSort2, arr1, n);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 近乎有序的数组 swapTimes：交换次数 区间[0,n)</span></span><br><span class="line">    <span class="keyword">int</span> swapTimes = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\ntest NearlyOrderArray size = %d [0,%d) swapTimes: %d\n"</span>, n, n, swapTimes);</span><br><span class="line">    <span class="keyword">int</span> *arr2 = generateNearlyOrderArray(n, swapTimes);</span><br><span class="line">    <span class="keyword">int</span> *arr3 = copyArray(arr, n);</span><br><span class="line">    testSort(<span class="string">"insertionSort1 "</span>, insertionSort1, arr2, n);</span><br><span class="line">    testSort(<span class="string">"insertionSort2"</span>, insertionSort2, arr3, n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 近乎倒序的数组  区间[0,n)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\ntest NearlyReverseArray size = %d [0,%d) swapTimes: %d\n"</span>, n, n, swapTimes);</span><br><span class="line">    <span class="keyword">int</span> *arr4 = generateNearlyReverseOrderArray(n, swapTimes);</span><br><span class="line">    <span class="keyword">int</span> *arr5 = copyArray(arr4, n);</span><br><span class="line">    testSort(<span class="string">"insertionSort1 "</span>, insertionSort1, arr4, n);</span><br><span class="line">    testSort(<span class="string">"insertionSort2 "</span>, insertionSort2, arr5, n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 含大量重复元素的数组  [0,10]</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\ntest RandomArray  size = %d [0,10]\n"</span>, n);</span><br><span class="line">    <span class="keyword">int</span> *arr6 = generateRandomArray(n, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">int</span> *arr7 = copyArray(arr6, n);</span><br><span class="line">    testSort(<span class="string">"insertionSort1 "</span>, insertionSort1, arr6, n);</span><br><span class="line">    testSort(<span class="string">"insertionSort2"</span>, insertionSort2, arr7, n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(arr);<span class="built_in">free</span>(arr1);<span class="built_in">free</span>(arr2);<span class="built_in">free</span>(arr3);<span class="built_in">free</span>(arr4);<span class="built_in">free</span>(arr5);<span class="built_in">free</span>(arr6);<span class="built_in">free</span>(arr7);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong><code>Clion运行结果如下：</code></strong></p><div align="center" style="zoom: 80%; margin:  0px auto;"><img src="/2018/07/31/插入排序/InsertionSort2.png" alt="原理"></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong><code>时间复杂度</code></strong>：<strong><code>O(n^2)</code></strong> &nbsp;&nbsp;&nbsp;指的是平均时间复杂度<br><strong><code>空间复杂度</code></strong>：<strong><code>O(1)</code></strong>   &nbsp;&nbsp;&nbsp; &nbsp;   拿insertionSort2来说 只开辟了<strong><code>i,j,temp</code></strong>等<strong><code>常数</code></strong>个空间<br><strong> <code>稳定性</code> </strong>：&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>稳定的</code></strong>   &nbsp;&nbsp;&nbsp; 元素关键字相等的两个元素进行比较时并不会发生交换，即<strong><code>相对位置不会发生变化</code></strong><br>插入排序<strong><code>最坏的情况</code></strong>下对应的每一个i，要进行i-1次比较和交换，时间复杂度<strong><code>O(N^2)</code></strong><br>插入排序<strong><code>最好的情况</code></strong>下(序列已经<strong><code>有序</code></strong>)，只用执行第一层循环就行了<strong><code>O(N)</code></strong></p><blockquote><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/09_%E6%8E%92%E5%BA%8F/04-InsertionSort" target="_blank" rel="noopener">源代码链接</a></p></blockquote></the>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C实现 </tag>
            
            <tag> 排序 </tag>
            
            <tag> 直接插入排序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>冒泡排序</title>
      <link href="/2018/07/31/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
      <url>/2018/07/31/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>本文将介绍冒泡排序<a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="冒泡排序基本思想"><a href="#冒泡排序基本思想" class="headerlink" title="冒泡排序基本思想"></a>冒泡排序基本思想</h2><p><strong><code>基本思想：</code></strong>对元素个数为<strong><code>N</code></strong>的的待排序序列进行排序时，共进行<strong><code>N-1</code></strong>次循环。在第K次循环中，对于从第1到k-1个元素从前往后进行比较，每次比较相邻的两个元素，<strong><code>若前一个元素大于后一个元素</code></strong>(相等的时候不交换，这也是为什么冒泡是稳定的)，则两者<strong><code>交换位置</code></strong>，否则保持<strong><code>位置不变</code></strong>。这样一次循环下来，就把第k大的元素移动到第N-k个位置上，称为第k趟的冒泡。整个过程一共进行N-1趟冒泡，直到第1个和第2个元素比较完成，最终剩余最小的元素，留在第1个位置上，排序结束</p><p><strong><code>动画演示：</code></strong></p><div align="center" style="zoom: 50%; margin:  0px auto;"><img src="/2018/07/31/冒泡排序/BubbleSort.gif" alt="原理"></div><h2 id="冒泡排序代码"><a href="#冒泡排序代码" class="headerlink" title="冒泡排序代码"></a>冒泡排序代码</h2><p><strong><code>SortHelper.h</code></strong>存放相关工具函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">#ifndef ALGORITHM_SORTHELPER_H</span><br><span class="line">#define ALGORITHM_SORTHELPER_H</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line"></span><br><span class="line">// 生成有n个元素的随机数组,每个元素的随机范围为[rangeL, rangeR]</span><br><span class="line">int *generateRandomArray(int n, int rangeL, int rangeR)</span><br><span class="line">&#123;</span><br><span class="line">    int * arr = NULL;</span><br><span class="line">    int i;</span><br><span class="line">    if (n &gt; 0 &amp;&amp; rangeL &lt;= rangeR)</span><br><span class="line">    &#123;</span><br><span class="line">        arr = (int *) malloc(sizeof(int) * n);          // 用malloc 分配数组 是因为不用malloc的话 随着此函数的结束 数组空间会被释放掉</span><br><span class="line">        srand(time(NULL));</span><br><span class="line">        for (i = 0; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i] = rand() % (rangeR - rangeL + 1) + rangeL;  // 注意区间是[rangeL, rangeR]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 交换两个数位置</span><br><span class="line">void swap(int *a, int *b)</span><br><span class="line">&#123;</span><br><span class="line">    int temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 生成近乎有序的数组  n数据个数  swapTimes:交换次数  最多只有2*交换次数个元素无序</span><br><span class="line">int * generateNearlyOrderArray(int n, int swapTimes)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    int *arr = NULL;</span><br><span class="line">    if (n &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        arr = (int *) malloc(sizeof(int) * n);</span><br><span class="line">        for (i = 0; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        srand(time(NULL));</span><br><span class="line">        for (i = 0; i &lt; swapTimes; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            int x = rand() % n;</span><br><span class="line">            int y = rand() % n;</span><br><span class="line">            swap(&amp;arr[x], &amp;arr[y]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 生成近乎倒序的数组  n数据个数  swapTimes:交换次数  最多只有2*交换次数个元素无序  左闭右开</span><br><span class="line">int * generateNearlyReverseOrderArray(int n, int swapTimes)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    int *arr = NULL;</span><br><span class="line">    if (n &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        arr = (int *) malloc(sizeof(int) * n);</span><br><span class="line">        for (i = 0; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i] = n-1-i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        srand(time(NULL));</span><br><span class="line">        for (i = 0; i &lt; swapTimes; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            int x = rand() % n;</span><br><span class="line">            int y = rand() % n;</span><br><span class="line">            swap(&amp;arr[x], &amp;arr[y]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 插入排序</span><br><span class="line">void InsertionSort(int * arr, int left, int right)</span><br><span class="line">&#123;</span><br><span class="line">    int i, j;</span><br><span class="line">    for (i = left + 1; i &lt;= right; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        int temp = arr[i];</span><br><span class="line">        for (j = i; j &gt; left &amp;&amp; arr[j-1] &gt; temp; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[j] = arr[j - 1];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 打印数组</span><br><span class="line">void printArray(int *arr, int n)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    for (i = 0; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%d &quot;, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void testSort(char * sortName, void(*sort)(int* , int ), int * arr, int n)</span><br><span class="line">&#123;</span><br><span class="line">    clock_t startTime = clock();</span><br><span class="line">    sort(arr, n);</span><br><span class="line">    clock_t endTime = clock();</span><br><span class="line">    printf(&quot;%s cost: %lfs\n&quot;,sortName, (double)(endTime - startTime) / CLOCKS_PER_SEC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 拷贝arr数组</span><br><span class="line">int * copyArray(int *arr, int n)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line">    int *arr2 = (int *) malloc(sizeof(int) * n);</span><br><span class="line">    for (i = 0; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        arr2[i] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return arr2;</span><br><span class="line">&#125;</span><br><span class="line">#endif //ALGORITHM_SORTHELPER_H</span><br></pre></td></tr></table></figure></p><p><strong><code>BubbleSort.c</code></strong>冒泡排序源码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &quot;SortHelper.h&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void bubbleSort1(int *arr, int n)</span><br><span class="line">&#123;</span><br><span class="line">    int p, i;</span><br><span class="line">    for (p = n - 1; p &gt; 0; --p)       // 趟数 n-1趟</span><br><span class="line">    &#123;</span><br><span class="line">        for (i = 0; i &lt; p; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            // 每趟找出一个最大元素  被交换到最右端</span><br><span class="line">            if (arr[i] &gt; arr[i + 1])  // 若前一个元素大于后一个元素 交换</span><br><span class="line">            &#123;</span><br><span class="line">                swap(&amp;arr[i], &amp;arr[i + 1]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 优化</span><br><span class="line">void bubbleSort2(int *arr, int n)</span><br><span class="line">&#123;</span><br><span class="line">    int p,i,flag;</span><br><span class="line">    for (p = n - 1; p &gt; 0; --p)       // 趟数 n-1趟</span><br><span class="line">    &#123;</span><br><span class="line">        flag = 1;                     // 1:代表此时整个序列已经有序</span><br><span class="line">        for (i = 0; i &lt; p; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            // 每趟找出一个最大元素  被交换到最右端</span><br><span class="line">            if (arr[i] &gt; arr[i + 1])  // 若前一个元素大于后一个元素 交换</span><br><span class="line">            &#123;</span><br><span class="line">                swap(&amp;arr[i], &amp;arr[i + 1]);</span><br><span class="line">                flag = 0;             // 说明无序</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (flag)                     // 如果flag还保持为1 说明已经有序</span><br><span class="line">        &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int n = 100000;</span><br><span class="line">    // 随机数组   区间[0,n]</span><br><span class="line">    printf(&quot;test RandomArray size = %d [0,%d]\n&quot;, n, n);</span><br><span class="line">    int *arr = generateRandomArray(n, 0, n);</span><br><span class="line">    int *arr1 = copyArray(arr, n);</span><br><span class="line">    testSort(&quot;bubbleSort1 &quot;, bubbleSort1, arr, n);</span><br><span class="line">    testSort(&quot;bubbleSort2 &quot;, bubbleSort2, arr1, n);</span><br><span class="line"></span><br><span class="line">    // 近乎有序的数组 swapTimes：交换次数 区间[0,n)</span><br><span class="line">    int swapTimes = 100;</span><br><span class="line">    printf(&quot;\ntest NearlyOrderArray size = %d [0,%d) swapTimes: %d\n&quot;, n, n, swapTimes);</span><br><span class="line">    int *arr2 = generateNearlyOrderArray(n, swapTimes);</span><br><span class="line">    int *arr3 = copyArray(arr, n);</span><br><span class="line">    testSort(&quot;bubbleSort1 &quot;, bubbleSort1, arr2, n);</span><br><span class="line">    testSort(&quot;bubbleSort2 &quot;, bubbleSort2, arr3, n);</span><br><span class="line"></span><br><span class="line">    // 近乎倒序的数组  区间[0,n)</span><br><span class="line">    printf(&quot;\ntest NearlyReverseArray size = %d [0,%d) swapTimes: %d\n&quot;, n, n, swapTimes);</span><br><span class="line">    int *arr4 = generateNearlyReverseOrderArray(n, swapTimes);</span><br><span class="line">    int *arr5 = copyArray(arr4, n);</span><br><span class="line">    testSort(&quot;bubbleSort1 &quot;, bubbleSort1, arr4, n);</span><br><span class="line">    testSort(&quot;bubbleSort2 &quot;, bubbleSort2, arr5, n);</span><br><span class="line"></span><br><span class="line">    // 含大量重复元素的数组  [0,10]</span><br><span class="line">    printf(&quot;\ntest RandomArray  size = %d [0,10]\n&quot;, n);</span><br><span class="line">    int *arr6 = generateRandomArray(n, 0, 10);</span><br><span class="line">    int *arr7 = copyArray(arr6, n);</span><br><span class="line">    testSort(&quot;bubbleSort1 &quot;, bubbleSort1, arr6, n);</span><br><span class="line">    testSort(&quot;bubbleSort2 &quot;, bubbleSort2, arr7, n);</span><br><span class="line"></span><br><span class="line">    free(arr);free(arr1);free(arr2);free(arr3);free(arr4);free(arr5);free(arr6);free(arr7);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>Clion运行结果如下：</code></strong></p><div align="center" style="zoom: 80%; margin:  0px auto;"><img src="/2018/07/31/冒泡排序/BubbleSort2.png" alt="原理"></div><h2 id="双向冒泡排序"><a href="#双向冒泡排序" class="headerlink" title="双向冒泡排序"></a>双向冒泡排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双向冒泡：奇数趟，从前往后比较相邻元素，关键字最大的放在序列尾</span></span><br><span class="line"><span class="comment">//         偶数趟，从后往前比较相邻元素，关键字最小的放在序列头</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> * nums, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>; <span class="comment">// [left,right]排序</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">true</span>; <span class="comment">// 默认为true表示有序，如果flag在冒泡过程中没有改变，说明已经有序</span></span><br><span class="line">        <span class="comment">// 奇数趟：从左到右冒泡 将关键字大的放到序列尾</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt; right; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(nums[i], nums[i + <span class="number">1</span>]);</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        right--; <span class="comment">// 更新</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 偶数趟：从右到左冒泡 将关键字小的放到序列头</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = right; i &gt; left; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                swap(nums[i], nums[i - <span class="number">1</span>]);</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        left++; <span class="comment">// 更新</span></span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="literal">true</span>) &#123; <span class="comment">// 说明已经有序</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong><code>时间复杂度</code></strong>：<strong><code>O(n^2)</code></strong> &nbsp;&nbsp;&nbsp;指的是平均时间复杂度<br><strong><code>空间复杂度</code></strong>：<strong><code>O(1)</code></strong>   &nbsp;&nbsp;&nbsp; &nbsp;   拿bubbleSort2来说 只开辟了<strong><code>p,i,flag</code></strong>等<strong><code>常数</code></strong>个空间<br><strong> <code>稳定性</code> </strong>：&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>稳定的</code></strong>   &nbsp;&nbsp;&nbsp; 元素关键字相等的两个元素进行比较时并不会发生交换，即<strong><code>相对位置不会发生变化</code></strong><br>冒泡排序<strong><code>最坏的情况</code></strong>下(序列时<strong><code>逆序</code></strong>排序的)，每次比较都需要进行交换，时间复杂度<strong><code>O(N^2)</code></strong><br>冒泡排序<strong><code>最好的情况</code></strong>下(序列已经<strong><code>有序</code></strong>)，这时由于用了flag标志只要进行<strong><code>O(N)</code></strong>次比较就可以从循环跳出来.看上面运行结果图在几乎有序的情况下，未经flag优化的运行时间。</p><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/09_%E6%8E%92%E5%BA%8F/03-BubbleSort" target="_blank" rel="noopener">源代码链接</a></p></the>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C实现 </tag>
            
            <tag> 排序 </tag>
            
            <tag> 冒泡排序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>选择排序</title>
      <link href="/2018/07/31/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
      <url>/2018/07/31/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>本文将介绍选择排序<a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="选择排序基本思想"><a href="#选择排序基本思想" class="headerlink" title="选择排序基本思想"></a>选择排序基本思想</h2><p><strong><code>基本思想：</code></strong>在未排序序列中选取<strong><code>最小元素</code></strong>与<strong><code>序列第一位</code></strong>交换，接下来再从<strong><code>剩下的未排序序列`</code></strong>中选取<strong><code>最小值</code></strong>与整个<strong><code>序列第二位</code></strong>交换,依次类推，最后形成从小到大的已排序序列</p><p><strong><code>选择排序动画演示：</code></strong></p><div align="center" style="zoom: 55%; margin:  0px auto;"><img src="/2018/07/31/选择排序/SelectionSort.gif" alt="原理"></div><p>##简单选择排序源码</p><p><strong><code>SimpleSelectSort.c源码如下：</code></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &quot;math.h&quot;</span><br><span class="line">#include &quot;SortHelper.h&quot;</span><br><span class="line"></span><br><span class="line">// 时间复杂度 O(n^2)   空间复杂度O(1):只声明了i，j，minIndex等变量</span><br><span class="line">void selectionSort(int * arr, int n)</span><br><span class="line">&#123;</span><br><span class="line">    int i ;</span><br><span class="line">    for(int i = 0 ; i &lt; n ; i ++)&#123; // n-1趟</span><br><span class="line">        // 寻找[i, n)区间里的最小值</span><br><span class="line">        int minIndex = i;</span><br><span class="line">        for( int j = i + 1 ; j &lt; n ; j ++ )   // 寻找[i,n-1]中最小值元素</span><br><span class="line">            if( arr[j] &lt; arr[minIndex] )  </span><br><span class="line">                minIndex = j; </span><br><span class="line">if (minIndex != i) &#123;</span><br><span class="line">swap( arr[i] , arr[minIndex] );</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int n = pow(10, 5);</span><br><span class="line">    int *arr = generateRandomArray(n, 0, n);</span><br><span class="line">    int *arr1 = generateNearlyOrderArray(n, 100);</span><br><span class="line">    int *arr2 = generateRandomArray(n, 0, 10);</span><br><span class="line">    testSort(&quot;simple seletion sort RandomArray&quot;, selectionSort, arr, n);</span><br><span class="line">    testSort(&quot;simple seletion sort NearlyOrderArray&quot;, selectionSort, arr1, n);</span><br><span class="line">    testSort(&quot;simple seletion sort RandomArray [0,10]&quot;, selectionSort, arr2, n);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong><code>Clion运行结果如下：</code></strong>(数据规模：100000 十万)</p><div align="center" style="zoom: 90%; margin:  0px auto;"><img src="/2018/07/31/选择排序/SelectionSort.png" alt="原理"></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong><code>时间复杂度</code></strong>：<strong><code>O(n^2)</code></strong> &nbsp;&nbsp;&nbsp;指的是平均时间复杂度<br><strong><code>空间复杂度</code></strong>：<strong><code>O(1)</code></strong>   &nbsp;&nbsp;&nbsp; &nbsp;    只开辟了<strong><code>i，j，minIndex</code></strong>等<strong><code>常数</code></strong>个空间<br><strong> <code>稳定性</code> </strong>：&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>稳定的</code></strong>   &nbsp;&nbsp;&nbsp; 元素关键字相等的两个元素进行比较时并不会发生交换，即<strong><code>相对位置不会发生变化</code></strong><br>选择排序<strong><code>无论在什么情况下</code></strong>，都需要比较N*(N-1)/2次，故时间复杂度<strong><code>O(N^2)</code></strong>.事实上，在将第i个元素与最小元素交换之前，我们可以判断一下，如果minIndex == i，则无需交换，那么简单选择排序移动元素ishu在最好的情况下时0次(序列已经有序),在最坏的情况下为3(N-1)次(除去最后一个元素外，每个元素都要经过3步交换位置)</p><blockquote><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/09_%E6%8E%92%E5%BA%8F/05-SelectionSort" target="_blank" rel="noopener">源代码链接</a></p></blockquote></the>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C实现 </tag>
            
            <tag> 排序 </tag>
            
            <tag> 选择排序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>归并排序(自顶向下，自底向上)</title>
      <link href="/2018/07/28/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
      <url>/2018/07/28/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>本文将介绍从归并排序<a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><h2 id="归并排序基本思想"><a href="#归并排序基本思想" class="headerlink" title="归并排序基本思想"></a>归并排序基本思想</h2><p><strong><code>基本思想:</code></strong>将大小为N的序列看成N个长度为1的子序列，接下来将相邻的子序列两两进行归并操作，形成N/2(+1)个长度为2(或1)的有序子序列；然后再继续进行相邻子序列两两归并操作，如此一直循环，直到剩下1个长度为N的序列，则待序列为原序列完成排序后的结果。动画演示如下：</p><div align="center" style="zoom: 50%; margin:  0px auto;"><img src="/2018/07/28/归并排序/mergeSort1.gif" alt="原理"></div><p>其中归并的过程具体如下，选取<strong><code>2 3 6 8</code></strong> <strong><code>1 4 5 7</code></strong>这个即将要归并成一个序列的归并过程来讲归并的实现。动画演示如下：</p><div align="center" style="zoom: 50%; margin:  0px auto;"><img src="/2018/07/28/归并排序/mergeSort2.gif" alt="原理"></div><p>解释上面的动画过程，用一个<strong><code>辅助数组aux[]</code></strong>复制即将整合的两个序列，<strong><code>初始时</code></strong> <strong><code>i指向第一个序列的起始位置</code></strong>，<strong><code>j指向第二个序列的起始位置</code></strong>。当<strong><code>aux[i-left] &lt; aux[j-left]</code></strong>要减去left的偏移量，则<strong><code>arr[k]= arr[i-left]</code></strong>，<strong><code>k++, i++,j不变</code></strong>;如果<strong><code>aux[i-left] &gt;= aux[j-left]</code></strong>，则<strong><code>arr[k]= arr[j-left]</code></strong>，<strong><code>k++, j++,i不变</code></strong>;如果<strong><code>第一个序列结束</code></strong>  将<strong><code>第二个序列搬到arr[]</code></strong>;如果<strong><code>如果第二个序列结束</code></strong>  将<strong><code>第一个序列搬到arr[]</code></strong></p><div align="center" style="zoom: 50%; margin:  0px auto;"><img src="/2018/07/28/归并排序/mergeSort3.png" alt="原理"></div><h2 id="自顶向下归并排序源代码"><a href="#自顶向下归并排序源代码" class="headerlink" title="自顶向下归并排序源代码"></a>自顶向下归并排序源代码</h2><p><strong><code>SortHelper.h</code></strong> 存放归并排序需要的相关函数:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ALGORITHM_SORTHELPER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALGORITHM_SORTHELPER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成有n个元素的随机数组,每个元素的随机范围为[rangeL, rangeR]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">generateRandomArray</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> rangeL, <span class="keyword">int</span> rangeR)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> * arr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span> &amp;&amp; rangeL &lt;= rangeR)</span><br><span class="line">    &#123;</span><br><span class="line">        arr = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);          <span class="comment">// 用malloc 分配数组 是因为不用malloc的话 随着此函数的结束 数组空间会被释放掉</span></span><br><span class="line">        srand(time(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i] = rand() % (rangeR - rangeL + <span class="number">1</span>) + rangeL;  <span class="comment">// 注意区间是[rangeL, rangeR]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换两个数位置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成近乎有序的数组  n数据个数  swapTimes:交换次数  最多只有2*交换次数个元素无序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">generateNearlyOrderArray</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> swapTimes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> *arr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        arr = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        srand(time(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; swapTimes; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x = rand() % n;</span><br><span class="line">            <span class="keyword">int</span> y = rand() % n;</span><br><span class="line">            swap(&amp;arr[x], &amp;arr[y]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertionSort</span><span class="params">(<span class="keyword">int</span> * arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = left + <span class="number">1</span>; i &lt;= right; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        <span class="keyword">for</span> (j = i; j &gt; left &amp;&amp; arr[j<span class="number">-1</span>] &gt; temp; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void testSort(char * sortName, void(*sort)(int* , int ), int * arr, int n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">clock_t</span> startTime = clock();</span><br><span class="line">    sort(arr, n);</span><br><span class="line">    <span class="keyword">clock_t</span> endTime = clock();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s cost: %lfs\n"</span>,sortName, (<span class="keyword">double</span>)(endTime - startTime) / CLOCKS_PER_SEC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝arr数组</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">copyArray</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> *arr2 = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        arr2[i] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//ALGORITHM_SORTHELPER_H</span></span></span><br></pre></td></tr></table></figure></p><p><strong><code>MergeSort1.c</code></strong>自顶向下源码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SortHelper.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将arr[left ... right] 进行归并操作</span></span><br><span class="line"><span class="keyword">void</span> __merge1(<span class="keyword">int</span> *arr, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">int</span> aux[right - left + <span class="number">1</span>];              <span class="comment">// 辅助数组aux[]  复制即将整合的两个序列</span></span><br><span class="line">    <span class="keyword">for</span> (i = left; i &lt;= right; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        aux[i - left] = arr[i];             <span class="comment">// aux[] 复制 arr[]的内容</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    i = left, j = mid + <span class="number">1</span>;                  <span class="comment">// i指向第一个序列的起始位置  j指向第二个序列的起始位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (k = left; k &lt;= right; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; mid)                        <span class="comment">// 如果第一个序列结束  将第二个序列搬到arr[]</span></span><br><span class="line">        &#123;</span><br><span class="line">            arr[k] = aux[j - left];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; right)                 <span class="comment">// 如果第二个序列结束  将第一个序列搬到arr[]</span></span><br><span class="line">        &#123;</span><br><span class="line">            arr[k] = aux[i-left];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (aux[i-left] &lt; aux[j-left])  <span class="comment">// 如果此时i指向的元素 小于 j</span></span><br><span class="line">        &#123;</span><br><span class="line">            arr[k] = aux[i - left];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            arr[k] = aux[j - left];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对arr[left ... right] 进行归并排序</span></span><br><span class="line"><span class="keyword">void</span> __mergeSort1(<span class="keyword">int</span> *arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    __mergeSort1(arr, left, mid);           <span class="comment">// 对左子序列进行归并排序</span></span><br><span class="line">    __mergeSort1(arr, mid + <span class="number">1</span>, right);      <span class="comment">// 对右子序列进行归并排序</span></span><br><span class="line">    __merge1(arr, left, mid , right);       <span class="comment">// 将左子序列 右子序列进行归并操作</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort1</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __mergeSort1(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">pow</span>(<span class="number">10</span>, <span class="number">7</span>);</span><br><span class="line">    <span class="comment">// 测试随机数组</span></span><br><span class="line">    <span class="keyword">int</span> *arr = generateRandomArray(n, <span class="number">0</span>, n);</span><br><span class="line">    testSort(<span class="string">"mergeSort1"</span>, mergeSort1, arr, n);</span><br><span class="line">    <span class="built_in">free</span>(arr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试几乎有序的数组</span></span><br><span class="line">    <span class="keyword">int</span> swapTimes = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> *arr1 = generateNearlyOrderArray(n, swapTimes);</span><br><span class="line">    testSort(<span class="string">"mergeSort1"</span>, mergeSort1, arr1, n);</span><br><span class="line">    <span class="built_in">free</span>(arr1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试含有大量重复元素的数组  n个数组 范围[0,10]</span></span><br><span class="line">    <span class="keyword">int</span> *arr2 = generateRandomArray(n, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    testSort(<span class="string">"mergeSort1"</span>, mergeSort1, arr2, n);</span><br><span class="line">    <span class="built_in">free</span>(arr2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong><code>自顶向下归并排序Clion运行结果：(数据规模10000000   1千万)</code></strong></p><div align="center" style="zoom: 90%; margin:  0px auto;"><img src="/2018/07/28/归并排序/mergeSort4.png" alt="原理"></div><p>还有两个地方可以<strong><code>优化：</code></strong></p><ul><li>对于<strong><code>小规模</code></strong>数组,使用<strong><code>插入排序</code></strong></li><li>对于<strong><code>arr[mid] &lt;= arr[mid+1]</code></strong>的情况 不进行merge 因为已经有序</li></ul><p><strong><code>优化后自顶向下的归并排序</code></strong>  <strong><code>MergeSort2.c</code></strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SortHelper.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将arr[left ... right] 进行归并操作</span></span><br><span class="line"><span class="keyword">void</span> __merge2(<span class="keyword">int</span> *arr, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">int</span> aux[right - left + <span class="number">1</span>];              <span class="comment">// 辅助数组aux[]  复制即将整合的两个序列</span></span><br><span class="line">    <span class="keyword">for</span> (i = left; i &lt;= right; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        aux[i - left] = arr[i];             <span class="comment">// aux[] 复制 arr[]的内容</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    i = left, j = mid + <span class="number">1</span>;                  <span class="comment">// i指向第一个序列的起始位置  j指向第二个序列的起始位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (k = left; k &lt;= right; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; mid)                        <span class="comment">// 如果第一个序列结束  将第二个序列搬到arr[]</span></span><br><span class="line">        &#123;</span><br><span class="line">            arr[k] = aux[j - left];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j &gt; right)                 <span class="comment">// 如果第二个序列结束  将第一个序列搬到arr[]</span></span><br><span class="line">        &#123;</span><br><span class="line">            arr[k] = aux[i-left];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (aux[i-left] &lt; aux[j-left])  <span class="comment">// 如果此时i指向的元素 小于 j</span></span><br><span class="line">        &#123;</span><br><span class="line">            arr[k] = aux[i - left];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            arr[k] = aux[j - left];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在__mergeSort1的基础上两个地方进行优化</span></span><br><span class="line"><span class="comment">// 对arr[left ... right] 进行归并排序</span></span><br><span class="line"><span class="keyword">void</span> __mergeSort2(<span class="keyword">int</span> *arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 优化1： 对于小规模数组,使用插入排序</span></span><br><span class="line">    <span class="keyword">if</span> (right - left &lt;= <span class="number">15</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        InsertionSort(arr, left, right);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    __mergeSort2(arr, left, mid);</span><br><span class="line">    __mergeSort2(arr, mid + <span class="number">1</span>, right);</span><br><span class="line">    <span class="comment">// 优化2： 对于arr[mid] &lt;= arr[mid+1]的情况 不进行merge 因为已经有序</span></span><br><span class="line">    <span class="comment">// 对于近乎有序的数组非常有效 但是对于一般情况，有一定的性能损失（判读需要时间）</span></span><br><span class="line">    <span class="keyword">if</span> (arr[mid] &gt; arr[mid + <span class="number">1</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        __merge2(arr, left, mid , right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort2</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __mergeSort2(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">pow</span>(<span class="number">10</span>, <span class="number">7</span>);</span><br><span class="line">    <span class="comment">// 测试随机数组</span></span><br><span class="line">    <span class="keyword">int</span> *arr = generateRandomArray(n, <span class="number">0</span>, n);</span><br><span class="line">    testSort(<span class="string">"mergeSort2"</span>, mergeSort2, arr, n);</span><br><span class="line">    <span class="built_in">free</span>(arr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试几乎有序的数组</span></span><br><span class="line">    <span class="keyword">int</span> swapTimes = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> *arr1 = generateNearlyOrderArray(n, swapTimes);</span><br><span class="line">    testSort(<span class="string">"mergeSort2"</span>, mergeSort2, arr1, n);</span><br><span class="line">    <span class="built_in">free</span>(arr1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试含有大量重复元素的数组  n个数组 范围[0,10]</span></span><br><span class="line">    <span class="keyword">int</span> *arr2 = generateRandomArray(n, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    testSort(<span class="string">"mergeSort2"</span>, mergeSort2, arr2, n);</span><br><span class="line">    <span class="built_in">free</span>(arr2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong><code>自顶向下归并排序(优化后)Clion运行结果：(数据规模10000000   1千万)</code></strong></p><div align="center" style="zoom: 90%; margin:  0px auto;"><img src="/2018/07/28/归并排序/mergeSort5.png" alt="原理"></div><h2 id="自底向上的归并排序"><a href="#自底向上的归并排序" class="headerlink" title="自底向上的归并排序"></a>自底向上的归并排序</h2><p>自底向上的归并排序<strong><code>MergeSortBU.c</code></strong>如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MergeSort1.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SortHelper.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b ? b : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSortBU</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size, i;</span><br><span class="line">    <span class="keyword">for</span> (size = <span class="number">1</span>; size &lt;= n; size += size)             <span class="comment">// 规模 每次扩大两倍</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i + size &lt; n; i += <span class="number">2</span> * size)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 对 arr[i...i+size-1] 和 arr[i+size...i+2*size-1] 进行归并</span></span><br><span class="line">            <span class="comment">// 循环条件i+size &lt; n 是为了确保第二部分的存在 也保证了i+size-1(第一个子序列)不会越界</span></span><br><span class="line">            <span class="comment">// 为了确保第二个子序列不会越界 min(i + 2 * size - 1, n-1)</span></span><br><span class="line">            __merge1(arr, i, i + size - <span class="number">1</span>, min(i + <span class="number">2</span> * size - <span class="number">1</span>, n - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在mergeSortBU的基础上两个地方进行优化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSortBU2</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size, i;</span><br><span class="line">    <span class="comment">// 优化1： 对于小规模数组,使用插入排序</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i += <span class="number">16</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        InsertionSort(arr, i, min(i + <span class="number">15</span>, n - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (size = <span class="number">16</span>; size &lt;= n; size += size)             <span class="comment">// 规模 每次扩大两倍</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i + size &lt; n; i += <span class="number">2</span> * size)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 优化2： 对于arr[i + size - 1] &gt; arr[i + size]的情况 不进行merge 因为已经有序</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i + size - <span class="number">1</span>] &gt; arr[i + size])</span><br><span class="line">            &#123;</span><br><span class="line">                __merge1(arr, i, i + size - <span class="number">1</span>, min(i + <span class="number">2</span> * size - <span class="number">1</span>, n - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">pow</span>(<span class="number">10</span>, <span class="number">7</span>);</span><br><span class="line">    <span class="comment">// 测试随机数组</span></span><br><span class="line">    <span class="keyword">int</span> *arr = generateRandomArray(n, <span class="number">0</span>, n);</span><br><span class="line">    <span class="keyword">int</span> *arr1 = copyArray(arr, n);</span><br><span class="line">    testSort(<span class="string">"mergeSortBU"</span>, mergeSortBU, arr, n);</span><br><span class="line">    testSort(<span class="string">"mergeSortBU2"</span>, mergeSortBU2, arr1, n);</span><br><span class="line">    <span class="built_in">free</span>(arr);</span><br><span class="line">    <span class="built_in">free</span>(arr1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试几乎有序的数组</span></span><br><span class="line">    <span class="keyword">int</span> swapTimes = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> *arr2 = generateNearlyOrderArray(n, swapTimes);</span><br><span class="line">    <span class="keyword">int</span> *arr3 = copyArray(arr2, n);</span><br><span class="line">    testSort(<span class="string">"mergeSortBU"</span>, mergeSortBU, arr2, n);</span><br><span class="line">    testSort(<span class="string">"mergeSortBU2"</span>, mergeSortBU2, arr3, n);</span><br><span class="line">    <span class="built_in">free</span>(arr2);</span><br><span class="line">    <span class="built_in">free</span>(arr3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试含有大量重复元素的数组  n个数组 范围[0,10]</span></span><br><span class="line">    <span class="keyword">int</span> *arr4 = generateRandomArray(n, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">int</span> *arr5 = copyArray(arr4, n);</span><br><span class="line">    testSort(<span class="string">"mergeSortBU"</span>, mergeSortBU, arr4, n);</span><br><span class="line">    testSort(<span class="string">"mergeSortBU2"</span>, mergeSortBU2, arr5, n);</span><br><span class="line">    <span class="built_in">free</span>(arr4);</span><br><span class="line">    <span class="built_in">free</span>(arr5);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong><code>自底向上归并排序Clion运行结果：(数据规模10000000   1千万)</code></strong></p><div align="center" style="zoom: 90%; margin:  0px auto;"><img src="/2018/07/28/归并排序/mergeSort6.png" alt="原理"></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>将<strong><code>MergeSort1.c</code></strong>,<strong><code>MergeSort2.c</code></strong>,<strong><code>MergeSortBU.c</code></strong>更改为<strong><code>.h</code></strong>,新建<strong><code>Main.c</code></strong>如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SortHelper.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MergeSort2.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MergeSortBU.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">pow</span>(<span class="number">10</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="comment">// 测试随机数组</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"test generateRandomArray, size = %d, random range [0, %d]\n"</span>, n, n);</span><br><span class="line">    <span class="keyword">int</span> *arr = generateRandomArray(n, <span class="number">0</span>, n);</span><br><span class="line">    <span class="keyword">int</span> *arr1 = copyArray(arr, n);</span><br><span class="line">    <span class="keyword">int</span> *arr2 = copyArray(arr, n);</span><br><span class="line">    <span class="keyword">int</span> *arr3 = copyArray(arr, n);</span><br><span class="line">    testSort(<span class="string">"mergeSort1"</span>, mergeSort1, arr, n);</span><br><span class="line">    testSort(<span class="string">"mergeSort2"</span>, mergeSort2, arr1, n);</span><br><span class="line">    testSort(<span class="string">"mergeSortBU"</span>, mergeSortBU, arr2, n);</span><br><span class="line">    testSort(<span class="string">"mergeSortBU2"</span>, mergeSortBU2, arr3, n);</span><br><span class="line">    <span class="built_in">free</span>(arr);<span class="built_in">free</span>(arr1);<span class="built_in">free</span>(arr2);<span class="built_in">free</span>(arr3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试几乎有序的数组</span></span><br><span class="line">    <span class="keyword">int</span> swapTimes = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\ntest generateNearlyOrderArray, size = %d, sawpTimes = %d\n"</span>,n, swapTimes);</span><br><span class="line">    <span class="keyword">int</span> *arr4 = generateNearlyOrderArray(n, swapTimes);</span><br><span class="line">    <span class="keyword">int</span> *arr5 = copyArray(arr4, n);</span><br><span class="line">    <span class="keyword">int</span> *arr6 = copyArray(arr4, n);</span><br><span class="line">    <span class="keyword">int</span> *arr7 = copyArray(arr4, n);</span><br><span class="line">    testSort(<span class="string">"mergeSort1"</span>, mergeSort1, arr4, n);</span><br><span class="line">    testSort(<span class="string">"mergeSort2"</span>, mergeSort2, arr5, n);</span><br><span class="line">    testSort(<span class="string">"mergeSortBU"</span>, mergeSortBU, arr6, n);</span><br><span class="line">    testSort(<span class="string">"mergeSortBU2"</span>, mergeSortBU2, arr7, n);</span><br><span class="line">    <span class="built_in">free</span>(arr4);<span class="built_in">free</span>(arr5);<span class="built_in">free</span>(arr6);<span class="built_in">free</span>(arr7);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试含有大量重复元素的数组  n个数组 范围[0,10]</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\ntest generateRandomArray, size = %d, random range [0, %d]\n"</span>,n, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">int</span> *arr8 = generateRandomArray(n, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">int</span> *arr9 = copyArray(arr8, n);</span><br><span class="line">    <span class="keyword">int</span> *arr10 = copyArray(arr8, n);</span><br><span class="line">    <span class="keyword">int</span> *arr11 = copyArray(arr8, n);</span><br><span class="line">    testSort(<span class="string">"mergeSort1"</span>, mergeSort1, arr8, n);</span><br><span class="line">    testSort(<span class="string">"mergeSort2"</span>, mergeSort2, arr9, n);</span><br><span class="line">    testSort(<span class="string">"mergeSortBU"</span>, mergeSortBU, arr10, n);</span><br><span class="line">    testSort(<span class="string">"mergeSortBU2"</span>, mergeSortBU2, arr11, n);</span><br><span class="line">    <span class="built_in">free</span>(arr8);<span class="built_in">free</span>(arr9);<span class="built_in">free</span>(arr10);<span class="built_in">free</span>(arr11);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong><code>Clion运行结果如下</code></strong>,规模又扩大了10倍(1亿)</p><div align="center" style="zoom: 90%; margin:  0px auto;"><img src="/2018/07/28/归并排序/mergeSort7.png" alt="原理"></div><p><a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/09_%E6%8E%92%E5%BA%8F/02-MergeSort" target="_blank" rel="noopener">相关源代码下载链接</a></p>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C实现 </tag>
            
            <tag> 排序 </tag>
            
            <tag> 分治法 </tag>
            
            <tag> 归并排序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>二分查找递归与非递归形式</title>
      <link href="/2018/07/28/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E9%80%92%E5%BD%92%E4%B8%8E%E9%9D%9E%E9%80%92%E5%BD%92%E5%BD%A2%E5%BC%8F/"/>
      <url>/2018/07/28/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E9%80%92%E5%BD%92%E4%B8%8E%E9%9D%9E%E9%80%92%E5%BD%92%E5%BD%A2%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>本文将介绍二分查找的递归形式与非递归形式，并对临界情况进行分析<a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><h2 id="二分查找基本思想"><a href="#二分查找基本思想" class="headerlink" title="二分查找基本思想"></a>二分查找基本思想</h2><p><strong><code>基本思想：</code></strong>在<strong><code>有序</code></strong>的数组中（不适用于链表）取中间元素为比较对象，如果要查找的值比中间元素的值<strong><code>小</code></strong>，到中间元素的<strong><code>左边</code></strong>去查，如果要查找的值比中间元素的值<strong><code>大</code></strong>，到中间元素的<strong><code>右边</code></strong>去查，如果<strong><code>相等</code></strong>则查找成功，不断重复此过程。</p><h2 id="二分查找非递归代码"><a href="#二分查找非递归代码" class="headerlink" title="二分查找非递归代码"></a>二分查找非递归代码</h2><p><strong><code>searchHelper.h</code></strong>辅助代码如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ALGORITHM_SEARCHHELPER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALGORITHM_SEARCHHELPER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"time.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成有序的数组  n:数据个数 [0,n)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">generateOrderArray</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> *arr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        arr = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印数组内容</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span> * arr, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d  "</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试该算法</span></span><br><span class="line">void testSearch(char * searchName, int (*search)(int *, int , int ), int * arr, int n )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">clock_t</span> startTime = clock();</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != search(arr, n, i))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"no found %d\n"</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">clock_t</span> endTime = clock();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s test complete.  cost time: %lf s\n"</span>, searchName, (<span class="keyword">double</span>)(endTime - startTime) / CLOCKS_PER_SEC);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//ALGORITHM_SEARCHHELPER_H</span></span></span><br></pre></td></tr></table></figure></p><p>边界范围<strong><code>[left,right]</code></strong>,<strong><code>BinarySearch1.c</code></strong>如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"searchHelper.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义二分查找的区间为 [left, right]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch1</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;     <span class="comment">// 在[left...right]的范围里寻找target</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)            <span class="comment">// 当 left == right时,区间[left...right]依然是有效的</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// int mid = (left + right) / 2;  此写法有bug 如果left + right超出了整数的范围 数据溢出</span></span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == target)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; target)</span><br><span class="line">        &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;    <span class="comment">// 找不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">pow</span>(<span class="number">10</span>, <span class="number">7</span>);</span><br><span class="line">    <span class="keyword">int</span> *arr1 = generateOrderArray(n);</span><br><span class="line">    testSearch(<span class="string">"BinarySearch1"</span>, binarySearch1, arr1, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>边界范围<strong><code>[left,right)</code></strong>,<strong><code>BinarySearch2.c</code></strong>如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"searchHelper.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在binarySearch1的基础上 更改 二分查找的区间为 [left, right)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch2</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = n;         <span class="comment">// 在[left...right)的范围里寻找target</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)            <span class="comment">// 当 left &lt; right时,区间[left...right)依然是有效的</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// int mid = (left + right) / 2;  此写法有bug 如果left + right超出了整数的范围 数据溢出</span></span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == target)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; target)</span><br><span class="line">        &#123;</span><br><span class="line">            right = mid;            <span class="comment">// 从mid -1 改成mid</span></span><br><span class="line">        &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;    <span class="comment">// 找不到</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">pow</span>(<span class="number">10</span>, <span class="number">7</span>);</span><br><span class="line">    <span class="keyword">int</span> *arr2 = generateOrderArray(n);</span><br><span class="line">    testSearch(<span class="string">"BinarySearch2"</span>, binarySearch2, arr2, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="二分查找递归"><a href="#二分查找递归" class="headerlink" title="二分查找递归"></a>二分查找递归</h2><p>边界范围<strong><code>[left,right]</code></strong>,<strong><code>BinarySearchRecursive.c</code></strong>如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"searchHelper.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义二分查找的区间为 [left, right]</span></span><br><span class="line"><span class="keyword">int</span> __BinarySearchRecursive(<span class="keyword">int</span> *arr, <span class="keyword">int</span> left,<span class="keyword">int</span> right, <span class="keyword">int</span> target)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right)      <span class="comment">// 根据定义的区间[left, right] 当left == right时 还有效</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">    <span class="keyword">if</span> (arr[mid] == target)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; target)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> __BinarySearchRecursive(arr, mid + <span class="number">1</span>, right,target);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> __BinarySearchRecursive(arr, left, mid - <span class="number">1</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统一接口</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearchRecursive</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  __BinarySearchRecursive(arr, <span class="number">0</span>, n - <span class="number">1</span>, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">pow</span>(<span class="number">10</span>, <span class="number">7</span>);</span><br><span class="line">    <span class="keyword">int</span> *arr3 = generateOrderArray(n);</span><br><span class="line">    testSearch(<span class="string">"BinarySearchRecursive"</span>, BinarySearchRecursive, arr3, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>将<strong><code>BinarySearch1.c</code></strong> <strong><code>BinarySearch2.c</code></strong> <strong><code>BinarySearchRecursive.c</code></strong> 分别改成<strong><code>.h</code></strong>，在<strong><code>Main.c</code></strong>中比较三者运行效率,二分查找<strong><code>[0,n)</code></strong>之间的所有元素 <strong><code>Main.c</code></strong>如下：</p><pre><code class="c"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"BinarySearch1.h"</span></span><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"BinarySearch2.h"</span></span><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"BinarySearchRecursive.h"</span></span><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><span class="function"></span>{    <span class="keyword">int</span> n = <span class="built_in">pow</span>(<span class="number">10</span>, <span class="number">7</span>);    <span class="keyword">int</span> *arr1 = generateOrderArray(n);    <span class="keyword">int</span> *arr2 = generateOrderArray(n);    <span class="keyword">int</span> *arr3 = generateOrderArray(n);    testSearch(<span class="string">"BinarySearch1"</span>, binarySearch1, arr1, n);    testSearch(<span class="string">"BinarySearch2"</span>, binarySearch2, arr2, n);    testSearch(<span class="string">"BinarySearchRecursive"</span>, BinarySearchRecursive, arr3, n);    <span class="keyword">return</span> <span class="number">0</span>;}</code></pre><p><strong><code>Clion运行结果</code></strong>如下：</p><div align="center" style="zoom: 90%; margin:  0px auto;"><img src="/2018/07/28/二分查找递归与非递归形式/BinarySear.png" alt="原理"></div><p><strong><code>二分查找缺点：</code></strong></p><ul><li>必须按关键字排序，有时排序也很费时。</li><li>只适用于顺序存储结构，所以插入、删除操作需大量移动元素<br>二分查找适用于一经建立就很少改动，而又经常需要查找的线性表。对于那些经常需要改动的线性表，可以采用链表存储结构，进行顺序查找</li></ul><p>可以看出递归形式与非递归形式相比的较慢         <a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/08_%E6%9F%A5%E6%89%BE/BinarySearch" target="_blank" rel="noopener">相关源码下载</a></p>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 查找 </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>快速排序实现及优化</title>
      <link href="/2018/07/23/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0%E5%8F%8A%E4%BC%98%E5%8C%96/"/>
      <url>/2018/07/23/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0%E5%8F%8A%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>本文将介绍从一路快速排序，二路快速排序，三路快速排序一步步实现以及优化的过程<a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><h2 id="Quick-Sort-基本思想"><a href="#Quick-Sort-基本思想" class="headerlink" title="Quick Sort 基本思想"></a>Quick Sort 基本思想</h2><p><strong><code>基本思想</code></strong>：每次从当前待排序序列中选取一个元素作为<strong><code>基准</code></strong>(pivot)，如下图所示，这里我们选取的元素是4，之后想办法把4(基准)挪到整个序列排好序时应该所处的位置，此时4(基准)之前的元素是小于4的，4之后的元素是大于4的，对小于4(基准)的序列和大于4(基准)的序列分别使用快速排序逐渐<strong><code>递归</code></strong>下去，完成整个排序过程。   </p><div align="center" style="zoom: 50%; margin:  0px auto;"><img src="/2018/07/23/快速排序实现及优化/QuickSort1.png" alt="原理"></div><p><strong><code>一路快速排序图片相关参数介绍：</code></strong></p><ul><li>v: 基准</li><li>l: 也就是left </li><li>r: 也就是right </li><li>i: 当前访问的元素</li><li>j: 记录大于v(基准)小于v的分界点，指向&lt;v的最后一个元素 </li></ul><h2 id="一路快速排序-原理演示"><a href="#一路快速排序-原理演示" class="headerlink" title="一路快速排序 原理演示"></a>一路快速排序 原理演示</h2><p>将把序列分成两个部分的过程称为<strong><code>Partition</code></strong>,一般将数组的第一个元素作为基准（<strong><code>基准的选取</code></strong>影响了整个程序的效率，有<a href="https://blog.csdn.net/liuyi1207164339/article/details/50827608" target="_blank" rel="noopener">三种选取方法</a>），从left + 1 位置开始遍历序列，将序列分成小于v的部分和大于v的部分  </p><div align="center" style="zoom: 50%; margin:  0px auto;"><img src="/2018/07/23/快速排序实现及优化/QuickOneWays.gif" alt=""></div><div align="center" style="zoom: 50%; margin:  0px auto;"><img src="/2018/07/23/快速排序实现及优化/QuickSort2.png" alt="原理"></div><p><strong><code>arr[left+1 ... j] &lt; v</code></strong> 这段左闭右闭的区间是小于v的，<strong><code>arr[j+1 ... i-1] &gt; v</code></strong>这段左闭右闭的区间是大于v的，如果当前所指向元素<strong><code>arr[i] &gt; v</code></strong>，则<strong><code>i++</code></strong>,动画演示如下：</p><div align="center" style="zoom: 50%; margin:  0px auto;"><img src="/2018/07/23/快速排序实现及优化/QuickSort3.gif" alt=""></div><p>如果当前所指元素<strong><code>arr[i] &lt; v</code></strong>，则<strong><code>swap(arr[i], arr[j+1])</code></strong>, 并且<strong><code>j++</code></strong>, <strong><code>i++</code></strong>,动画演示如下:</p><div align="center" style="zoom: 50%; margin:  0px auto;"><img src="/2018/07/23/快速排序实现及优化/QuickSort4.gif" alt=""></div><p><strong><code>遍历完</code></strong>整个序列是这样子的：</p><div align="center" style="zoom: 50%; margin:  0px auto;"><img src="/2018/07/23/快速排序实现及优化/QuickSort5.png" alt=""></div><p>最后要将v放到它应该在的位置,即<strong><code>swap(arr[left],arr[j])</code></strong>，动画演示如下：</p><div align="center" style="zoom: 50%; margin:  0px auto;"><img src="/2018/07/23/快速排序实现及优化/QuickSort6.gif" alt=""></div><h2 id="一路快速排序-代码实现"><a href="#一路快速排序-代码实现" class="headerlink" title="一路快速排序 代码实现"></a>一路快速排序 代码实现</h2><p>为了方便从数组描述算法的性能，我把一些辅助函数放在<strong><code>SortHelper.h</code></strong>的头文件里，内容如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ALGORITHM_SORTHELP_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALGORITHM_SORTHELP_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成有n个元素的随机数组,每个元素的随机范围为[rangeL, rangeR] 左闭右闭区间</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">generateRandomArray</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> rangeL, <span class="keyword">int</span> rangeR)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> *arr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span> &amp;&amp; rangeR &gt;= rangeL)</span><br><span class="line">    &#123;</span><br><span class="line">        arr = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);   <span class="comment">// 用malloc 分配数组 是因为不用malloc的话 随着此函数的结束 数组空间会被释放掉</span></span><br><span class="line">        srand(time(<span class="literal">NULL</span>));                       <span class="comment">// 设置随机种子</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i] = rand() % (rangeR - rangeL + <span class="number">1</span>) + rangeL;  <span class="comment">// 注意随机数所在区间区间是[rangeL, rangeR]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换两个数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> * a, <span class="keyword">int</span> * b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成近乎有序的数组  n:数据个数  swapTimes:交换次数  最多只有2*交换次数个元素无序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">generateNearlyOrderArray</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> swapTimes)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> *arr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">0</span> &amp;&amp; swapTimes &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        arr = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);</span><br><span class="line">        srand(time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; swapTimes; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x = rand() % n;</span><br><span class="line">            <span class="keyword">int</span> y = rand() % n;</span><br><span class="line">            swap(&amp;arr[x], &amp;arr[y]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试此排序方法 第四个形参传递的是方法</span></span><br><span class="line">void testSort(int * arr, int n, char * sortName , void(*sort)(int * , int ))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">clock_t</span> startTime = clock();</span><br><span class="line">    sort(arr, n);</span><br><span class="line">    <span class="keyword">clock_t</span> endTime = clock();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s cost time: %lf s\n"</span>, sortName, (<span class="keyword">double</span>) (endTime - startTime) / CLOCKS_PER_SEC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制数组</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> * <span class="title">copyArray</span><span class="params">(<span class="keyword">int</span> * arr, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> *newArr = (<span class="keyword">int</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        newArr[i] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertionSort</span><span class="params">(<span class="keyword">int</span> * arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = left + <span class="number">1</span>; i &lt;= right; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        <span class="keyword">for</span> (j = i; j &gt; left &amp;&amp; arr[j<span class="number">-1</span>] &gt; temp; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印数组内容</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span> * arr, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d  "</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//ALGORITHM_SORTHELP_H</span></span></span><br></pre></td></tr></table></figure></p><p><strong><code>QuickSortOneWays.c</code></strong>源代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SortHelp.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对arr[left...right]部分进行partition操作</span></span><br><span class="line"><span class="comment">// 返回posi,使得arr[left...p-1] &lt; arr[p] ; arr[p+1...right] &gt; arr[p]</span></span><br><span class="line"><span class="keyword">int</span> __partition(<span class="keyword">int</span> *arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">int</span> v = arr[left];                      <span class="comment">// 基准</span></span><br><span class="line">    j = left;</span><br><span class="line">    <span class="keyword">for</span> (i = left + <span class="number">1</span>; i &lt;= right; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果当前元素 比 基准小</span></span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; v)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(&amp;arr[i], &amp;arr[j + <span class="number">1</span>]);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 比基准大 i++</span></span><br><span class="line">    &#125;</span><br><span class="line">    swap(&amp;arr[left], &amp;arr[j]);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对arr[left, right]进行快速排序</span></span><br><span class="line"><span class="keyword">void</span> __QuickSortOneWays(<span class="keyword">int</span> * arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right)                          <span class="comment">// 递归结束条件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> p = __partition(arr, left, right);      <span class="comment">// 排好序后 基准所在位置的索引</span></span><br><span class="line">    __QuickSortOneWays(arr, left, p - <span class="number">1</span>);              <span class="comment">// 对左子序列进行快排</span></span><br><span class="line">    __QuickSortOneWays(arr, p + <span class="number">1</span>, right);             <span class="comment">// 对右子序列进行快排</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统一接口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSortOneWays</span><span class="params">(<span class="keyword">int</span> * arr, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __QuickSortOneWays(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 生成随机数组测试</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">100000</span>;</span><br><span class="line">    <span class="keyword">int</span> *arr = generateRandomArray(n, <span class="number">0</span>, n);    <span class="comment">// 生成n个[0,n]的随机数</span></span><br><span class="line">    testSort(arr, n, <span class="string">"QuickSortOneWays"</span>, QuickSortOneWays);</span><br><span class="line">    <span class="comment">// printArray(arr, n);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成 几乎有序的数组 最多只有2*100个元素无序</span></span><br><span class="line">    <span class="keyword">int</span> swapTimes = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> *arr1 = generateNearlyOrderArray(n, swapTimes);</span><br><span class="line">    testSort(arr1, n, <span class="string">"QuickSortOneWays"</span>, QuickSortOneWays);</span><br><span class="line">    <span class="comment">// printArray(arr1, n);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成大量重复元素数组 [0,10]</span></span><br><span class="line">    <span class="keyword">int</span> *arr2 = generateRandomArray(n, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    testSort(arr2, n, <span class="string">"QuickSortOneWays"</span>, QuickSortOneWays);</span><br><span class="line">    <span class="comment">// printArray(arr2, n);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong><code>Clion运行结果如下：</code></strong></p><div align="center" style="zoom: 90%; margin:  0px auto;"><img src="/2018/07/23/快速排序实现及优化/QuickSort7.png" alt=""></div><p>可以看出<strong>一路快速排序</strong>的<strong><code>缺点</code></strong>在有<strong><code>大量重复元素</code></strong>，<strong><code>近乎有序的序列</code></strong>,运行效率都非常慢,<strong><code>二路快速排序</code></strong>由此被引伸出来,在此一路快速排序还有两个地方可以<strong><code>优化</code></strong>：</p><ol><li>当规模小于某个值时  使用插入排序</li><li><a href="https://blog.csdn.net/liuyi1207164339/article/details/50827608" target="_blank" rel="noopener">基准的选取</a> 这里采用随机数法 <strong><code>三位取中法</code></strong> 更好一点  因为rand() 需要时间</li></ol><p><strong><code>基准选取的三种方法</code></strong><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 三数取中法  **/</span></span><br><span class="line"><span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 这里取三个数排序后，中间那个数作为枢轴</span></span><br><span class="line"><span class="keyword">if</span> (arr[left] &gt; arr[mid])</span><br><span class="line">&#123;</span><br><span class="line">    swap(&amp;arr[left], &amp;arr[mid]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (arr[left] &gt; arr[right])</span><br><span class="line">&#123;</span><br><span class="line">    swap(&amp;arr[left], &amp;arr[right]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (arr[mid] &gt; arr[right])</span><br><span class="line">&#123;</span><br><span class="line">    swap(&amp;arr[mid], &amp;arr[right]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 此时 arr[left] &lt;= arr[mid] &lt;= arr[right]*/</span></span><br><span class="line">swap(&amp;arr[left], &amp;arr[mid]);    <span class="comment">// 将基准放到最左边</span></span><br><span class="line"><span class="keyword">int</span> v = arr[left];</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 随机选取 **/</span></span><br><span class="line">swap(&amp;arr[left], &amp;arr[rand() % (right - left + <span class="number">1</span>) + left]);   <span class="comment">// 选取随机基准 与arr[left]交换</span></span><br><span class="line"><span class="keyword">int</span> v = arr[left];                                            <span class="comment">// 基准 此时基准已经时交换了的随机数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 固定基准 **/</span></span><br><span class="line"><span class="keyword">int</span> v = arr[left];</span><br></pre></td></tr></table></figure></p><p><strong><code>优化之后</code></strong>的源代码<strong><code>QuickSortOneWays1.c</code></strong>：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SortHelp.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对arr[left...right]部分进行partition操作</span></span><br><span class="line"><span class="comment">// 返回posi,使得arr[left...p-1] &lt; arr[p] ; arr[p+1...right] &gt; arr[p]</span></span><br><span class="line"><span class="keyword">int</span> __partition1(<span class="keyword">int</span> *arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="comment">/******************* 优化2 *******************/</span></span><br><span class="line">    swap(&amp;arr[left], &amp;arr[rand() % (right - left + <span class="number">1</span>) + left]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> v = arr[left];                      <span class="comment">// 基准</span></span><br><span class="line">    j = left;</span><br><span class="line">    <span class="keyword">for</span> (i = left + <span class="number">1</span>; i &lt;= right; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果当前元素 比 基准小</span></span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; v)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(&amp;arr[i], &amp;arr[j + <span class="number">1</span>]);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 比基准大 i++</span></span><br><span class="line">    &#125;</span><br><span class="line">    swap(&amp;arr[left], &amp;arr[j]);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对arr[left, right]进行快速排序</span></span><br><span class="line"><span class="keyword">void</span> __QuickSortOneWays1(<span class="keyword">int</span> * arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/************ 优化1 **********/</span></span><br><span class="line">    <span class="keyword">if</span> (right - left &lt;= <span class="number">15</span>)                      <span class="comment">// 递归结束条件</span></span><br><span class="line">    &#123;</span><br><span class="line">        InsertionSort(arr, left, right);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> p = __partition1(arr, left, right);      <span class="comment">// 排好序后 基准所在位置的索引</span></span><br><span class="line">    __QuickSortOneWays1(arr, left, p - <span class="number">1</span>);          <span class="comment">// 对左子序列进行快排</span></span><br><span class="line">    __QuickSortOneWays1(arr, p + <span class="number">1</span>, right);         <span class="comment">// 对右子序列进行快排</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统一接口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSortOneWays1</span><span class="params">(<span class="keyword">int</span> * arr, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    __QuickSortOneWays1(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 生成随机数组测试</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">100000</span>;</span><br><span class="line">    <span class="keyword">int</span> *arr = generateRandomArray(n, <span class="number">0</span>, n);    <span class="comment">// 生成n个[0,n]的随机数</span></span><br><span class="line">    testSort(arr, n, <span class="string">"QuickSortOneWays"</span>, QuickSortOneWays1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成 几乎有序的数组 最多只有2*100个元素无序</span></span><br><span class="line">    <span class="keyword">int</span> swapTimes = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> *arr1 = generateNearlyOrderArray(n, swapTimes);</span><br><span class="line">    testSort(arr1, n, <span class="string">"QuickSortOneWays"</span>, QuickSortOneWays1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成大量重复元素数组 [0,10]</span></span><br><span class="line">    <span class="keyword">int</span> *arr2 = generateRandomArray(n, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    testSort(arr2, n, <span class="string">"QuickSortOneWays"</span>,QuickSortOneWays1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong><code>优化后Clion运行结果：(数据规模100000   10万)</code></strong></p><div align="center" style="zoom: 90%; margin:  0px auto;"><img src="/2018/07/23/快速排序实现及优化/QuickSort8.png" alt=""></div><p>测试数据规模为100000(10万)，发现在<strong><code>几乎有序的数组</code></strong>中，从之前的15.284000s提高到0.022000s，效率明显<strong><code>高</code></strong>了不少（而且我们快速排序的对象只是一个数组，内部设计不是很复杂），在大量重复元素和随机数组中效率差不多，这是为什么呢？下面我用图来解释。</p><div align="center" style="zoom: 50%; margin:  0px auto;"><img src="/2018/07/23/快速排序实现及优化/QuickSort9.png" alt=""></div><p>随着<strong><code>基准选取的不同</code></strong>,快速排序的效率也受到了影响，当<strong><code>基准</code></strong>能把原序列换分成<strong><code>均匀</code></strong>的两个子序列时，每一次递归层次上比较的次数都是<strong><code>O(N)</code></strong>次，而递归的深度是 <strong><code>log2^N</code></strong> (每次都是将原始序列分一半，即一直除2)，最好的情况下时间复杂度应为<strong><code>O(Nlog2^N)</code></strong>,最坏的情况下，即基准每次是第一个元素，用因为是有序的，比基准小的元素没有，只有比基准大的元素，每次划分序列都近似于1和N-1，划分极度不均匀，像一个单链表，导致时间复杂度为<strong><code>O(N^2)</code></strong>,最坏情况下，快速排序图解如下：</p><div align="center" style="zoom: 50%; margin:  0px auto;"><img src="/2018/07/23/快速排序实现及优化/QuickSort10.png" alt=""></div><p>其中<strong><code>空间复杂度为O(log2^N)</code></strong>，递归的深度为log2^N，系统栈需要压入log2^N种状态，需要空间O(log2^N),在快排过程种定义的left,right…,都是常数级需要空间O(1),总共耗费空间O(log2^N) * O(1)。<br>这里解释下我为什么基准选取随机数：最坏的情况下，数组完全有序，每次选中最左边的元素，$ \frac{1}{n} \times \cfrac{1}{n-1} \times \cfrac{1}{n-2} \times….. \cfrac{1}{1} $ 当n无穷大时，出现最坏情况的概率接近于0</p><h2 id="二路快速排序"><a href="#二路快速排序" class="headerlink" title="二路快速排序"></a>二路快速排序</h2><p>当我在一路快速排序已经进行优化的代码中（基准选取得当解决了近乎有序数组的问题），把数组规模再<strong><code>扩大10倍</code></strong>（百万），Clion运行结果如下:</p><div align="center" style="zoom: 90%; margin:  0px auto;"><img src="/2018/07/23/快速排序实现及优化/QuickSort11.png" alt=""></div><p>从数据观察到，含有大量重复元素时，快速排序算法的复杂度似乎又退化到了<strong><code>O(N^2)</code></strong>，这是因为我们之前并没有算当前元素<strong><code>e==v</code></strong>这种情况，如图：</p><div align="center" style="zoom: 50%; margin:  0px auto;"><img src="/2018/07/23/快速排序实现及优化/QuickSort2.png" alt="原理"></div><p>假设此时我们把e==V 放在<strong><code>黄色</code></strong>区域,或者把e==v放在<strong><code>紫色</code></strong>区域,最后都会变成这样：</p><div align="center" style="zoom: 50%; margin:  0px auto;"><img src="/2018/07/23/快速排序实现及优化/QuickSort12.png" alt="原理"></div><p>partition这个过程极有可能将序列分为<strong><code>极度不平衡</code></strong>的两个子序列，而最好的情况是划分为均匀的两个序列O(log2^N)，<strong>此时的情况更接近于最坏的情况<code>O(N^2)</code></strong>， 如何解决这个问题呢？ <strong><code>二路快速排序</code></strong>由此而来.</p><p><strong><code>二路快速排序图片相关参数介绍：</code></strong></p><ul><li>v: 基准</li><li>l: 也就是left </li><li>r: 也就是right </li><li>e: 当前所指向元素</li><li>i: 记录小于v这一端即将要扫描的位置(向右)</li><li>j: 记录大于v这一端即将要扫描的位置(向左)  </li></ul><h2 id="二路快速排序-基本思想"><a href="#二路快速排序-基本思想" class="headerlink" title="二路快速排序 基本思想"></a>二路快速排序 基本思想</h2><p><strong><code>基本思想：</code></strong>首先我们从i开始向右扫描，如果当前扫描到的元素<strong><code>e &lt; v</code></strong> 则i往后移(<strong><code>i++</code></strong>)，<strong>直到</strong>碰到当前元素<strong><code>e &gt;= v</code></strong>停止。然后<strong>从j开始</strong>向左扫描,如果当前元素<strong><code>e &gt; v</code></strong>，则j往前移(<strong><code>j--</code></strong>),<strong>直到</strong>遇到 <strong><code>e &lt;= v</code></strong>，则将<strong>i,j对应的元素</strong> <strong><code>交换</code></strong>，<strong><code>i++</code></strong>，<strong><code>j--</code></strong>，再从i开始重复此过程，<strong><code>直到i，j相遇</code></strong>，然后把基准放到j对应的位置，即<strong><code>swap(arr[left, arr[j])</code></strong>代表整个序列遍历完毕，动画如下:</p><div align="center" style="zoom: 50%; margin:  0px auto;"><img src="/2018/07/23/快速排序实现及优化/QuickSort13.gif" alt=""></div><p><strong><code>实际上上面的图最后那里有点错误</code></strong>，正确的图如下：</p><div align="center" style="zoom: 62%; margin:  0px auto;"><img src="/2018/07/23/快速排序实现及优化/QuickSort14.png" alt=""></div><p>根据我们描叙的逻辑，<strong><code>橙色部分 &lt;= v</code></strong>的元素， <strong><code>紫色部分 &gt;= v</code></strong>的元素,这就解决了<strong><code>大量重复元素集中在一个区域</code></strong>的情况，<strong>之前一路快速排序=v的元素，根据自己设置的代码逻辑要么集中在黄色区域，要么就是紫色区域，造成划分的子序列不均匀</strong>,<strong><code>现在=v即可以在黄色区域，又可以在紫色区域</code></strong>，换句话来说假设i,j此时都指向等于v的元素，两者还是会交换，<strong>这样就不会造成=v的元素集中在一个区域</strong>。</p><h2 id="二路快速排序-代码实现"><a href="#二路快速排序-代码实现" class="headerlink" title="二路快速排序 代码实现"></a>二路快速排序 代码实现</h2><p><strong><code>QuickSortTwoWays.c</code></strong>源代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SortHelp.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对arr[left...right]部分进行partition操作</span></span><br><span class="line"><span class="comment">// 返回p, 使得arr[left...p-1] &lt; arr[p] ; arr[p+1...right] &gt; arr[p]</span></span><br><span class="line"><span class="keyword">int</span> __partitionTwoWays(<span class="keyword">int</span> *arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    swap(&amp;arr[left], &amp;arr[rand() % (right - left + <span class="number">1</span>) + left]);   <span class="comment">// 选取随机基准 与arr[left]交换</span></span><br><span class="line">    <span class="keyword">int</span> v = arr[left];                                            <span class="comment">// 基准 此时基准已经时交换了的随机数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// arr[left+1...i) &lt;= v; arr(j...right] &gt;= v</span></span><br><span class="line">    i = left + <span class="number">1</span>, j = right;                                      <span class="comment">// i初始化为left+1 刚好arr[left+1..i)无效 j同理</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// i 从左向右扫描 遇到比基准小的元素 i++</span></span><br><span class="line">        <span class="comment">// 注意这里的边界, arr[i] &lt; v, 不能是arr[i] &lt;= v    思考一下为什么?</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= right &amp;&amp; arr[i] &lt; v)        <span class="comment">// 写成i &lt;= j 也可以</span></span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// j 从右向左扫描 遇到比基准大的元素 j--</span></span><br><span class="line"><span class="comment">// 注意这里的边界, arr[j] &gt; v, 不能是arr[j] &gt;= v 思考？</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= left + <span class="number">1</span> &amp;&amp; arr[j] &gt; v)     <span class="comment">// 写成j &gt;= i 也可以</span></span><br><span class="line">        &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两者相遇时 按照之前的动画逻辑  相遇时 i&gt;j 用数据加图来体会</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(&amp;arr[i], &amp;arr[j]);         <span class="comment">// i,j两者对应元素交换</span></span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(&amp;arr[left], &amp;arr[j]);          <span class="comment">// 把基准放到 排好序应该在的位置 注意是与j交换不是i 画图体会</span></span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">比如数组 1,0,0, ..., 0, 0</span></span><br><span class="line"><span class="comment">a. 对于arr[i]&lt;v和arr[j]&gt;v的方式，第一次partition得到的分点是数组中间；</span></span><br><span class="line"><span class="comment">b. 对于arr[i]&lt;=v和arr[j]&gt;=v的方式，第一次partition得到的分点是数组的倒数第二个。</span></span><br><span class="line"><span class="comment">这是因为对于连续出现相等的情况，a方式会交换i和j的值；而b方式则会将连续出现的这些值归为其中一方，使得两棵子树不平衡</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对arr[left, right]进行快速排序</span></span><br><span class="line"><span class="keyword">void</span> __QuickSortTwoWays(<span class="keyword">int</span> *arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (right - left &lt;= <span class="number">15</span>)                      <span class="comment">// 递归结束条件</span></span><br><span class="line">    &#123;</span><br><span class="line">        InsertionSort(arr, left, right);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> p = __partitionTwoWays(arr, left, right);      <span class="comment">// 排好序后 基准所在位置的索引</span></span><br><span class="line">    __QuickSortTwoWays(arr, left, p - <span class="number">1</span>);              <span class="comment">// 对左子序列进行快排</span></span><br><span class="line">    __QuickSortTwoWays(arr, p + <span class="number">1</span>, right);             <span class="comment">// 对右子序列进行快排</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统一接口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSortTwoWays</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    __QuickSortTwoWays(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 生成随机数组测试</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">1000000</span>;</span><br><span class="line">    <span class="keyword">int</span> *arr = generateRandomArray(n, <span class="number">0</span>, n);           <span class="comment">// 生成n个[0,n]的随机数</span></span><br><span class="line">    testSort(arr, n, <span class="string">"QuickSortTwoWays"</span>, QuickSortTwoWays);</span><br><span class="line">    <span class="comment">// printArray(arr, n);                             // 打印元素 看是否排序成功</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成 几乎有序的数组 最多只有2*100个元素无序</span></span><br><span class="line">    <span class="keyword">int</span> swapTimes = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> *arr1 = generateNearlyOrderArray(n, swapTimes);</span><br><span class="line">    testSort(arr1, n, <span class="string">"QuickSortTwoWays"</span>, QuickSortTwoWays);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成大量重复元素数组 [0,10]</span></span><br><span class="line">    <span class="keyword">int</span> *arr2 = generateRandomArray(n, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    testSort(arr2, n, <span class="string">"QuickSortTwoWays"</span>, QuickSortTwoWays);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong><code>二路快速排序Clion运行结果：(数据规模1000000   1百万)</code></strong></p><div align="center" style="zoom: 90%; margin:  0px auto;"><img src="/2018/07/23/快速排序实现及优化/QuickSort15.png" alt=""></div><p><strong><code>优化后的一路快速排序Clion运行结果：(数据规模1000000   1百万万)</code></strong></p><div align="center" style="zoom: 100%; margin:  0px auto;"><img src="/2018/07/23/快速排序实现及优化/QuickSort11.png" alt=""></div><p>可以看出<strong><code>二路快速排序</code></strong>在处理<strong><code>随机元素</code></strong>， <strong><code>几乎有序元素</code></strong>，<strong><code>大量重复元素</code></strong>, 效率都很不错,对比一路快排尤其在含大量重复元素时，优化了不少.但是对含有大量重复元素时，还有一个更好的方法，那就是下面要介绍的<strong><code>三路快速排序</code></strong></p><h2 id="三路快速排序"><a href="#三路快速排序" class="headerlink" title="三路快速排序"></a>三路快速排序</h2><p><strong><code>基本思想</code></strong>:之前二路快速排序将序列分为<v>v两部分，现在三路快速排序将序列分为 <v =="v">v 三部分，这样分割之后在递归的过程中对于<strong><code>==v</code></strong>的部分，就可以<strong><code>不用管</code></strong>了，只需要对<strong><code>&lt;v &gt;v</code></strong>的部分进行递归排序，更有效的解决了<strong><code>含有大量重复元素的序列</code></strong></v></v></p><p><strong><code>三路快速排序图片相关参数介绍：</code></strong></p><ul><li>v: 基准</li><li>l: 也就是left </li><li>lt:指向&lt;v部分的最后一个元素</li><li>r: 也就是right </li><li>e: 当前所指向元素</li><li>i: 当前所指向元素</li><li>gt:大于v部分的第一个元素</li></ul><p>如果当前元素 <strong><code>e==v</code></strong>，直接<strong><code>i++</code></strong>，如下图所示：</p><div align="center" style="zoom: 50%; margin:  0px auto;"><img src="/2018/07/23/快速排序实现及优化/QuickSort16.gif" alt=""></div><p>如果当前元素 <strong><code>e &lt; v</code></strong>，则当前元素与==v部分的第一个元素交换，即<strong><code>swap(arr[i], arr[lt+1])</code></strong>,然后<strong><code>lt++</code></strong>, i往后移,<strong><code>i++</code></strong></p><div align="center" style="zoom: 50%; margin:  0px auto;"><img src="/2018/07/23/快速排序实现及优化/QuickSort17.gif" alt=""></div><p>如果当前元素 <strong><code>e &gt; v</code></strong>，则当前元素与&gt;v部分的前面一个交换位置，即<strong><code>swap(arr[i], arr[gt-1])</code></strong>，然后gt往左移<strong><code>gt--</code></strong>,注意此时<strong><code>i不变</code></strong>，任然指向一个没有被处理的元素，只不过这个元素是从gt-1这个位置换过来的</p><div align="center" style="zoom: 50%; margin:  0px auto;"><img src="/2018/07/23/快速排序实现及优化/QuickSort18.gif" alt=""></div><p>当遍历完整个序列后,即<strong>i和gt相遇</strong>,最后只需要将基准v放到排好序应该在的地方，即<strong><code>swap(arr[left],arr[lt])</code></strong>，这个时候就不用管==v的部分，只用对 <strong><code>&lt;v &gt;v</code></strong>的部分进行<strong><code>递归</code></strong>快速排序.</p><div align="center" style="zoom: 50%; margin:  0px auto;"><img src="/2018/07/23/快速排序实现及优化/QuickSort19.gif" alt=""></div><h2 id="三路快速排序-代码实现"><a href="#三路快速排序-代码实现" class="headerlink" title="三路快速排序 代码实现"></a>三路快速排序 代码实现</h2><p><strong><code>QuickSortThreeWays.c</code></strong>源代码如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SortHelp.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[left+1...lt] &lt; v  ; arr[lt+1...i-1] == v ; arr[gt...right] &gt;v</span></span><br><span class="line"><span class="keyword">void</span> __QuickSortThreeWays(<span class="keyword">int</span> *arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i, lt, gt;</span><br><span class="line">    <span class="keyword">if</span> (right - left &lt;= <span class="number">15</span>)                     <span class="comment">// 递归结束条件</span></span><br><span class="line">    &#123;</span><br><span class="line">        InsertionSort(arr, left, right);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    swap(&amp;arr[left], &amp;arr[rand() % (right - left + <span class="number">1</span>) + left]);      <span class="comment">// 选取随机基准 与arr[left]交换</span></span><br><span class="line">    <span class="keyword">int</span> v = arr[left];                                               <span class="comment">// 基准</span></span><br><span class="line"></span><br><span class="line">    lt = left;           <span class="comment">// 将初始lt代入 [left+1...lt] &lt; v  刚好使这个区间无效</span></span><br><span class="line">    gt = right + <span class="number">1</span>;      <span class="comment">// 同理 gt代入  [gt...right] &gt;v</span></span><br><span class="line">    i = left + <span class="number">1</span>;        <span class="comment">// 同理i代入    [lt+1...i-1] == v</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// i和gt还没遇上</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; gt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; v)               <span class="comment">// 当前元素 &lt; 基准</span></span><br><span class="line">        &#123;</span><br><span class="line">            swap(&amp;arr[i], &amp;arr[lt + <span class="number">1</span>]);</span><br><span class="line">            lt++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &gt; v)        <span class="comment">// 当前元素 &gt; 基准</span></span><br><span class="line">        &#123;</span><br><span class="line">            swap(&amp;arr[i], &amp;arr[gt - <span class="number">1</span>]);</span><br><span class="line">            gt--;                     <span class="comment">// 注意i不动</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;                             <span class="comment">// 等于基准</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时i和gt已经遇上了</span></span><br><span class="line">    swap(&amp;arr[left], &amp;arr[lt--]);</span><br><span class="line">    __QuickSortThreeWays(arr, left, lt);  </span><br><span class="line">    __QuickSortThreeWays(arr, gt, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 统一接口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSortThreeWays</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    __QuickSortThreeWays(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 生成随机数组测试</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">1000000</span>;</span><br><span class="line">    <span class="keyword">int</span> *arr = generateRandomArray(n, <span class="number">0</span>, n);    <span class="comment">// 生成n个[0,n]的随机数</span></span><br><span class="line">    testSort(arr, n, <span class="string">"QuickSortThreeWays"</span>, QuickSortThreeWays);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成 几乎有序的数组 最多只有2*100个元素无序</span></span><br><span class="line">    <span class="keyword">int</span> swapTimes = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> *arr1 = generateNearlyOrderArray(n, swapTimes);</span><br><span class="line">    testSort(arr1, n, <span class="string">"QuickSortThreeWays"</span>, QuickSortThreeWays);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成大量重复元素数组 [0,10]</span></span><br><span class="line">    <span class="keyword">int</span> *arr2 = generateRandomArray(n, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    testSort(arr2, n, <span class="string">"QuickSortThreeWays"</span>, QuickSortThreeWays);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我将一路快速排序优化后，二路快速排序，三路快速排序的源代码<strong><code>改成.h文件</code></strong>,在<strong><code>Main.c</code></strong>中比较他们分别针对<strong><code>随机序列</code></strong>、<strong><code>几乎有序的序列</code></strong>、<strong><code>含有大量重复元素的序列</code></strong>分别进行效率测试，Main.c如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SortHelp.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"QuickSortOneWays1.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"QuickSortTwoWays.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"QuickSortThreeWays.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 生成随机数组测试</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">1000000</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\ntest generateRandomArray, size = %d, random range [0, %d]\n "</span>, n, n);</span><br><span class="line">    <span class="keyword">int</span> *arr1 = generateRandomArray(n, <span class="number">0</span>, n);    <span class="comment">// 生成n个[0,n]的随机数</span></span><br><span class="line">    <span class="keyword">int</span> *arr2 = copyArray(arr1, n);</span><br><span class="line">    <span class="keyword">int</span> *arr3 = copyArray(arr2, n);</span><br><span class="line">    testSort(arr1, n, <span class="string">"QuickSortOneWays1"</span>, QuickSortOneWays1);</span><br><span class="line">    testSort(arr2, n, <span class="string">"QuickSortTwoWays"</span>, QuickSortTwoWays);</span><br><span class="line">    testSort(arr3, n, <span class="string">"QuickSortThreeWays"</span>, QuickSortThreeWays);</span><br><span class="line">    <span class="built_in">free</span>(arr1);<span class="built_in">free</span>(arr2);<span class="built_in">free</span>(arr3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成 几乎有序的数组 最多只有2*100个元素无序</span></span><br><span class="line">    <span class="keyword">int</span> swapTimes = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\ntest generateNearlyOrderArray, size = %d, sawpTimes = %d\n"</span>,n, swapTimes);</span><br><span class="line">    <span class="keyword">int</span> *arr4 = generateNearlyOrderArray(n, swapTimes);</span><br><span class="line">    <span class="keyword">int</span> *arr5 = copyArray(arr4, n);</span><br><span class="line">    <span class="keyword">int</span> *arr6 = copyArray(arr4, n);</span><br><span class="line">    testSort(arr4, n, <span class="string">"QuickSortOneWays1"</span>, QuickSortOneWays1);</span><br><span class="line">    testSort(arr5, n, <span class="string">"QuickSortTwoWays"</span>, QuickSortTwoWays);</span><br><span class="line">    testSort(arr6, n, <span class="string">"QuickSortThreeWays"</span>, QuickSortThreeWays);</span><br><span class="line">    <span class="built_in">free</span>(arr4);<span class="built_in">free</span>(arr5);<span class="built_in">free</span>(arr6);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成大量重复元素数组 [0,10]</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\ntest generateRandomArray, size = %d, random range [0, %d]\n"</span>,n, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">int</span> *arr7 = generateRandomArray(n, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">int</span> *arr8 = copyArray(arr7, n);</span><br><span class="line">    <span class="keyword">int</span> *arr9 = copyArray(arr7, n);</span><br><span class="line">    testSort(arr7, n, <span class="string">"QuickSortOneWays1"</span>, QuickSortOneWays1);</span><br><span class="line">    testSort(arr8, n, <span class="string">"QuickSortTwoWays"</span>, QuickSortTwoWays);</span><br><span class="line">    testSort(arr9, n, <span class="string">"QuickSortThreeWays"</span>, QuickSortThreeWays);</span><br><span class="line">    <span class="built_in">free</span>(arr7);<span class="built_in">free</span>(arr8);<span class="built_in">free</span>(arr9);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong><code>Clion运行结果如下：</code></strong></p><div align="center" style="zoom: 80%; margin:  0px auto;"><img src="/2018/07/23/快速排序实现及优化/QuickSort20.png" alt=""></div><p>当我在把数据规模扩大<strong><code>10倍</code></strong>(把含有大量重复元素一路快排去掉)<strong><code>Clion运行结果如下：</code></strong></p><div align="center" style="zoom: 72%; margin:  0px auto;"><img src="/2018/07/23/快速排序实现及优化/QuickSort21.png" alt=""></div><h2 id="快速排序总结"><a href="#快速排序总结" class="headerlink" title="快速排序总结"></a>快速排序总结</h2><p><strong><code>总结：</code></strong> 当测试的规模<strong><code>n越大</code></strong>,在<strong><code>随机序列</code></strong>以及<strong><code>几乎有序</code></strong>的序列<strong><code>二路快速排序效率最高</code></strong>，在含有<strong><code>大量重复元素</code></strong>时，<strong><code>三路快速排序效率最高</code></strong>，<strong>二路快速次之</strong>，<strong>一路快速排序</strong>接近退化到<strong><code>O(N^2)</code></strong><br><strong><code>时间复杂度</code></strong>：<strong><code>O(Nlog2^N)</code></strong> 指的是平均时间复杂度<br><strong><code>空间复杂度</code></strong>：<strong><code>O(log2^N)</code></strong>      递归的深度为log2^N，系统栈需要压入log2^N种状态，需要空间O(log2^N),在快排过程种定义的left,right…,都是常数级需要空间O(1),总共耗费空间O(log2^N) * O(1)。<br><strong> <code>稳定性</code> </strong>：<strong><code>不稳定的</code></strong>   &nbsp;&nbsp;&nbsp; 元素关键字相等的两个元素进行比较时会发生交换，即<strong><code>相对位置会发生变化</code></strong><br>快速排序<strong><code>最坏的情况</code></strong>即基准每次是第一个元素，用因为是有序的，比基准小的元素没有，只有比基准大的元素，每次划分序列都近似于1和N-1，划分极度不均匀，像一个单链表，导致时间复杂度为<strong><code>O(N^2)</code></strong><br>快速排序<strong><code>最好的情况</code></strong>下当<strong><code>基准</code></strong>能把原序列换分成<strong><code>均匀</code></strong>的两个子序列时，每一次递归层次上比较的次数都是<strong><code>O(N)</code></strong>次，而递归的深度是 <strong><code>log2^N</code></strong> (每次都是将原始序列分一半，即一直除2)，时间复杂度应为<strong><code>O(Nlog2^N)</code></strong></p><p><strong><code>pS:</code></strong> <a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/09_%E6%8E%92%E5%BA%8F/01-QuickSort" target="_blank" rel="noopener">相关源码链接</a></p>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C实现 </tag>
            
            <tag> 排序 </tag>
            
            <tag> 分治法，快速排序 </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
  
</search>
