<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>leetcode 15. 3Sum</title>
      <link href="/2018/09/06/leetcode-15-3Sum/"/>
      <url>/2018/09/06/leetcode-15-3Sum/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="15"><li>3Sum:<a href="https://leetcode.com/problems/3sum/description/" target="_blank" rel="noopener">题目链接</a></li></ol><p><strong><code>基本思想：</code></strong> 先对数组排序 ，用一个for循环寻找第一个元素(索引为i)，在用双指针在[i+1,nums.length-1]寻找第二个元素(索引left)，第三个元素(索引right) .<br>如果nums[i] + nums[left] + nums[right] == 0 说明找到了<br>如果nums[i] + nums[left] + nums[right] &lt; 0 left++<br>如果nums[i] + nums[left] + nums[right] &gt; 0 right–</p><h2 id="方法1："><a href="#方法1：" class="headerlink" title="方法1："></a>方法1：</h2><p>注意此方法超时了<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 时间复杂度O(Nlog2^N) + O(N^2)      排序 + 双指针</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> left = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> right = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 在[i+1,nums.length-1] 用双指针搜索另外两个元素</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[i] + nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">List</span>&lt;Integer&gt; <span class="keyword">list</span> = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                    <span class="keyword">list</span>.add(nums[i]);</span><br><span class="line">                    <span class="keyword">list</span>.add(nums[left++]);</span><br><span class="line">                    <span class="keyword">list</span>.add(nums[right--]);</span><br><span class="line">                    res.add(<span class="keyword">list</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;(res);    <span class="comment">// set用来给结果 去重</span></span><br><span class="line">        <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;(set); <span class="comment">// 将set转list</span></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(String[] args) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-4</span>&#125;;</span><br><span class="line">        <span class="keyword">List</span>&lt;<span class="keyword">List</span>&lt;Integer&gt;&gt; res = <span class="keyword">new</span> Solution1().threeSum(nums);</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="方法2：sorting-twoPoint-推荐"><a href="#方法2：sorting-twoPoint-推荐" class="headerlink" title="方法2：sorting + twoPoint(推荐)"></a>方法2：sorting + twoPoint(推荐)</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 时间复杂度O(Nlog2^N) + O(N^2)      排序 + 双指针</span></span><br><span class="line">    <span class="comment">// 优化Solution1  不需要set去重 直接在找的时候重复元素不添加到res中</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">List</span>&lt;<span class="type">List</span>&lt;<span class="type">Integer</span>&gt;&gt; threeSum(int[] nums) &#123;</span><br><span class="line">        <span class="type">List</span>&lt;<span class="type">List</span>&lt;<span class="type">Integer</span>&gt;&gt; res = new <span class="type">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Arrays</span>.<span class="built_in">sort</span>(nums);</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || (i &gt; <span class="number">0</span> &amp;&amp; nums[i] != nums[i - <span class="number">1</span>])) &#123;      <span class="comment">// 防止res中有重复的结果</span></span><br><span class="line">                int <span class="keyword">left</span> = i + <span class="number">1</span>;</span><br><span class="line">                int <span class="keyword">right</span> = nums.length - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">left</span> &lt; <span class="keyword">right</span>) &#123;</span><br><span class="line">                    int sum = nums[i] + nums[<span class="keyword">left</span>] + nums[<span class="keyword">right</span>];</span><br><span class="line">                    <span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="type">List</span>&lt;<span class="type">Integer</span>&gt; list = new <span class="type">ArrayList</span>&lt;&gt;();</span><br><span class="line">                        <span class="keyword">while</span> (<span class="keyword">left</span> &lt; <span class="keyword">right</span> &amp;&amp; nums[<span class="keyword">left</span>] == nums[<span class="keyword">left</span> + <span class="number">1</span>]) &#123;   <span class="comment">// 防止res中有重复的结果</span></span><br><span class="line">                            <span class="keyword">left</span>++;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">while</span> (<span class="keyword">left</span> &lt; <span class="keyword">right</span> &amp;&amp; nums[<span class="keyword">right</span>] == nums[<span class="keyword">right</span> - <span class="number">1</span>]) &#123; <span class="comment">// 防止res中有重复的结果</span></span><br><span class="line">                            <span class="keyword">right</span>--;</span><br><span class="line">                        &#125;</span><br><span class="line">                        list.add(nums[i]);</span><br><span class="line">                        list.add(nums[<span class="keyword">left</span>++]);</span><br><span class="line">                        list.add(nums[<span class="keyword">right</span>--]);</span><br><span class="line">                        res.add(list);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">left</span>++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">right</span>--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="type">String</span>[] args) &#123;</span><br><span class="line">        int[] nums = &#123;-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">4</span>&#125;;</span><br><span class="line">        <span class="type">List</span>&lt;<span class="type">List</span>&lt;<span class="type">Integer</span>&gt;&gt; res = new <span class="type">Solution2</span>().threeSum(nums);</span><br><span class="line">        <span class="type">System</span>.out.<span class="built_in">println</span>(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/290.%20Word%20Pattern" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java实现 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 1. Two Sum</title>
      <link href="/2018/09/05/leetcode-1-Two-Sum/"/>
      <url>/2018/09/05/leetcode-1-Two-Sum/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol><li>Two Sum:<a href="https://leetcode.com/problems/two-sum/description/" target="_blank" rel="noopener">题目链接</a></li></ol><h2 id="方法1：双指针"><a href="#方法1：双指针" class="headerlink" title="方法1：双指针"></a>方法1：双指针</h2><p><strong><code>基本思路：</code></strong> 先对数组进行排序，然后一个指针left指向数组第一个元素，一个指针right指向数组最后一个元素,将两者相加，只有可能有三种情况</p><ol><li>nums[left] + nums[right] == target      找到了</li><li>nums[left] + nums[right] &lt; target       因为数组是有序状态 将left++  及增大两者的和</li><li>nums[left] + nums[right] &gt; target       因为数组是有序状态 将right– 及减小两者的和</li></ol><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 时间复杂度O（Nlog2^N）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> <span class="keyword">target</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] tempArr = Arrays.copyOf(nums, nums.length);</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = nums[left] + nums[right];</span><br><span class="line">            <span class="keyword">if</span> (sum == <span class="keyword">target</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(sum &lt; <span class="keyword">target</span>)</span> </span>&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这里nums[left] + nums[right] 已经等于 target 但是不能直接返回 left，right 因为我们将数组排过序</span></span><br><span class="line">        <span class="comment">// 查找left</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tempArr.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tempArr[i] == nums[left]) &#123;</span><br><span class="line">                res[<span class="number">0</span>] = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 查找right</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = tempArr.length<span class="number">-1</span>; i&gt;=<span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tempArr[i] == nums[right]) &#123;</span><br><span class="line">                res[<span class="number">1</span>] = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果left &gt; right 交换</span></span><br><span class="line">        <span class="keyword">if</span> (res[<span class="number">0</span>] &gt; res[<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">int</span> t = res[<span class="number">0</span>];</span><br><span class="line">            res[<span class="number">0</span>] = res[<span class="number">1</span>];</span><br><span class="line">            res[<span class="number">1</span>] = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-3</span>, <span class="number">-4</span>, <span class="number">-5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">target</span> = <span class="number">-8</span>;</span><br><span class="line">        System.out.println(Arrays.toString(<span class="keyword">new</span> Solution1().twoSum(nums, <span class="keyword">target</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法2：二分搜索"><a href="#方法2：二分搜索" class="headerlink" title="方法2：二分搜索"></a>方法2：二分搜索</h2><p><strong><code>基本思路：</code></strong> 先将数组排序，遍历数组，当前指向元素left，如果用二分搜索法在[left, right]中发现target-nums[left]存在说明找到了</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 二分搜索非递归</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">BinarySearch1</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> <span class="keyword">target</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; <span class="keyword">target</span>) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(nums[mid] &gt; <span class="keyword">target</span>)</span> </span>&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;      <span class="comment">// 没找到：-1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分搜索递归</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">int</span> <span class="title">BinarySearch2</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> <span class="keyword">target</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">// 没找到</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; <span class="keyword">target</span>)&#123;</span><br><span class="line">            <span class="function"><span class="keyword">return</span> <span class="title">BinarySearch2</span><span class="params">(nums, mid + <span class="number">1</span>, right, <span class="keyword">target</span>)</span></span>;</span><br><span class="line">        &#125;<span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(nums[mid] &gt; <span class="keyword">target</span>)</span></span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">return</span> <span class="title">BinarySearch2</span><span class="params">(nums, left, mid - <span class="number">1</span>, <span class="keyword">target</span>)</span></span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 时间复杂度O(Nlog2^N)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> <span class="keyword">target</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] tempArr = Arrays.copyOf(nums, nums.length);</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; left &lt; nums.length; ++left) &#123;</span><br><span class="line">            right = BinarySearch1(nums, left + <span class="number">1</span>, nums.length - <span class="number">1</span>, <span class="keyword">target</span> - nums[left]);</span><br><span class="line">            <span class="keyword">if</span> (right != <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tempArr.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tempArr[i] == nums[left]) &#123;</span><br><span class="line">                res[<span class="number">0</span>] = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = tempArr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tempArr[i] == nums[right]) &#123;</span><br><span class="line">                res[<span class="number">1</span>] = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (res[<span class="number">0</span>] &gt; res[<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = res[<span class="number">0</span>];</span><br><span class="line">            res[<span class="number">0</span>] = res[<span class="number">1</span>];</span><br><span class="line">            res[<span class="number">1</span>] = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-3</span>, <span class="number">-4</span>, <span class="number">-5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">target</span> = <span class="number">-8</span>;</span><br><span class="line">        System.out.println(Arrays.toString(<span class="keyword">new</span> Solution2().twoSum(nums, <span class="keyword">target</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法3：-利用map-推荐"><a href="#方法3：-利用map-推荐" class="headerlink" title="方法3： 利用map (推荐)"></a>方法3： 利用map (推荐)</h2><p><strong><code>基本思路：</code></strong> 利用map，key存放元素的值 ，value存放元素的索引 ,遍历数组，当前指向元素索引为i，如果在数组中发现map的key中包含target - nums[i]，说明找到了.否则将该元素添加进map中，继续查找</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.<span class="keyword">HashMap</span>;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class Solution3 &#123;</span><br><span class="line">    <span class="comment">// 时间复杂度O(N)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span>[] twoSum(<span class="built_in">int</span>[] nums, <span class="built_in">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">int</span>[] res = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">2</span>];</span><br><span class="line">        Map&lt;Integer, Integer&gt; <span class="built_in">map</span> = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>.containsKey(target - nums[i])) &#123;</span><br><span class="line">                res[<span class="number">1</span>] = i;</span><br><span class="line">                res[<span class="number">0</span>] = <span class="built_in">map</span>.<span class="built_in">get</span>(target - nums[i]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">map</span>.put(nums[i], i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        <span class="built_in">int</span>[] nums = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="built_in">int</span> target = <span class="number">6</span>;</span><br><span class="line">        System.out.<span class="built_in">println</span>(Arrays.toString(<span class="keyword">new</span> Solution3().twoSum(nums, target)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>pS:</code></strong> 在查找问题 而且数组有序 要想到 二分和双指针<br><a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/1.%20Two%20Sum" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java实现 </tag>
            
            <tag> 双指针 </tag>
            
            <tag> map </tag>
            
            <tag> 二分搜索 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 451. Sort Characters By Frequency</title>
      <link href="/2018/09/05/leetcode-451-Sort-Characters-By-Frequency/"/>
      <url>/2018/09/05/leetcode-451-Sort-Characters-By-Frequency/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="451"><li>Sort Characters By Frequency:<a href="https://leetcode.com/problems/sort-characters-by-frequency/description/" target="_blank" rel="noopener">题目链接</a></li></ol><p><strong><code>图解思路：</code></strong></p><div align="center" style="zoom: 70%; margin:  0px auto;"><img src="/2018/09/05/leetcode-451-Sort-Characters-By-Frequency/leetcode_451_1.png" alt="原理"></div><h2 id="方法1：利用HashMap"><a href="#方法1：利用HashMap" class="headerlink" title="方法1：利用HashMap"></a>方法1：利用HashMap</h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.<span class="keyword">HashMap</span>;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class Solution1 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">String</span> frequencySort(<span class="keyword">String</span> s) &#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; <span class="built_in">map</span> = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">max</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 将s加入到map中 并记录次数</span></span><br><span class="line">        <span class="keyword">for</span> (Character c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="built_in">map</span>.put(c, <span class="built_in">map</span>.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">max</span> = Math.<span class="built_in">max</span>(<span class="built_in">max</span>, <span class="built_in">map</span>.<span class="built_in">get</span>(c));</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Character&gt;[] lists = <span class="keyword">new</span> List[<span class="built_in">max</span> + <span class="number">1</span>];    <span class="comment">// 建立链表数量(并不是指真正的链表)  体会+1  lists[0]并没有作用</span></span><br><span class="line">        <span class="comment">// 遍历key  将剩余的元素链到对应位置</span></span><br><span class="line">        <span class="keyword">for</span> (Character c : <span class="built_in">map</span>.keySet()) &#123;</span><br><span class="line">            <span class="built_in">int</span> index = <span class="built_in">map</span>.<span class="built_in">get</span>(c);                     <span class="comment">// 链表下标 也对应的是该字母出现的个数</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">map</span>.<span class="built_in">get</span>(c) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lists[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    lists[index] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">                lists[index].<span class="built_in">add</span>(c);</span><br><span class="line">                <span class="built_in">map</span>.put(c, <span class="built_in">map</span>.<span class="built_in">get</span>(c) - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringBuffer res = <span class="keyword">new</span> StringBuffer();          <span class="comment">// 将答案放在res中</span></span><br><span class="line">        <span class="comment">// 从lists[max] 开始往 lists[1] 遍历 (1-max中可能出现k，使得lists[k] =null 比如本例中lists[3] = null)</span></span><br><span class="line">        <span class="comment">// lists的索引是该字母出现的次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="built_in">max</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lists[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; lists[i].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                    res.<span class="built_in">append</span>(lists[i].<span class="built_in">get</span>(j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        <span class="keyword">String</span> s = <span class="string">"aaabcc"</span>;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="keyword">new</span> Solution1().frequencySort(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法2：利用Hash-Table"><a href="#方法2：利用Hash-Table" class="headerlink" title="方法2：利用Hash Table"></a>方法2：利用Hash Table</h2><p>写法跟利用HashMap的一样，只是利用的是哈希表(数组)</p><p><strong><code>int[26]</code></strong> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for Letters <strong><code>&#39;a&#39; - &#39;z&#39;</code></strong> or <strong><code>&#39;A&#39; - &#39;Z&#39;</code></strong><br><strong><code>int[128]</code></strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for <strong><code>ASCII</code></strong><br><strong><code>int[256]</code></strong> &nbsp;&nbsp;&nbsp;&nbsp;  for <strong><code>Extended ASCII</code></strong></p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class Solution2 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">String</span> frequencySort(<span class="keyword">String</span> s) &#123;</span><br><span class="line">        <span class="built_in">int</span>[] hash = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">max</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Character c : s.toCharArray()) &#123;</span><br><span class="line">            hash[c]++;</span><br><span class="line">            <span class="built_in">max</span> = Math.<span class="built_in">max</span>(<span class="built_in">max</span>, hash[c]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Character&gt;[] buckets = <span class="keyword">new</span> List[<span class="built_in">max</span> + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; hash.length; ++i) &#123;</span><br><span class="line">            <span class="built_in">int</span> index = hash[i];</span><br><span class="line">            <span class="keyword">while</span> (hash[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (buckets[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    buckets[index] = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">                buckets[index].<span class="built_in">add</span>((<span class="built_in">char</span>) i);</span><br><span class="line">                hash[i]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringBuffer res = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="built_in">max</span>; i &gt; <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (buckets[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; buckets[i].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                    res.<span class="built_in">append</span>(buckets[i].<span class="built_in">get</span>(j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        <span class="keyword">String</span> s = <span class="string">"aaaabcc"</span>;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="keyword">new</span> Solution2().frequencySort(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/451.%20Sort%20Characters%20By%20Frequency" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java实现 </tag>
            
            <tag> map </tag>
            
            <tag> Hash Table </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 205. Isomorphic Strings</title>
      <link href="/2018/09/05/leetcode-205-Isomorphic-Strings/"/>
      <url>/2018/09/05/leetcode-205-Isomorphic-Strings/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="205"><li>Isomorphic Strings:<a href="https://leetcode.com/problems/isomorphic-strings/description/" target="_blank" rel="noopener">题目链接</a></li></ol><h2 id="方法1：map"><a href="#方法1：map" class="headerlink" title="方法1：map"></a>方法1：map</h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.<span class="keyword">HashMap</span>;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class Solution1 &#123;</span><br><span class="line">    <span class="comment">// 时间复杂度O(N)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">boolean</span> isIsomorphic(<span class="keyword">String</span> s, <span class="keyword">String</span> t) &#123;</span><br><span class="line">        Map&lt;Character, Character&gt; <span class="built_in">map</span> = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (s.length() != t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            <span class="built_in">char</span> chs = s.charAt(i);</span><br><span class="line">            <span class="built_in">char</span> cht = t.charAt(i);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>.containsKey(chs)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">map</span>.<span class="built_in">get</span>(chs).equals(cht)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">map</span>.containsValue(cht))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">map</span>.put(chs, cht);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        <span class="keyword">String</span> s = <span class="string">"egg"</span>;</span><br><span class="line">        <span class="keyword">String</span> t = <span class="string">"add"</span>;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="keyword">new</span> Solution1().isIsomorphic(s, t));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/205.%20Isomorphic%20Strings" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java实现 </tag>
            
            <tag> map </tag>
            
            <tag> Hash Table </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 290. Word Pattern</title>
      <link href="/2018/09/04/leetcode-290-Word-Pattern/"/>
      <url>/2018/09/04/leetcode-290-Word-Pattern/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="290"><li>Word Pattern:<a href="https://leetcode.com/problems/word-pattern/description/" target="_blank" rel="noopener">题目链接</a></li></ol><h2 id="方法1：HashMap"><a href="#方法1：HashMap" class="headerlink" title="方法1：HashMap"></a>方法1：HashMap</h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.<span class="keyword">HashMap</span>;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class Solution1 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">boolean</span> wordPattern(<span class="keyword">String</span> pattern, <span class="keyword">String</span> <span class="built_in">str</span>) &#123;</span><br><span class="line">        Map&lt;Character, <span class="keyword">String</span>&gt; <span class="built_in">map</span> = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">String</span>[] res = <span class="built_in">str</span>.<span class="built_in">split</span>(<span class="string">" "</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pattern.length() != res.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;pattern.length();++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>.containsKey(pattern.charAt(i)))&#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">map</span>.<span class="built_in">get</span>(pattern.charAt(i)).equals(res[i])) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">map</span>.containsValue(res[i]))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">map</span>.put(pattern.charAt(i), res[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        <span class="keyword">String</span> pattern = <span class="string">"abba"</span>;</span><br><span class="line">        <span class="keyword">String</span> <span class="built_in">str</span> = <span class="string">"dog cat cat dog"</span>;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="keyword">new</span> Solution1().wordPattern(pattern, <span class="built_in">str</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/290.%20Word%20Pattern" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java实现 </tag>
            
            <tag> map </tag>
            
            <tag> Hash Table </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 202. Happy Number</title>
      <link href="/2018/09/04/leetcode-202-Happy-Number/"/>
      <url>/2018/09/04/leetcode-202-Happy-Number/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="202"><li>Happy Number:<a href="https://leetcode.com/problems/happy-number/description/" target="_blank" rel="noopener">题目链接</a></li></ol><h2 id="方法1：利用HashSet"><a href="#方法1：利用HashSet" class="headerlink" title="方法1：利用HashSet"></a>方法1：利用HashSet</h2><p><strong><code>基本思路：</code></strong>首先这个题目是要将数字的每一位分离出来，用sum记录此次该数每个数字的平方和是多少，如果该数重复出现及sum重复，说明肯定不是happy number，用HashSet来记录sum</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> &#123;</span></span><br><span class="line">    <span class="comment">// 时间复杂度 O(N^2)  空间复杂度(m)  m:set的大小</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        Set&lt;Integer&gt; <span class="built_in">set</span> = <span class="keyword">new</span> HashSet&lt;&gt;();       <span class="comment">// 记录sum</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 分离数位</span></span><br><span class="line">            <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> k = n % <span class="number">10</span>;</span><br><span class="line">                sum += Math.<span class="built_in">pow</span>(k, <span class="number">2</span>);</span><br><span class="line">                n /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            n = sum;</span><br><span class="line">            <span class="comment">// 如果sum == 1 说明是happy number</span></span><br><span class="line">            <span class="keyword">if</span> (sum == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果set包含sum 说明不是</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">set</span>.contains(sum))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;  <span class="comment">// set不含sum 添加进set 继续</span></span><br><span class="line">                <span class="built_in">set</span>.add(sum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">19</span>;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution1().isHappy(n));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/202.%20Happy%20Number" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java实现 </tag>
            
            <tag> Hash Table </tag>
            
            <tag> set </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 350. Intersection of Two Arrays II</title>
      <link href="/2018/09/01/leetcode-350-Intersection-of-Two-Arrays-II/"/>
      <url>/2018/09/01/leetcode-350-Intersection-of-Two-Arrays-II/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="350"><li>Intersection of Two Arrays II:<a href="https://leetcode.com/problems/intersection-of-two-arrays-ii/description/" target="_blank" rel="noopener">题目链接</a></li></ol><h2 id="方法1：利用map"><a href="#方法1：利用map" class="headerlink" title="方法1：利用map"></a>方法1：利用map</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> &#123;</span></span><br><span class="line">    <span class="comment">// 时间复杂度O(N)   利用map 跟个数有关</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; <span class="built_in">map</span> = <span class="keyword">new</span> HashMap&lt;&gt;(); <span class="comment">// 用来存放 nums2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x:nums2)&#123;                           <span class="comment">// 将nums2添加到map</span></span><br><span class="line">            <span class="built_in">map</span>.put(x, <span class="built_in">map</span>.getOrDefault(x, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 遍历nums1 看map中是否含有此元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;nums1.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>.containsKey(nums1[i]) &amp;&amp; <span class="built_in">map</span>.get(nums1[i]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">list</span>.add(nums1[i]);</span><br><span class="line">                <span class="built_in">map</span>.put(nums1[i], <span class="built_in">map</span>.get(nums1[i]) - <span class="number">1</span>);    <span class="comment">// 该元素对应次数-1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将list转为数组</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="built_in">list</span>.size()];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x: <span class="built_in">list</span>)&#123;</span><br><span class="line">            res[index++] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] nums2 = &#123;<span class="number">2</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] res = (<span class="keyword">new</span> Solution1()).intersection(nums1, nums2);</span><br><span class="line">        System.out.println(Arrays.toString(res));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法2-双指针"><a href="#方法2-双指针" class="headerlink" title="方法2:双指针"></a>方法2:双指针</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> &#123;</span></span><br><span class="line">    <span class="comment">// 时间复杂度O(nlog2^n)   双指针</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] intersection(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="comment">// 先对两个数组 进行排序</span></span><br><span class="line">        Arrays.sort(nums1);</span><br><span class="line">        Arrays.sort(nums2);</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; <span class="built_in">list</span> = <span class="keyword">new</span> ArrayList&lt;&gt;();  <span class="comment">// 存放答案</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; nums1.length &amp;&amp; j &lt; nums2.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i] == nums2[j]) &#123;</span><br><span class="line">                <span class="built_in">list</span>.add(nums1[i]);</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[i] &lt; nums2[j]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将set转为数组</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="built_in">list</span>.size()];</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Integer x : <span class="built_in">list</span>) &#123;</span><br><span class="line">            res[index++] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] nums2 = &#123;<span class="number">2</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] res = (<span class="keyword">new</span> Solution1()).intersection(nums1, nums2);</span><br><span class="line">        System.out.println(Arrays.toString(res));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/349.%20Intersection%20of%20Two%20Arrays" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java实现 </tag>
            
            <tag> 双指针 </tag>
            
            <tag> map </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 349. Intersection of Two Arrays</title>
      <link href="/2018/08/31/leetcode-349-Intersection-of-Two-Arrays/"/>
      <url>/2018/08/31/leetcode-349-Intersection-of-Two-Arrays/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="349"><li>Intersection of Two Arrays:<a href="https://leetcode.com/problems/intersection-of-two-arrays/description/" target="_blank" rel="noopener">题目链接</a></li></ol><h2 id="方法1-利用set"><a href="#方法1-利用set" class="headerlink" title="方法1:利用set"></a>方法1:利用set</h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class Solution1 &#123;</span><br><span class="line">    <span class="comment">// 时间复杂度O(N)  空间复杂度O(N):两个set+res[]</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span>[] intersection(<span class="built_in">int</span>[] nums1, <span class="built_in">int</span>[] nums2) &#123;</span><br><span class="line">        Set&lt;Integer&gt; <span class="built_in">set</span> = <span class="keyword">new</span> HashSet&lt;&gt;();        <span class="comment">// 用来存放 nums2</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> x:nums2)&#123;                         <span class="comment">// 将nums2添加到set(此时nums2的重复元素被过滤)</span></span><br><span class="line">            <span class="built_in">set</span>.<span class="built_in">add</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;Integer&gt; resultSet = <span class="keyword">new</span> HashSet&lt;&gt;();  <span class="comment">// 存放两数组之间的公共元素(重复的会被过滤)</span></span><br><span class="line">        <span class="comment">// 遍历nums1 看set中是否含有此元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i =<span class="number">0</span>; i&lt;nums1.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">set</span>.contains(nums1[i])) &#123;</span><br><span class="line">                resultSet.<span class="built_in">add</span>(nums1[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将resultSet转为数组</span></span><br><span class="line">        <span class="built_in">int</span>[] res = <span class="keyword">new</span> <span class="built_in">int</span>[resultSet.<span class="built_in">size</span>()];</span><br><span class="line">        <span class="built_in">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> x: resultSet)&#123;</span><br><span class="line">            res[index++] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        <span class="built_in">int</span>[] nums1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="built_in">int</span>[] nums2 = &#123;<span class="number">2</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="built_in">int</span>[] res = (<span class="keyword">new</span> Solution1()).intersection(nums1, nums2);</span><br><span class="line">        System.out.<span class="built_in">println</span>(Arrays.toString(res));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法2：双指针"><a href="#方法2：双指针" class="headerlink" title="方法2：双指针"></a>方法2：双指针</h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class Solution2 &#123;</span><br><span class="line">    <span class="comment">// 时间复杂度O(nlog2^n)   双指针</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span>[] intersection(<span class="built_in">int</span>[] nums1, <span class="built_in">int</span>[] nums2) &#123;</span><br><span class="line">        <span class="comment">// 先对两个数组 进行排序</span></span><br><span class="line">        Arrays.<span class="built_in">sort</span>(nums1);</span><br><span class="line">        Arrays.<span class="built_in">sort</span>(nums2);</span><br><span class="line"></span><br><span class="line">        Set&lt;Integer&gt; <span class="built_in">set</span> = <span class="keyword">new</span> HashSet&lt;&gt;(); <span class="comment">// 存放答案(会过滤掉重复的元素)</span></span><br><span class="line">        <span class="built_in">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; nums1.length &amp;&amp; j &lt; nums2.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i] == nums2[j]) &#123;</span><br><span class="line">                <span class="built_in">set</span>.<span class="built_in">add</span>(nums1[i]);</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums1[i] &lt; nums2[j]) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将set转为数组</span></span><br><span class="line">        <span class="built_in">int</span>[] res = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="built_in">set</span>.<span class="built_in">size</span>()];</span><br><span class="line">        <span class="built_in">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Integer x : <span class="built_in">set</span>) &#123;</span><br><span class="line">            res[index++] = x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        <span class="built_in">int</span>[] nums1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="built_in">int</span>[] nums2 = &#123;<span class="number">2</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="built_in">int</span>[] res = (<span class="keyword">new</span> Solution1()).intersection(nums1, nums2);</span><br><span class="line">        System.out.<span class="built_in">println</span>(Arrays.toString(res));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/349.%20Intersection%20of%20Two%20Arrays" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java实现 </tag>
            
            <tag> 双指针 </tag>
            
            <tag> set </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>双指针总结篇</title>
      <link href="/2018/08/31/%E5%8F%8C%E6%8C%87%E9%92%88%E6%80%BB%E7%BB%93%E7%AF%87/"/>
      <url>/2018/08/31/%E5%8F%8C%E6%8C%87%E9%92%88%E6%80%BB%E7%BB%93%E7%AF%87/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>双指针这种思想对于解决数组类问题是很重要的，一般来讲可以将时间复杂度控制在<strong><code>O(N)</code></strong>,我将其分为三类，<font color="red">双指针之快慢指针、双指针之对撞指针、双指针之滑动窗口</font>。注意这里的指针并不是c语言里面的指针，而是<font color="deeppink">数组下标(索引)</font><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><h2 id="双指针之快慢指针"><a href="#双指针之快慢指针" class="headerlink" title="双指针之快慢指针"></a>双指针之快慢指针</h2><p><strong><code>基本思想：</code></strong>快指针fast,慢指针slow都指向数组第一个元素，其中fast用来遍历整个数组，一旦fast发现满足条件的元素,就与slow指向元素进行某种操作(交换，赋值等等)，slow往后移动，直至快指针fast遍历完整个数组,时间复杂度O(N) </p><p><strong><code>应用场景：</code></strong></p><ol><li>in place (原地解决问题 不需要额外的空间)</li><li>在数组中寻找特定的元素(大于等于小于target,或在某个范围内等等)，将其放到[0,slow)这个左闭右开的区间</li><li>在数组<font color="red">有序</font>的状态 对数组进行去重(去重复元素,不需要额外的空间)</li><li>待补充</li></ol><table><thead><tr><th style="text-align:left">题目</th><th style="text-align:center">类型</th><th style="text-align:left">题目链接</th><th style="text-align:center">详细解答</th></tr></thead><tbody><tr><td style="text-align:left">283.Move Zeroes</td><td style="text-align:center">双指针之快慢指针</td><td style="text-align:left"><a href="https://leetcode.com/problems/move-zeroes/description/" target="_blank" rel="noopener">点击这里</a></td><td style="text-align:center"><a href="https://xerdemo.github.io/2018/08/13/LeetCode%E8%A7%A3%E9%A2%98/leetcode-283-Move-Zeroes/">点击这里</a></td></tr><tr><td style="text-align:left">27.Remove Element</td><td style="text-align:center">双指针之快慢指针</td><td style="text-align:left"><a href="https://leetcode.com/problems/remove-element/description/" target="_blank" rel="noopener">点击这里</a></td><td style="text-align:center"><a href="https://xerdemo.github.io/2018/08/14/LeetCode%E8%A7%A3%E9%A2%98/leetcode-27-Remove-Element/">点击这里</a></td></tr><tr><td style="text-align:left">26.Remove Duplicates from Sorted Array</td><td style="text-align:center">双指针之快慢指针</td><td style="text-align:left"><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/" target="_blank" rel="noopener">点击这里</a></td><td style="text-align:center"><a href="https://xerdemo.github.io/2018/08/14/LeetCode%E8%A7%A3%E9%A2%98/leetcode-26-Remove-Duplicates-from-Sorted-Array/">点击这里</a></td></tr><tr><td style="text-align:left">80.Remove Duplicates from Sorted Array II</td><td style="text-align:center">双指针之快慢指针</td><td style="text-align:left"><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/description/" target="_blank" rel="noopener">点击这里</a></td><td style="text-align:center"><a href="https://xerdemo.github.io/2018/08/14/LeetCode%E8%A7%A3%E9%A2%98/leetcode-80-Remove-Duplicates-from-Sorted-Array-II/">点击这里</a></td></tr></tbody></table><h2 id="双指针之对撞指针"><a href="#双指针之对撞指针" class="headerlink" title="双指针之对撞指针"></a>双指针之对撞指针</h2><p><strong><code>基本思想：</code></strong> 两个指针i，j，i指向数组最左边,j指向数组最右边，i从左往右遍历，j从右往左遍历，当满足某某条件时，进行某某操作，直至两者相遇,时间复杂度<strong><code>O(N)</code></strong></p><p><strong><code>应用场景：</code></strong></p><ol><li>判断一个字符串是否对称、回文数,翻转字符串(也可以交换特定位置的字符)</li><li>数组有序的状态，看哪两数相加，减等等，其结果是否大于等于小于target（N sum类问题）</li><li>二路快速排序</li><li>待补充</li></ol><table><thead><tr><th style="text-align:left">题目</th><th style="text-align:center">类型</th><th style="text-align:left">题目链接</th><th style="text-align:center">详细解答</th></tr></thead><tbody><tr><td style="text-align:left">167. Two Sum II - Input array is sorted</td><td style="text-align:center">双指针之对撞指针</td><td style="text-align:left"><a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/" target="_blank" rel="noopener">点击这里</a></td><td style="text-align:center"><a href="https://xerdemo.github.io/2018/08/19/LeetCode%E8%A7%A3%E9%A2%98/leetcode-167-Two-Sum-II-Input-array-is-sorted/">点击这里</a></td></tr><tr><td style="text-align:left">125. Valid Palindrome</td><td style="text-align:center">双指针之对撞指针</td><td style="text-align:left"><a href="https://leetcode.com/problems/valid-palindrome/description/" target="_blank" rel="noopener">点击这里</a></td><td style="text-align:center"><a href="https://xerdemo.github.io/2018/08/19/leetcode-125-Valid-Palindrome/">点击这里</a></td></tr><tr><td style="text-align:left">344. Reverse String</td><td style="text-align:center">双指针之对撞指针</td><td style="text-align:left"><a href="https://leetcode.com/problems/reverse-string/description/" target="_blank" rel="noopener">点击这里</a></td><td style="text-align:center"><a href="https://xerdemo.github.io/2018/08/20/leetcode-344-Reverse-String/">点击这里</a></td></tr><tr><td style="text-align:left">345. Reverse Vowels of a String</td><td style="text-align:center">双指针之对撞指针</td><td style="text-align:left"><a href="https://leetcode.com/problems/reverse-vowels-of-a-string/description/" target="_blank" rel="noopener">点击这里</a></td><td style="text-align:center"><a href="https://xerdemo.github.io/2018/08/21/leetcode-345-Reverse-Vowels-of-a-String/">点击这里</a></td></tr><tr><td style="text-align:left">11. Container With Most Water</td><td style="text-align:center">双指针之对撞指针</td><td style="text-align:left"><a href="https://leetcode.com/problems/container-with-most-water/description/" target="_blank" rel="noopener">点击这里</a></td><td style="text-align:center"><a href="https://xerdemo.github.io/2018/08/21/leetcode-11-Container-With-Most-Water/">点击这里</a></td></tr></tbody></table><h2 id="双指针之滑动窗口"><a href="#双指针之滑动窗口" class="headerlink" title="双指针之滑动窗口"></a>双指针之滑动窗口</h2><p><strong><code>基本思想：</code></strong>初始时指针left，right都指向数组第一个元素,维持[left,right)这个窗口，                </p><table><thead><tr><th style="text-align:left">题目</th><th style="text-align:center">类型</th><th style="text-align:left">题目链接</th><th style="text-align:center">详细解答</th></tr></thead><tbody><tr><td style="text-align:left">209. Minimum Size Subarray Sum</td><td style="text-align:center">双指针之滑动窗口</td><td style="text-align:left"><a href="https://leetcode.com/problems/minimum-size-subarray-sum/description/" target="_blank" rel="noopener">点击这里</a></td><td style="text-align:center"><a href="https://xerdemo.github.io/2018/08/21/leetcode-209-Minimum-Size-Subarray-Sum/">点击这里</a></td></tr><tr><td style="text-align:left">3. Longest Substring Without Repeating Characters</td><td style="text-align:center">双指针之滑动窗口</td><td style="text-align:left"><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/description/" target="_blank" rel="noopener">点击这里</a></td><td style="text-align:center"><a href="https://xerdemo.github.io/2018/08/22/leetcode-3-Longest-Substring-Without-Repeating-Characters/">点击这里</a></td></tr><tr><td style="text-align:left">438. Find All Anagrams in a String</td><td style="text-align:center">双指针之滑动窗口</td><td style="text-align:left"><a href="https://leetcode.com/problems/find-all-anagrams-in-a-string/description/" target="_blank" rel="noopener">点击这里</a></td><td style="text-align:center"><a href="https://xerdemo.github.io/2018/08/24/leetcode-438-Find-All-Anagrams-in-a-String/">点击这里</a></td></tr><tr><td style="text-align:left">76. Minimum Window Substring</td><td style="text-align:center">双指针之滑动窗口</td><td style="text-align:left"><a href="https://leetcode.com/problems/minimum-window-substring/description/" target="_blank" rel="noopener">点击这里</a></td><td style="text-align:center"><a href="https://xerdemo.github.io/2018/08/25/leetcode-76-Minimum-Window-Substring/">点击这里</a></td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>跟数组有关的时候 并且是查找类型 要想到双指针和二分法</p>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java实现 </tag>
            
            <tag> 双指针 </tag>
            
            <tag> 数组问题 </tag>
            
            <tag> Thinking </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 76 Minimum Window Substring</title>
      <link href="/2018/08/25/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-76-Minimum-Window-Substring/"/>
      <url>/2018/08/25/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-76-Minimum-Window-Substring/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="76"><li>Minimum Window Substring:<a href="https://leetcode.com/problems/minimum-window-substring/description/" target="_blank" rel="noopener">题目链接</a></li></ol><h2 id="方法1：双指针之滑动窗口"><a href="#方法1：双指针之滑动窗口" class="headerlink" title="方法1：双指针之滑动窗口"></a>方法1：双指针之滑动窗口</h2><blockquote><p>有一个关于此类问题的模板链接:<a href="https://leetcode.com/problems/minimum-window-substring/discuss/26808/Here-is-a-10-line-template-that-can-solve-most-&#39;substring&#39;-problems" target="_blank" rel="noopener">点击这里</a></p></blockquote><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class Solution1 &#123;</span><br><span class="line">    <span class="comment">// 时间复杂度O(N)   双指针之滑动窗口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">String</span> minWindow(<span class="keyword">String</span> s, <span class="keyword">String</span> t) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] hash = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];              <span class="comment">// 建立哈希表  hash['a'] 就是hash[97]</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;                <span class="comment">// [left,right)  滑动窗口区间为左闭右开区间</span></span><br><span class="line">        <span class="comment">// 将t中字符出现的次数 加入hash[]</span></span><br><span class="line">        <span class="built_in">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); ++i) &#123;</span><br><span class="line">            hash[t.charAt(i)]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> minLength = Integer.MAX_VALUE;      <span class="comment">// 当找到符合答案的滑动窗口时 记录其窗口长度</span></span><br><span class="line">        <span class="keyword">int</span> minStart = <span class="number">0</span>;                       <span class="comment">// 当找到符合答案的滑动窗口时 记录其起始位置</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;                          <span class="comment">// 计数器</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">            <span class="comment">// 不管if()里面条件是否满足  right指向的当前元素始终频率--（所以只要不是t中的元素出现的频率肯定是负数）  right++</span></span><br><span class="line">            <span class="comment">// 如果right指向当前的元素频率&gt;=1 此元素也在t中  count++</span></span><br><span class="line">            <span class="built_in">if</span> (hash[s.charAt(right++)]-- &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// t中的元素全部找到后</span></span><br><span class="line">            <span class="built_in">while</span> (count == t.length())&#123;</span><br><span class="line">                <span class="comment">// 更新满足条件的最小滑动区间</span></span><br><span class="line">                <span class="built_in">if</span> (right - left &lt; minLength)&#123;</span><br><span class="line">                    minLength = right - left;</span><br><span class="line">                    minStart = left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 不管if()里面条件是否满足 left指向的当前元素始终频率++(不是t中的元素频率最多只能加到0,不会超过0)  left++</span></span><br><span class="line">                <span class="comment">// 如果left指向当前的元素频率 = 0  此元素也在t中   count--</span></span><br><span class="line">                <span class="built_in">if</span> (hash[s.charAt(left++)]++&gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    count--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> minLength == Integer.MAX_VALUE ? <span class="string">""</span> : s.substring(minStart, minStart + minLength);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        <span class="keyword">String</span> s = <span class="string">"ADOBECODEBANC"</span>;</span><br><span class="line">        <span class="keyword">String</span> t = <span class="string">"ABC"</span>;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="keyword">new</span> Solution1().minWindow(s, t));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/76.%20Minimum%20Window%20Substring" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java实现 </tag>
            
            <tag> 数组问题 </tag>
            
            <tag> 双指针之滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 438 Find All Anagrams in a String</title>
      <link href="/2018/08/24/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-438-Find-All-Anagrams-in-a-String/"/>
      <url>/2018/08/24/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-438-Find-All-Anagrams-in-a-String/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="438"><li>Find All Anagrams in a String:<a href="https://leetcode.com/problems/find-all-anagrams-in-a-string/description/" target="_blank" rel="noopener">题目链接</a></li></ol><h2 id="方法1：双指针之滑动窗口"><a href="#方法1：双指针之滑动窗口" class="headerlink" title="方法1：双指针之滑动窗口"></a>方法1：双指针之滑动窗口</h2><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 时间复杂度O(N)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">List</span>&lt;<span class="type">Integer</span>&gt; findAnagrams(<span class="type">String</span> s, <span class="type">String</span> p) &#123;</span><br><span class="line">        <span class="type">List</span>&lt;<span class="type">Integer</span>&gt; res = new <span class="type">ArrayList</span>&lt;&gt;();</span><br><span class="line">        int <span class="keyword">left</span> = <span class="number">0</span>, <span class="keyword">right</span> = <span class="number">0</span>;      <span class="comment">// [left, right)  滑动窗口</span></span><br><span class="line">        int[] hash = new int[<span class="number">128</span>];    <span class="comment">// 声明哈希表  128：ASCII  256:扩展的ASCII</span></span><br><span class="line">        <span class="comment">// hash中存放p中字符出现的次数</span></span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="number">0</span>; i&lt;p.length();++i) &#123;</span><br><span class="line">            hash[p.charAt(i)]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int <span class="built_in">count</span> = <span class="number">0</span>;                <span class="comment">// 计数器</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">right</span> &lt; s.length()) &#123;</span><br><span class="line">            <span class="comment">// 每次都将当前遍历的元素次数-1 ,那么不属于p里面的字符 出现的频率肯定是负数</span></span><br><span class="line">            <span class="comment">// 当发现当前元素频率大于等于1 说明当前元素是p中的某一个  计数器++</span></span><br><span class="line">            <span class="keyword">if</span> (hash[s.charAt(<span class="keyword">right</span>++)]-- &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">count</span>++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果计数器等于p的长度 说明找到了符合条件的答案</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">count</span> == p.length())&#123;</span><br><span class="line">                res.add(<span class="keyword">left</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果发现left所在位置元素的频率&gt;=0 说明是p中的某个元素  (不是p中的元素在第一个if时 频率已经是复述了)</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">right</span> -<span class="keyword">left</span> == p.length() &amp;&amp; hash[s.charAt(<span class="keyword">left</span>++)]++ &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="built_in">count</span>--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="type">String</span>[] args) &#123;</span><br><span class="line">        <span class="type">String</span> s = <span class="string">"cbaebabacd"</span>;</span><br><span class="line">        <span class="type">String</span> p = <span class="string">"abc"</span>;</span><br><span class="line">        <span class="type">System</span>.out.<span class="built_in">println</span>(new <span class="type">Solution1</span>().findAnagrams(s, p));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外一种用map的方法，但是效率不知道为什么非常低<br><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution2 &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; findAnagrams(<span class="built_in">String</span> s, <span class="built_in">String</span> p) &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Map&lt;Character, Integer&gt; ms = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;Character, Integer&gt; mp = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Vector v = <span class="keyword">new</span> Vector();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i =<span class="number">0</span>; i&lt;p.length();++i) &#123;</span><br><span class="line">            mp.put(p.charAt(i), mp.getOrDefault(p.charAt(i), <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>, <span class="built_in">right</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">right</span> &lt; s.length())&#123;</span><br><span class="line">            ms.put(s.charAt(<span class="built_in">right</span>), ms.getOrDefault(s.charAt(<span class="built_in">right</span>), <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">right</span>++;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">right</span> - <span class="built_in">left</span> == p.length())&#123;</span><br><span class="line">                <span class="keyword">if</span> (ms.equals(mp)) &#123;</span><br><span class="line">                    list.add(<span class="built_in">left</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                char ch = s.charAt(<span class="built_in">left</span>);</span><br><span class="line">                <span class="keyword">if</span> (ms.<span class="keyword">get</span>(ch) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                    ms.put(ch, ms.<span class="keyword">get</span>(ch)<span class="number">-1</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    ms.remove(ch);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">left</span>++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> static void main(<span class="built_in">String</span>[] args) &#123;</span><br><span class="line">        <span class="built_in">String</span> s = <span class="string">"cbaebabacd"</span>;</span><br><span class="line">        <span class="built_in">String</span> p = <span class="string">"abc"</span>;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution2().findAnagrams(s, p));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/438.%20Find%20All%20Anagrams%20in%20a%20String" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java实现 </tag>
            
            <tag> 数组问题 </tag>
            
            <tag> 双指针之滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 3 Longest Substring Without Repeating Characters</title>
      <link href="/2018/08/22/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-3-Longest-Substring-Without-Repeating-Characters/"/>
      <url>/2018/08/22/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-3-Longest-Substring-Without-Repeating-Characters/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="3"><li>Longest Substring Without Repeating Characters:<a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/description/" target="_blank" rel="noopener">题目链接</a></li></ol><h2 id="方法1：暴力解法"><a href="#方法1：暴力解法" class="headerlink" title="方法1：暴力解法"></a>方法1：暴力解法</h2><p>利用hashset来判断在[i,j]区间内有无重复元素<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class Solution1 &#123;</span><br><span class="line">    <span class="comment">// 时间复杂度O(N^2)    空间复杂度O(set的大小*s的大小)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> lengthOfLongestSubstring(<span class="keyword">String</span> s) &#123;</span><br><span class="line">        <span class="built_in">int</span> res = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            <span class="comment">// 创建hashset判断[i,j]之间是否有重复元素</span></span><br><span class="line">            Set&lt;Character&gt; <span class="built_in">set</span> = <span class="keyword">new</span> HashSet();</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = i; j &lt; s.length(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">set</span>.contains(s.charAt(j))) &#123;    <span class="comment">// 如果有重复元素 终止当前循环 判断[i+1,j]之间是否有重复元素</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">set</span>.<span class="built_in">add</span>(s.charAt(j));               <span class="comment">// 如果set中不含当前元素 将当前元素添加进set中</span></span><br><span class="line">                res = Math.<span class="built_in">max</span>(j - i + <span class="number">1</span>, res);     <span class="comment">// 更新结果</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == Integer.MIN_VALUE ? <span class="number">0</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        <span class="keyword">String</span> s = <span class="string">"abcabcbb"</span>;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="keyword">new</span> Solution1().lengthOfLongestSubstring(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="方法2：双指针之滑动窗口"><a href="#方法2：双指针之滑动窗口" class="headerlink" title="方法2：双指针之滑动窗口"></a>方法2：双指针之滑动窗口</h2><p>维持一个窗口<strong><code>[left,right)</code></strong>使这个窗口里面的<strong><code>元素不重复</code></strong><br><strong><code>基本思路:</code></strong>[left,right)中没有重复元素，<strong><code>right++</code></strong>,并将该元素对应出现的<strong><code>频率++</code></strong>,直到right对应元素的<strong><code>频率不为0</code></strong>(即在[left,right)中已有该元素)，记录此时在[left,right)区间元素的个数(选取最大值),<strong><code>left</code></strong>对应元素的<strong><code>频率--</code></strong>，并且<strong><code>left++</code></strong>，直到发现此时right对应元素的<strong><code>频率为0</code></strong>  </p><p><strong><code>初始时：</code></strong>left,right都指向第一个元素,此时a,b,c出现的频率都是0</p><div align="center" style="zoom: 70%; margin:  0px auto;"><img src="/2018/08/22/LeetCode解题/01-Array/leetcode-3-Longest-Substring-Without-Repeating-Characters/leetcode_3_1.png" alt="原理"></div><p><strong><code>当遇到重复元素时：</code></strong>如图所示，在right遍历的过程中,[left,right)这个左闭右开区间中，a,b,c出现的次数为 <strong><code>a:1 、b:1 、c:1</code></strong>,此时right指向的元素是a,检测发现a之前在[left,right)中出现过，故将left对应元素的频率- -，left++,此时<strong><code>a:0 、b:1 、c:1</code></strong>,发现right指向的元素频率为0了，right++,对应元素的频率++</p><div align="center" style="zoom: 70%; margin:  0px auto;"><img src="/2018/08/22/LeetCode解题/01-Array/leetcode-3-Longest-Substring-Without-Repeating-Characters/leetcode_3_2.png" alt="原理"></div><p><strong><code>利用HashMap实现：</code></strong><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 时间复杂度O(N)  </span></span><br><span class="line">    <span class="keyword">public</span> int lengthOfLongestSubstring(<span class="type">String</span> s) &#123;</span><br><span class="line">        int <span class="keyword">left</span> = <span class="number">0</span>, <span class="keyword">right</span> = <span class="number">0</span>;                        <span class="comment">// [left,right):存放无重复元素</span></span><br><span class="line">        <span class="type">Map</span>&lt;<span class="type">Character</span>, <span class="type">Integer</span>&gt; <span class="built_in">map</span> = new <span class="type">HashMap</span>&lt;&gt;();</span><br><span class="line">        int res = <span class="type">Integer</span>.<span class="type">MIN_VALUE</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">right</span> &lt; s.length()) &#123;</span><br><span class="line">            <span class="comment">// 如果map中不含当前元素, 将当前元素添加进map,对应频率+1,并且right往后移</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">right</span> &lt; s.length() &amp;&amp; !<span class="built_in">map</span>.containsKey(s.charAt(<span class="keyword">right</span>)))&#123;</span><br><span class="line">                <span class="built_in">map</span>.put(s.charAt(<span class="keyword">right</span>++), <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;  <span class="comment">// 如果map中发现当前元素在[left,right)中已经出现过  将left对应元素频率--，left向后移动</span></span><br><span class="line">                <span class="built_in">map</span>.remove(s.charAt(<span class="keyword">left</span>++));</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="type">Math</span>.<span class="built_in">max</span>(res, <span class="keyword">right</span> - <span class="keyword">left</span>);   <span class="comment">// 更新结果</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == <span class="type">Integer</span>.<span class="type">MIN_VALUE</span> ? <span class="number">0</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="type">String</span>[] args) &#123;</span><br><span class="line">        <span class="type">String</span> s = <span class="string">"abcabcbb"</span>;</span><br><span class="line">        <span class="type">System</span>.out.<span class="built_in">println</span>(new <span class="type">Solution2</span>().lengthOfLongestSubstring(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong><code>不用HashMap使用哈希表</code></strong>,即<strong><code>数组</code></strong>，解法跟用hashMap的一样，只是利用的是数组来记录频率</p><p><strong><code>int[26]</code></strong> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for Letters <strong><code>&#39;a&#39; - &#39;z&#39;</code></strong> or <strong><code>&#39;A&#39; - &#39;Z&#39;</code></strong><br><strong><code>int[128]</code></strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for <strong><code>ASCII</code></strong><br><strong><code>int[256]</code></strong> &nbsp;&nbsp;&nbsp;&nbsp;  for <strong><code>Extended ASCII</code></strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class Solution3 &#123;</span><br><span class="line">    <span class="comment">// 时间复杂度O(N)  空间复杂度O(M) M:字符集的长度 即声明ascii数组大小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> lengthOfLongestSubstring(<span class="keyword">String</span> s) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;         <span class="comment">// [left,right)</span></span><br><span class="line">        <span class="keyword">int</span>[] ascii = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="keyword">int</span> res = Integer.MIN_VALUE;</span><br><span class="line">        <span class="built_in">while</span> (right &lt; s.length()) &#123;</span><br><span class="line">            <span class="built_in">if</span> (right &lt; s.length() &amp;&amp; ascii[s.charAt(right)] == <span class="number">0</span>) &#123;</span><br><span class="line">                ascii[s.charAt(right++)]++;</span><br><span class="line">            &#125; <span class="built_in">else</span> &#123;</span><br><span class="line">                ascii[s.charAt(left++)]--;</span><br><span class="line">            &#125;</span><br><span class="line">            res = Math.<span class="built_in">max</span>(res, right - left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> res == Integer.MIN_VALUE ? <span class="number">0</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        <span class="keyword">String</span> s = <span class="string">"abcabcbb"</span>;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="keyword">new</span> Solution3().lengthOfLongestSubstring(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/3.%20Longest%20Substring%20Without%20Repeating%20Characters" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java实现 </tag>
            
            <tag> 数组问题 </tag>
            
            <tag> 双指针之滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 209 Minimum Size Subarray Sum</title>
      <link href="/2018/08/21/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-209-Minimum-Size-Subarray-Sum/"/>
      <url>/2018/08/21/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-209-Minimum-Size-Subarray-Sum/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="209"><li>Minimum Size Subarray Sum:<a href="https://leetcode.com/problems/minimum-size-subarray-sum/description/" target="_blank" rel="noopener">题目链接</a></li></ol><h2 id="方法1：暴力解法"><a href="#方法1：暴力解法" class="headerlink" title="方法1：暴力解法"></a>方法1：暴力解法</h2><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 暴力破解 时间复杂度O(N^2)  空间复杂度O(1)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> minSubArrayLen(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> <span class="keyword">sum</span> = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; nums.length; ++j) &#123;</span><br><span class="line">                <span class="keyword">sum</span> += nums[j];</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">sum</span> &gt;= s) &#123;</span><br><span class="line">                    res = Math.min(j - i + <span class="number">1</span>, res);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == Integer.MAX_VALUE? <span class="number">0</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">7</span>;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution1().minSubArrayLen(s, nums));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法2：双指针之滑动窗口"><a href="#方法2：双指针之滑动窗口" class="headerlink" title="方法2：双指针之滑动窗口"></a>方法2：双指针之滑动窗口</h2><p><strong><code>基本思想：</code></strong>维护一个区间[left,right)，使得在这个区间里的和是小于ｓ的，如果加上一个数之后区间和大于等于ｓ了，那么就从区间左边开始删元素，并且边删边判断是不是和依然大于等于ｓ，更新结果．</p><div align="center" style="zoom: 75%; margin:  0px auto;"><img src="/2018/08/21/LeetCode解题/01-Array/leetcode-209-Minimum-Size-Subarray-Sum/leetcode 209_1.png" alt="原理"></div><p>如果<strong><code>sum &gt;= s</code></strong>,记录当前长度即<strong><code>right-left</code></strong>,然后删除[left,right)最左侧元素，left向右移,即<strong><code>sum -=nums[left++]</code></strong>，直到<strong><code>sum &lt; s</code></strong></p><p><strong><code>sum &gt;= s</code></strong></p><div align="center" style="zoom: 75%; margin:  0px auto;"><img src="/2018/08/21/LeetCode解题/01-Array/leetcode-209-Minimum-Size-Subarray-Sum/leetcode 209_2.png" alt="原理"></div><p><strong><code>sum &lt; s</code></strong></p><div align="center" style="zoom: 75%; margin:  0px auto;"><img src="/2018/08/21/LeetCode解题/01-Array/leetcode-209-Minimum-Size-Subarray-Sum/leetcode 209_3.png" alt="原理"></div><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 时间复杂度O(N)  空间复杂度O(1)  双指针之滑动窗口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> minSubArrayLen(<span class="keyword">int</span> s, <span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;       <span class="comment">// [left, right) 左闭右开区间 </span></span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">sum</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (right &lt; nums.length) &#123;</span><br><span class="line">            <span class="keyword">sum</span> += nums[right++];</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">sum</span> &gt;= s)&#123;</span><br><span class="line">                res = Math.min(right - left, res);</span><br><span class="line">                <span class="keyword">sum</span> -= nums[left++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == Integer.MAX_VALUE ? <span class="number">0</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">7</span>;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> Solution2().minSubArrayLen(s, nums));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/209.%20Minimum%20Size%20Subarray%20Sum" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java实现 </tag>
            
            <tag> 数组问题 </tag>
            
            <tag> 双指针之滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 11  Container With Most Water</title>
      <link href="/2018/08/21/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-11-Container-With-Most-Water/"/>
      <url>/2018/08/21/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-11-Container-With-Most-Water/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="11"><li>Container With Most Water:<a href="https://leetcode.com/problems/container-with-most-water/description/" target="_blank" rel="noopener">题目链接</a></li></ol><h2 id="方法1：暴力解法"><a href="#方法1：暴力解法" class="headerlink" title="方法1：暴力解法"></a>方法1：暴力解法</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class Solution1 &#123;</span><br><span class="line">    <span class="comment">// 时间复杂度 O(N^2)   空间复杂度O(1)  暴力破解法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> maxArea(<span class="keyword">int</span>[] <span class="built_in">height</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">height</span>.length; ++i) &#123;</span><br><span class="line">            <span class="built_in">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; <span class="built_in">height</span>.length; ++j) &#123;</span><br><span class="line">                <span class="keyword">int</span> area = (j - i) * (<span class="built_in">height</span>[i] &lt; <span class="built_in">height</span>[j] ? <span class="built_in">height</span>[i] : <span class="built_in">height</span>[j]);</span><br><span class="line">                <span class="built_in">if</span> (area &gt; res)&#123;</span><br><span class="line">                    res = area;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] <span class="built_in">height</span> = &#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">7</span>&#125;;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="keyword">new</span> Solution1().maxArea(<span class="built_in">height</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法2：双指针之对撞指针"><a href="#方法2：双指针之对撞指针" class="headerlink" title="方法2：双指针之对撞指针"></a>方法2：双指针之对撞指针</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class Solution2 &#123;</span><br><span class="line">    <span class="comment">// 时间复杂度O(N)   空间复杂度O(1)   双指针之对撞指针</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> maxArea(<span class="keyword">int</span>[] <span class="built_in">height</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="built_in">height</span>.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 当i,j还未相遇</span></span><br><span class="line">        <span class="built_in">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">int</span> area = (j - i) * Math.<span class="built_in">min</span>(<span class="built_in">height</span>[i], <span class="built_in">height</span>[j]);  <span class="comment">//  计算当前所围面积</span></span><br><span class="line">            <span class="built_in">if</span> (<span class="built_in">height</span>[i] &lt; <span class="built_in">height</span>[j])&#123;                <span class="comment">// 如果是height[i]小了 尝试i++</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;<span class="built_in">else</span> &#123;                                    <span class="comment">// 如果是height[j]小了 尝试j--</span></span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">if</span> (res &lt; area) &#123;</span><br><span class="line">                res = area;                             <span class="comment">// 更新所围最大面积</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] <span class="built_in">height</span> = &#123;<span class="number">1</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">7</span>&#125;;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="keyword">new</span> Solution2().maxArea(<span class="built_in">height</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/11.%20Container%20With%20Most%20Water" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java实现 </tag>
            
            <tag> 数组问题 </tag>
            
            <tag> 双指针之对撞指针 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 345 Reverse Vowels of a String</title>
      <link href="/2018/08/21/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-345-Reverse-Vowels-of-a-String/"/>
      <url>/2018/08/21/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-345-Reverse-Vowels-of-a-String/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="345"><li>Reverse Vowels of a String:<a href="https://leetcode.com/problems/reverse-vowels-of-a-string/description/" target="_blank" rel="noopener">题目链接</a></li></ol><h2 id="方法1：双指针之对撞指针"><a href="#方法1：双指针之对撞指针" class="headerlink" title="方法1：双指针之对撞指针"></a>方法1：双指针之对撞指针</h2><p><strong><code>基本思想：</code></strong>指针i从左向右扫描，指针j从右向左扫描，，在此过程中发现是元音字母就交换指针i和指针j所指向的内容，不是元音字母，只要i&lt;j即两者不相遇继续进行扫描</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class Solution1 &#123;</span><br><span class="line">    <span class="comment">// 时间复杂度O(N)   空间复杂度O(N)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">String</span> reverseVowels(<span class="keyword">String</span> s) &#123;</span><br><span class="line">        <span class="keyword">char</span>[] res = s.toCharArray();</span><br><span class="line">        <span class="keyword">String</span> vowels = <span class="string">"aeiouAEIOU"</span>;       <span class="comment">// 元音字母</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = res.length<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 只要i,j两者还未相遇</span></span><br><span class="line">        <span class="built_in">while</span> (i &lt; j)&#123;</span><br><span class="line">            <span class="comment">// 如果i指向的不是元音字母 i++; i&lt;j是为了确保在i++的过程中始终满足 i&lt;j</span></span><br><span class="line">            <span class="built_in">while</span> (i &lt; j &amp;&amp; !vowels.contains(res[i]+<span class="string">""</span>)) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果j指向的不是元音字母 j--; i&lt;j是为了确保在j--的过程中始终满足 i&lt;j</span></span><br><span class="line">            <span class="built_in">while</span> (i &lt; j &amp;&amp; !vowels.contains(res[j]+<span class="string">""</span>)) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 此时i,j指向的都是元音字母 交换</span></span><br><span class="line">            <span class="keyword">char</span> temp = res[i];</span><br><span class="line">            res[i] = res[j];</span><br><span class="line">            res[j] = temp;</span><br><span class="line">            <span class="comment">// 如果i,j指向的是元音字母 上面的两个while不会执行 需手动移动i,j指针</span></span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> <span class="keyword">new</span> <span class="keyword">String</span>(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        <span class="keyword">String</span> s = <span class="string">"leetcode"</span>;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="keyword">new</span> Solution1().reverseVowels(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/344.%20Reverse%20String" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java实现 </tag>
            
            <tag> 数组问题 </tag>
            
            <tag> 双指针之对撞指针 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 344 Reverse String</title>
      <link href="/2018/08/20/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-344-Reverse-String/"/>
      <url>/2018/08/20/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-344-Reverse-String/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="344"><li>Reverse String:<a href="https://leetcode.com/problems/reverse-string/description/" target="_blank" rel="noopener">题目链接</a></li></ol><h2 id="方法1：双指针之对撞指针"><a href="#方法1：双指针之对撞指针" class="headerlink" title="方法1：双指针之对撞指针"></a>方法1：双指针之对撞指针</h2><p><strong><code>基本思想：</code></strong>指针i从左向右扫描，指针j从右向左扫描，只要i&lt;j即两者不相遇，就交换指针i和指针j所指向的内容</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class Solution1 &#123;</span><br><span class="line">    <span class="comment">// 时间复杂度O(N)  空间复杂度O(N) 主要是开辟了res数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">String</span> reverseString(<span class="keyword">String</span> s) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span>[] res = s.toCharArray();</span><br><span class="line">        <span class="built_in">while</span> (i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">char</span> temp = res[i];</span><br><span class="line">            res[i] = res[j];</span><br><span class="line">            res[j] = temp;</span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">return</span> <span class="keyword">new</span> <span class="keyword">String</span>(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        <span class="keyword">String</span> s = <span class="string">"A man, a plan, a canal: Panama"</span>;</span><br><span class="line">        System.out.<span class="built_in">println</span>(<span class="keyword">new</span> Solution1().reverseString(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/344.%20Reverse%20String" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java实现 </tag>
            
            <tag> 数组问题 </tag>
            
            <tag> 双指针之对撞指针 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 125 Valid Palindrome</title>
      <link href="/2018/08/19/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-125-Valid-Palindrome/"/>
      <url>/2018/08/19/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-125-Valid-Palindrome/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="125"><li>Valid Palindromet:<a href="https://leetcode.com/problems/valid-palindrome/description/" target="_blank" rel="noopener">题目链接</a></li></ol><h2 id="方法1：双指针之对撞指针"><a href="#方法1：双指针之对撞指针" class="headerlink" title="方法1：双指针之对撞指针"></a>方法1：双指针之对撞指针</h2><p><strong><code>基本思想：</code></strong> <strong><code>指针i</code></strong>从左向右扫描，如果遇到的<strong><code>不是</code></strong>字母或者数字<strong><code>i++</code></strong>，<strong><code>指针j</code></strong>从右向左扫描，如果遇到的<strong><code>不是</code></strong>字母或者数字<strong><code>j--</code></strong>，此时i，j指向的是字母或数组，判断两者是否相等，相等继续，不相等说明不是回文数，当i与j相遇时结束</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution1</span> &#123;</span><br><span class="line">    <span class="comment">// 时间复杂度 O(N)   空间复杂度O(1)    双指针之对撞指针</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> boolean <span class="title">isPalindrome</span>(<span class="params">String s</span>) </span>&#123;</span><br><span class="line">        s = s.toLowerCase();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;        <span class="comment">// 两者还未相遇</span></span><br><span class="line">            <span class="comment">// 从i向右扫描   如果不是字母或数字i++; i&lt;j 是为了在i++的过程中 i始终小于j</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; !Character.isLetterOrDigit(s.charAt(i))) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从j向左扫描   如果不是字母或数字j--; i&lt;j 是为了在j--的过程中 i始终小于j</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; j &amp;&amp; !Character.isLetterOrDigit(s.charAt(j))) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果i&gt;=j 说明已经相遇</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= j) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 此时i,j指向的都是字母或数字 看两者是否相等 不等说明不是回文数</span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) != s.charAt(j)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果i,j都指向的是数字或字母 上面的两个while不会执行 需要手动的i++,j--</span></span><br><span class="line">            i++;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</span><br><span class="line">        String s = <span class="string">"A man, a plan, a canal: Panama"</span>;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="keyword">new</span> Solution1().isPalindrome(s));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/125.%20Valid%20Palindrome" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java实现 </tag>
            
            <tag> 数组问题 </tag>
            
            <tag> 双指针之对撞指针 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 167 Two Sum II - Input array is sorted</title>
      <link href="/2018/08/19/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-167-Two-Sum-II-Input-array-is-sorted/"/>
      <url>/2018/08/19/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-167-Two-Sum-II-Input-array-is-sorted/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="167"><li>Two Sum II - Input array is sorted:<a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/" target="_blank" rel="noopener">题目链接</a></li></ol><h2 id="方法1：暴力解法"><a href="#方法1：暴力解法" class="headerlink" title="方法1：暴力解法"></a>方法1：暴力解法</h2><p><strong><code>暴力解法如下：</code></strong><br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 时间复杂度O(N^2)  空间复杂度O(1)   暴力枚举法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> <span class="keyword">target</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 双重循环遍历i和i之后的元素是否满足相加等于target</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; numbers.length; ++j) &#123;</span><br><span class="line">                <span class="comment">// 如果满足条件  加入res中</span></span><br><span class="line">                <span class="keyword">if</span> (numbers[i] + numbers[j] == <span class="keyword">target</span>) &#123;</span><br><span class="line">                    res[<span class="number">0</span>] = i + <span class="number">1</span>;</span><br><span class="line">                    res[<span class="number">1</span>] = j + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">return</span> res;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] numbers = &#123;<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">target</span> = <span class="number">9</span>;</span><br><span class="line">        System.out.println(Arrays.toString(twoSum(numbers, <span class="keyword">target</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="方法2：二分查找法"><a href="#方法2：二分查找法" class="headerlink" title="方法2：二分查找法"></a>方法2：二分查找法</h2><p>从题目中提取有效条件，发现输入的数组都是<strong><code>有序</code></strong>的,又是<strong><code>查找</code></strong>两个元素，这不由让我想到了用<strong><code>二分查找法</code></strong>，二分法应用的前提就是<strong><code>连续的存储空间</code></strong>(数组不就是连续的嘛)，<strong><code>元素有序</code></strong><br><strong><code>基本思路：</code></strong> <strong><code>指针i</code></strong>指向当前元素，在<strong><code>[i+1,nums.length-1]</code></strong>这个区间使用<strong><code>二分查找法</code></strong>寻找<strong><code>指针j</code></strong>满足<strong><code>numbers[i] + numbers[j] == target</code></strong></p><blockquote><p><strong><code>二分查找法</code></strong> <strong>递归与非递归形式详解：</strong><a href="https://xerdemo.github.io/2018/07/28/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E9%80%92%E5%BD%92%E4%B8%8E%E9%9D%9E%E9%80%92%E5%BD%92%E5%BD%A2%E5%BC%8F/">点击这里</a></p></blockquote><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 二分查找非递归</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> <span class="keyword">target</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">target</span> &gt; numbers[mid]) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(<span class="keyword">target</span> &lt; numbers[mid])</span> </span>&#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;       <span class="comment">// 不存在 </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分查找递归</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">int</span> <span class="title">binarySearch2</span><span class="params">(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> <span class="keyword">target</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;    <span class="comment">// 不存在</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">target</span> &gt; numbers[mid]) &#123;</span><br><span class="line">            <span class="function"><span class="keyword">return</span> <span class="title">binarySearch2</span><span class="params">(numbers, mid + <span class="number">1</span>, right, <span class="keyword">target</span>)</span></span>;</span><br><span class="line">        &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(<span class="keyword">target</span> &lt; numbers[mid])</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">return</span> <span class="title">binarySearch2</span><span class="params">(numbers, left, mid - <span class="number">1</span>, <span class="keyword">target</span>)</span></span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果用的是二分非递归 时间复杂度O(N*log2^N)   空间复杂度O(1)</span></span><br><span class="line">    <span class="comment">// 如果用的是二分递归     时间复杂度O(N*log2^N)   空间复杂度O(log2^N)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> <span class="keyword">target</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="comment">// j:利用二分查找看[i+1,nums.length-1] 是否存在j满足 numbers[i] + numbers[j] == target</span></span><br><span class="line">            <span class="keyword">int</span> j = binarySearch2(numbers, i + <span class="number">1</span>, numbers.length - <span class="number">1</span>, <span class="keyword">target</span> - numbers[i]);</span><br><span class="line">            <span class="keyword">if</span> (j != <span class="number">-1</span>) &#123;    <span class="comment">// 如果存在</span></span><br><span class="line">                res[<span class="number">0</span>] = i + <span class="number">1</span>;</span><br><span class="line">                res[<span class="number">1</span>] = j + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] numbers = &#123;<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">target</span> = <span class="number">9</span>;</span><br><span class="line">        System.out.println(Arrays.toString(twoSum(numbers, <span class="keyword">target</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="方法3：双指针之对撞指针"><a href="#方法3：双指针之对撞指针" class="headerlink" title="方法3：双指针之对撞指针"></a>方法3：双指针之对撞指针</h2><p><strong><code>基本思想：</code></strong> <strong><code>指针i</code></strong>从数组<strong>左侧开始往右侧</strong>移动，<strong><code>指针j</code></strong>从数组<strong>右侧往左侧</strong>移动</p><div align="center" style="zoom: 75%; margin:  0px auto;"><img src="/2018/08/19/LeetCode解题/01-Array/leetcode-167-Two-Sum-II-Input-array-is-sorted/leetcode167_1.png" alt=""></div><p>如果<strong><code>numbers[i] + numbers[j] &gt; target</code></strong>,则说明numbers[j]大了，尝试<strong><code>j--</code></strong>，<strong>减小numbers[j]的值</strong>，注意数组是<strong><code>有序</code></strong>的<br>同理<strong><code>numbers[i] + numbers[j] &lt; target</code></strong>,则说明numbers[i]小了，尝试<strong><code>i++</code></strong>，<strong>加大numbers[i]的值</strong><br>如果<strong><code>numbers[i] + numbers[j] == target</code></strong>，则说明找到了<br>如果<strong><code>i和j相遇</code></strong> <strong>还没有找到</strong>，说明不存在<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution3</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 时间复杂度O(N)  空间复杂度O(1)  双指针之对撞指针</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> <span class="keyword">target</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">// 只要i和j没相遇 </span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = numbers[i] + numbers[j];</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; <span class="keyword">target</span>) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125; <span class="function"><span class="keyword">else</span> <span class="title">if</span> <span class="params">(sum &lt; <span class="keyword">target</span>)</span> </span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                res[<span class="number">0</span>] = i + <span class="number">1</span>;</span><br><span class="line">                res[<span class="number">1</span>] = j + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] numbers = &#123;<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">target</span> = <span class="number">9</span>;</span><br><span class="line">        System.out.println(Arrays.toString(twoSum(numbers, <span class="keyword">target</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="方法4：利用map"><a href="#方法4：利用map" class="headerlink" title="方法4：利用map"></a>方法4：利用map</h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.<span class="keyword">HashMap</span>;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> class Solution4 &#123;</span><br><span class="line">    <span class="comment">// 时间复杂度O(N) 利用hashMap</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span>[] twoSum(<span class="built_in">int</span>[] numbers, <span class="built_in">int</span> target) &#123;</span><br><span class="line">        Map&lt;Integer, Integer&gt; <span class="built_in">map</span> = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="built_in">int</span>[] res = <span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; numbers.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>.containsKey(target - numbers[i])) &#123;</span><br><span class="line">                res[<span class="number">0</span>] = <span class="built_in">map</span>.<span class="built_in">get</span>(target - numbers[i]) + <span class="number">1</span>;</span><br><span class="line">                res[<span class="number">1</span>] = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">map</span>.put(numbers[i], i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        <span class="built_in">int</span>[] numbers = &#123;<span class="number">2</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>&#125;;</span><br><span class="line">        <span class="built_in">int</span> target = <span class="number">9</span>;</span><br><span class="line">        System.out.<span class="built_in">println</span>(Arrays.toString(<span class="keyword">new</span> Solution4().twoSum(numbers, target)));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>pS:</code></strong> <a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/167.%20Two%20Sum%20II%20-%20Input%20array%20is%20sorted" target="_blank" rel="noopener">相关源码链接</a></p>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java实现 </tag>
            
            <tag> 二分查找 </tag>
            
            <tag> 数组问题 </tag>
            
            <tag> 双指针之对撞指针 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 215 Kth Largest Element in an Array</title>
      <link href="/2018/08/18/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-215-Kth-Largest-Element-in-an-Array/"/>
      <url>/2018/08/18/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-215-Kth-Largest-Element-in-an-Array/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="215"><li>Kth Largest Element in an Array:<a href="https://leetcode.com/problems/kth-largest-element-in-an-array/description/" target="_blank" rel="noopener">题目链接</a></li></ol><h2 id="方法1：二路快速排序"><a href="#方法1：二路快速排序" class="headerlink" title="方法1：二路快速排序"></a>方法1：二路快速排序</h2><blockquote><p><strong><code>二路快速算法详情链接:</code></strong>&nbsp;&nbsp;<a href="https://xerdemo.github.io/2018/07/23/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0%E5%8F%8A%E4%BC%98%E5%8C%96/">点击这里</a></p></blockquote><p><strong><code>二路快速排序源码如下：</code></strong><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void <span class="built_in">swap</span>(int[] nums, int i, int j) &#123;</span><br><span class="line">        int temp = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void <span class="built_in">insertionSort</span>(int[] nums, int <span class="keyword">left</span>, int <span class="keyword">right</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="keyword">left</span> + <span class="number">1</span>; i &lt;= <span class="keyword">right</span>; ++i) &#123;</span><br><span class="line">            int temp = nums[i];</span><br><span class="line">            int j = i;</span><br><span class="line">            <span class="keyword">for</span> (; j &gt; <span class="keyword">left</span> &amp;&amp; nums[j - <span class="number">1</span>] &gt; temp; j--) &#123;</span><br><span class="line">                nums[j] = nums[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            nums[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> int parttion(int[] nums, int <span class="keyword">left</span>, int <span class="keyword">right</span>) &#123;</span><br><span class="line">        <span class="comment">// 基准的选取 : 三路取中法</span></span><br><span class="line">        <span class="comment">// 保证nums[left] &lt;= nums[mid] &lt;= nums[right] 最后将nums[left],nums[mid]交换</span></span><br><span class="line">        int mid = <span class="keyword">left</span> + (<span class="keyword">right</span> - <span class="keyword">left</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[<span class="keyword">left</span>] &gt; nums[mid]) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums, <span class="keyword">left</span>, mid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[<span class="keyword">left</span>] &gt; nums[<span class="keyword">right</span>]) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums, <span class="keyword">left</span>, <span class="keyword">right</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; nums[<span class="keyword">right</span>]) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums, mid, <span class="keyword">right</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums, <span class="keyword">left</span>, mid);</span><br><span class="line">        int v = nums[<span class="keyword">left</span>];</span><br><span class="line"></span><br><span class="line">        int i = <span class="keyword">left</span> + <span class="number">1</span>;</span><br><span class="line">        int j = <span class="keyword">right</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt;= <span class="keyword">right</span> &amp;&amp; nums[i] &lt; v) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="keyword">left</span> + <span class="number">1</span> &amp;&amp; nums[j] &gt; v) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; j) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">swap</span>(nums, i++, j--);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums, <span class="keyword">left</span>, j);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二路快速排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> int <span class="type">QuickSort</span>(int[] nums, int <span class="keyword">left</span>, int <span class="keyword">right</span>, int k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">left</span> &gt; <span class="keyword">right</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="type">Integer</span>.<span class="type">MIN_VALUE</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        int p = parttion(nums, <span class="keyword">left</span>, <span class="keyword">right</span>);</span><br><span class="line">        <span class="comment">// 发现在基准右边就只快排右边 不管左边 同理</span></span><br><span class="line">        <span class="keyword">if</span> (nums.length - k == p) &#123;            <span class="comment">// 如果p此时指向的位置就是第K大数</span></span><br><span class="line">            <span class="keyword">return</span> nums[p];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums.length - k &lt; p) &#123;    <span class="comment">// 如果p此时指向的位置 &lt; 第K大数</span></span><br><span class="line">            <span class="keyword">return</span> <span class="type">QuickSort</span>(nums, <span class="keyword">left</span>, p - <span class="number">1</span>, k);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;                            <span class="comment">// 如果p此时指向的位置 &gt; 第K大数</span></span><br><span class="line">            <span class="keyword">return</span> <span class="type">QuickSort</span>(nums, p + <span class="number">1</span>, <span class="keyword">right</span>, k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> int findKthLargest(int[] nums, int k) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">QuickSort</span>(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="type">String</span>[] args) &#123;</span><br><span class="line">        int[] nums = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        int k = <span class="number">2</span>;</span><br><span class="line">        <span class="type">System</span>.out.<span class="built_in">println</span>(findKthLargest(nums, k));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>ps：<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/215.%20Kth%20Largest%20Element%20in%20an%20Array" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java实现 </tag>
            
            <tag> 二路快速排序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 88 Merge Sorted Array</title>
      <link href="/2018/08/17/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-88-Merge-Sorted-Array/"/>
      <url>/2018/08/17/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-88-Merge-Sorted-Array/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="88"><li>Merge Sorted Array:<a href="https://leetcode.com/problems/merge-sorted-array/description/" target="_blank" rel="noopener">题目链接</a></li></ol><p><strong><code>动画演示：</code></strong></p><div align="center" style="zoom: 70%; margin:  0px auto;"><img src="/2018/08/17/LeetCode解题/01-Array/leetcode-88-Merge-Sorted-Array/Animation.gif" alt="原理"></div><p><strong><code>源码如下：</code></strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = m + n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[i] &lt; nums2[j]) &#123;</span><br><span class="line">                nums1[k--] = nums2[j--];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums1[k--] = nums1[i--];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当j遍历万nums2[] i还没遍历完时</span></span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            nums1[k--] = nums1[i--];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当i遍历万nums1[] j还没遍历完时</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            nums1[k--] = nums2[j--];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] nums2 = &#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">3</span>;</span><br><span class="line">        merge(nums1, m, nums2, n);</span><br><span class="line">        System.out.println(Arrays.toString(nums1));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>ps：<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/88.%20Merge%20Sorted%20Array" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java实现 </tag>
            
            <tag> 数组问题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 75 Sort Colors</title>
      <link href="/2018/08/17/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-75-Sort-Colors/"/>
      <url>/2018/08/17/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-75-Sort-Colors/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><ol start="75"><li>Sort Colors:<a href="https://leetcode.com/problems/sort-colors/description/" target="_blank" rel="noopener">题目链接</a></li></ol><h2 id="方法1：计数排序"><a href="#方法1：计数排序" class="headerlink" title="方法1：计数排序"></a>方法1：计数排序</h2><blockquote><p><strong><code>计数排序算法详情链接:</code></strong>&nbsp;&nbsp;<a href="https://xerdemo.github.io/2018/08/16/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/">点击这里</a></p></blockquote><p><strong><code>计数排序源码如下：</code></strong><br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution1 &#123;</span><br><span class="line">    <span class="comment">// 时间复杂度O(N)  空间复杂度O(k) 其中K为要排序的数组的范围 O(3)  计数排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> sortColors(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">// 1.创建计数数组  并初始化</span></span><br><span class="line">        <span class="keyword">int</span>[] <span class="keyword">count</span> = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="comment">// 2.将nums元素存放进对应的count中计算出现次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">count</span>[nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.根据count出现次数来写入原数组nums</span></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">count</span>.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">count</span>[i]-- != <span class="number">0</span>) &#123;</span><br><span class="line">                nums[j++] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        sortColors(nums);</span><br><span class="line">        System.out.<span class="keyword">println</span>(Arrays.toString(nums));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="方法2：三路快速排序"><a href="#方法2：三路快速排序" class="headerlink" title="方法2：三路快速排序"></a>方法2：三路快速排序</h2><blockquote><p><strong><code>三路快速算法详情链接:</code></strong>&nbsp;&nbsp;<a href="https://xerdemo.github.io/2018/07/23/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0%E5%8F%8A%E4%BC%98%E5%8C%96/">点击这里</a></p></blockquote><p><strong><code>三路快速排序源码如下：</code></strong><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void <span class="built_in">swap</span>(int[] nums, int i, int j) &#123;</span><br><span class="line">        int t = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void <span class="built_in">insertionSort</span>(int[] nums, int <span class="keyword">left</span>, int <span class="keyword">right</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (int i = <span class="keyword">left</span> + <span class="number">1</span>; i &lt;= <span class="keyword">right</span>; ++i) &#123;</span><br><span class="line">            int temp = nums[i];</span><br><span class="line">            int j = i;</span><br><span class="line">            <span class="keyword">for</span> (; j &gt; <span class="keyword">left</span> &amp;&amp; nums[j - <span class="number">1</span>] &gt; temp; j--) &#123;</span><br><span class="line">                nums[j] = nums[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            nums[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void quickSort3ways(int[] nums, int <span class="keyword">left</span>, int <span class="keyword">right</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">right</span> - <span class="keyword">left</span> &lt;= <span class="number">15</span>) &#123;</span><br><span class="line">            <span class="built_in">insertionSort</span>(nums, <span class="keyword">left</span>, <span class="keyword">right</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 基准的选取 : 三路取中法</span></span><br><span class="line">        <span class="comment">// 保证nums[left] &lt;= nums[mid] &lt;= nums[right] 最后将nums[left],nums[mid]交换</span></span><br><span class="line">        int mid = <span class="keyword">left</span> + (<span class="keyword">right</span> - <span class="keyword">left</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[<span class="keyword">left</span>] &gt; nums[mid]) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums, <span class="keyword">left</span>, mid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[<span class="keyword">left</span>] &gt; nums[<span class="keyword">right</span>]) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums, <span class="keyword">left</span>, <span class="keyword">right</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; nums[<span class="keyword">right</span>]) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums, mid, <span class="keyword">right</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums, <span class="keyword">left</span>, mid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 基准的选取 : 随机数法</span></span><br><span class="line">        <span class="comment">// swap(nums, left, (int)Math.random() * (right-left+1) + left );</span></span><br><span class="line">        int v = nums[<span class="keyword">left</span>];</span><br><span class="line"></span><br><span class="line">        int lt = <span class="keyword">left</span>;</span><br><span class="line">        int gt = <span class="keyword">right</span> + <span class="number">1</span>;</span><br><span class="line">        int i = <span class="keyword">left</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i &lt; gt) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == v) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &lt; v) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums, i++, ++lt);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums, i, --gt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums, <span class="keyword">left</span>, lt--);</span><br><span class="line"></span><br><span class="line">        quickSort3ways(nums, <span class="keyword">left</span>, lt);</span><br><span class="line">        quickSort3ways(nums, gt, <span class="keyword">right</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void sortColors(int[] nums) &#123;</span><br><span class="line">        quickSort3ways(nums, <span class="number">0</span>, nums.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="type">String</span>[] args) &#123;</span><br><span class="line">        int[] nums = &#123;<span class="number">2</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        sortColors(nums);</span><br><span class="line">        <span class="type">System</span>.out.<span class="built_in">println</span>(<span class="type">Arrays</span>.<span class="built_in">toString</span>(nums));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>ps：<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/27.RemoveElement" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java实现 </tag>
            
            <tag> 计数排序 </tag>
            
            <tag> 三路快速排序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>计数排序</title>
      <link href="/2018/08/16/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"/>
      <url>/2018/08/16/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>本文将介绍计数排序<a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>举个栗子来理解计数排序，输入数组<strong><code>arr[5] = {3, 4, 3, 2, 1}</code></strong>进行计数排序，会输出<strong><code>{1, 2, 3, 3, 4}</code></strong>。这个算法由以下步骤组成：</p><ol><li><strong><code>初始化</code></strong>计数数组count[size]，<strong><code>数组大小</code></strong>为数组中<strong><code>size = 最大值 - 最小值 + 1</code></strong></li><li>统计arr数组中每个值为<strong><code>k</code></strong>的元素<strong><code>出现的次数</code></strong>，存入计数数组count的第k项(此处为了节约开辟的数组空间，可以存入数组的<strong><code>k-min</code></strong>项)</li><li>遍历整个计数数组，将count中<strong><code>大于0</code></strong>的数对应原数组的值写回原数组中</li></ol><p><strong><code>例子:</code></strong><br>输入arr[5] = {3, 4, 3, 2, 1}</p><p>实现<strong><code>步骤1</code></strong>最大元素<strong><code>max = 4</code></strong>， 最小<strong><code>min = 1</code></strong>,开辟计数数组<strong><code>count[size]</code></strong> ,<strong><code>size = max - min + 1 = 4</code></strong><br>初始化count[4] = {0, 0, 0, 0} </p><p>实现<strong><code>步骤2</code></strong>，计算出arr中元素对应在count中的出现的次数<br>{<strong><code>3</code></strong>, 4, 3, 2, 1}  -&gt;  {0, 0, <strong><code>1</code></strong>, 0}  (值为3的元素，在count的第3-min项，即<strong><code>第2项</code></strong>，从0开始算)<br>{3, <strong><code>4</code></strong>, 3, 2, 1}  -&gt;  {0, 0, 1, <strong><code>1</code></strong>}<br>{3, 4, <strong><code>3</code></strong>, 2, 1}  -&gt;  {0, 0, <strong><code>2</code></strong>, 1}<br>{3, 4, 3, <strong><code>2</code></strong>, 1}  -&gt;  {0, <strong><code>1</code></strong>, 2, 1}<br>{3, 4, 3, 2, <strong><code>1</code></strong>}  -&gt;  {<strong><code>1</code></strong>, 1, 2, 1} </p><p>实现<strong><code>步骤3</code></strong><br>{<strong><code>1</code></strong>, 1, 2, 1} -&gt; {<strong><code>1</code></strong>, 4, 3, 2, 1}(下标:0+min:1即为对应原数组的值)<br>{0, <strong><code>1</code></strong>, 2, 1} -&gt; {1, <strong><code>2</code></strong>, 3, 2, 1}<br>{0, 0, <strong><code>2</code></strong>, 1} -&gt; {1, 2, <strong><code>3</code></strong>, 2, 1}<br>{0, 0, <strong><code>1</code></strong>, 1} -&gt; {1, 2, 3, <strong><code>3</code></strong>, 1}<br>{0, 0, 0, <strong><code>1</code></strong>} -&gt; {1, 2, 3, 3, <strong><code>4</code></strong>}<br>{0, 0, 0, <strong><code>0</code></strong>} -&gt; {1, 2, 3, 3, 4}</p><p><strong><code>CountSort.c</code></strong>源码如下：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> printArray(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(<span class="string">"%d  "</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> countSort(<span class="keyword">int</span> * arr, <span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">max</span> = arr[<span class="number">0</span>], <span class="built_in">min</span> = arr[<span class="number">0</span>],i;</span><br><span class="line">    <span class="comment">// 找出数组中的最大值  最小值</span></span><br><span class="line">    <span class="built_in">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">if</span> (arr[i] &lt; <span class="built_in">min</span>)&#123;</span><br><span class="line">            <span class="built_in">min</span> = arr[i];       <span class="comment">// 更新最小值</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">if</span> (arr[i] &gt; <span class="built_in">max</span>) &#123;</span><br><span class="line">            <span class="built_in">max</span> = arr[i];       <span class="comment">// 更新最大值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span> = <span class="built_in">max</span> - <span class="built_in">min</span> + <span class="number">1</span>;   <span class="comment">// 计数数组count的大小</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *count = (<span class="keyword">int</span> *) malloc(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="built_in">size</span>);</span><br><span class="line">    <span class="built_in">for</span> (i = <span class="number">0</span>; i&lt; <span class="built_in">size</span>;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        count[i] = <span class="number">0</span>;           <span class="comment">// 初始化count</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将arr[]对应的数放入统计数组中  arr[i]-min对应的偏移量</span></span><br><span class="line">    <span class="built_in">for</span> (i = <span class="number">0</span>; i&lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        count[arr[i] - <span class="built_in">min</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历哈希表，将count数组中大于0的数对应出原数组的值，</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">size</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">while</span> (count[i]--)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[j++] = i + <span class="built_in">min</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    countSort(arr,<span class="number">5</span>);</span><br><span class="line">    printArray(arr, <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>时间复杂度:</strong> <strong><code>O(N + k)</code></strong>，n是输入数组长度，k是最大的数的大小。<br><strong>空间复杂度:</strong> <strong><code>O(N + k)</code></strong>，n是输入数组长度，k是最大的数的大小</p><p><strong><code>优点：</code></strong></p><ol><li>无需进行比较，所以时间上快于任何的比较排序。</li><li>适用于数据比较<strong><code>集中</code></strong>,<strong><code>规模小</code></strong>的数据排序 </li></ol><p><strong><code>缺点：</code></strong></p><ol><li>计数排序对于数据<strong><code>范围很大</code></strong>的数组，需要大量时间和内存 </li><li>必须是<strong><code>正整数</code></strong></li></ol><blockquote><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/09_%E6%8E%92%E5%BA%8F/06-CountSortt" target="_blank" rel="noopener">源代码链接</a></p></blockquote></the>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C实现 </tag>
            
            <tag> 排序 </tag>
            
            <tag> 计数排序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 80 Remove Duplicates from Sorted Array II</title>
      <link href="/2018/08/14/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-80-Remove-Duplicates-from-Sorted-Array-II/"/>
      <url>/2018/08/14/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-80-Remove-Duplicates-from-Sorted-Array-II/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""><br>Remove Duplicates from Sorted Array II:<a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/description/" target="_blank" rel="noopener">题目链接</a></the></p><h2 id="解法1：双指针之快慢指针"><a href="#解法1：双指针之快慢指针" class="headerlink" title="解法1：双指针之快慢指针"></a>解法1：双指针之快慢指针</h2><p><strong><code>[0,slow]</code></strong>存放answer(第二个数组)，快指针从索引为1的地方开始遍历，初始时count = 1，已经将数组第一个元素0，计算在[0,slow]这个区间<br><strong><code>当快指针与慢指针指向相同元素时：</code></strong></p><div align="center" style="zoom: 20%; margin:  0px auto;"><img src="/2018/08/14/LeetCode解题/01-Array/leetcode-80-Remove-Duplicates-from-Sorted-Array-II/1.jpg" alt="原理"></div><p>slow往后移，并将fast指向的内容赋给slow，即<strong><code>nums[++slow] = nums[fast]</code></strong>,此时count++，执行此过程的<strong><code>前提是count&lt;2</code></strong>,如果count&gt;=2, 代表[0,slow]中已经有两个该元素了，fast往后移，slow不变</p><p><strong><code>当快指针与慢指针指向不相同元素时：</code></strong></p><p><div align="center" style="zoom: 80%; margin:  0px auto;"><img src="/2018/08/14/LeetCode解题/01-Array/leetcode-80-Remove-Duplicates-from-Sorted-Array-II/2.jpg" alt="原理"></div><br>slow往后移，并将fast指向的内容赋给slow，即<strong><code>nums[++slow] = nums[fast]</code></strong>，并将count置为1，表示[0,slow]中有1个该元素</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Solution1 &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> removeDuplicates(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="keyword">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>;        <span class="comment">// [0,slow] 存放answer</span></span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">count</span> = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> fast = <span class="number">1</span>; fast &lt; nums.length; ++fast) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[slow] == nums[fast]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">count</span> &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                    nums[++slow] = nums[fast];</span><br><span class="line">                    <span class="keyword">count</span>++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[++slow] = nums[fast];</span><br><span class="line">                <span class="keyword">count</span> = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        System.out.<span class="keyword">println</span>(removeDuplicates(nums));</span><br><span class="line">        System.out.<span class="keyword">println</span>(Arrays.toString(nums));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/80.%20Remove%20Duplicates%20from%20Sorted%20Array%20II" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java实现 </tag>
            
            <tag> 数组问题 </tag>
            
            <tag> 双指针之快慢指针 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 26 Remove Duplicates from Sorted Array</title>
      <link href="/2018/08/14/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-26-Remove-Duplicates-from-Sorted-Array/"/>
      <url>/2018/08/14/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-26-Remove-Duplicates-from-Sorted-Array/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""><br>Remove Duplicates from Sorted Arrayt:<a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/" target="_blank" rel="noopener">题目链接</a></the></p><h2 id="方法1：双指针之快慢指针"><a href="#方法1：双指针之快慢指针" class="headerlink" title="方法1：双指针之快慢指针"></a>方法1：双指针之快慢指针</h2><p><strong><code>基本思路：</code></strong>用快指针fast遍历整个数组，发现符合条件的数据放入[0,slow]这个区间,题目有序这个条件很重要</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution1</span> &#123;</span><br><span class="line">    <span class="comment">// 时间复杂度O(N)  空间复杂度O(1)   双指针</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">removeDuplicates</span>(<span class="params"><span class="keyword">int</span>[] nums</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>;                 <span class="comment">// [0,slow]  存放合法数据(答案)</span></span><br><span class="line">        <span class="comment">// 快指针遍历数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> fast = <span class="number">0</span>; fast &lt; nums.length; ++fast) &#123;</span><br><span class="line">            <span class="comment">// 当前元素在[0,slow]中未出现，添加到[0,slow)  此处体会数组有序这个条件</span></span><br><span class="line">            <span class="keyword">if</span> (nums[slow] != nums[fast]) &#123;</span><br><span class="line">                nums[++slow] = nums[fast];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        System.<span class="keyword">out</span>.println(removeDuplicates(nums));</span><br><span class="line">        System.<span class="keyword">out</span>.println(Arrays.toString(nums));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ps：<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/26.%20Remove%20Duplicates%20from%20Sorted%20Array" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java实现 </tag>
            
            <tag> 数组问题 </tag>
            
            <tag> 双指针之快慢指针 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 27 Remove Element</title>
      <link href="/2018/08/14/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-27-Remove-Element/"/>
      <url>/2018/08/14/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-27-Remove-Element/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""><br>Remove Element:<a href="https://leetcode.com/problems/remove-element/description/" target="_blank" rel="noopener">题目链接</a></the></p><h2 id="方法1：双指针之快慢指针"><a href="#方法1：双指针之快慢指针" class="headerlink" title="方法1：双指针之快慢指针"></a>方法1：双指针之快慢指针</h2><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Solution1</span> &#123;</span><br><span class="line">    <span class="comment">// 时间复杂度 O(N)   空间复杂度O(1)   双指针</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">removeElement</span>(<span class="params"><span class="keyword">int</span>[] nums, <span class="keyword">int</span> val</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>;                     <span class="comment">// 存放不为val元素 区间[0, slow)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> fast = <span class="number">0</span>; fast &lt; nums.length; ++fast) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val != nums[fast]) &#123;</span><br><span class="line">                nums[slow++] = nums[fast];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">2</span>;</span><br><span class="line">        System.<span class="keyword">out</span>.println(removeElement(nums, val));</span><br><span class="line">        System.<span class="keyword">out</span>.println(Arrays.toString(nums));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ps：<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/27.RemoveElement" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java实现 </tag>
            
            <tag> 数组问题 </tag>
            
            <tag> 双指针之快慢指针 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>leetcode 283. Move Zeroes</title>
      <link href="/2018/08/13/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-283-Move-Zeroes/"/>
      <url>/2018/08/13/LeetCode%E8%A7%A3%E9%A2%98/01-Array/leetcode-283-Move-Zeroes/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br><a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""><br>Move Zeroes:<a href="https://leetcode.com/problems/move-zeroes/description/" target="_blank" rel="noopener">题目链接</a></the></p><h2 id="解法1：双指针之快慢指针"><a href="#解法1：双指针之快慢指针" class="headerlink" title="解法1：双指针之快慢指针"></a>解法1：双指针之快慢指针</h2><p><strong><code>基本思想：</code></strong>将<strong><code>[0,slow）</code></strong>存放<strong><code>非零</code></strong>元素，<strong><code>[slow,数组长度)</code></strong>存放0，fast用来遍历整个数组，当发现满足条件的元素，放入[0,slow)区间</p><div align="center" style="zoom: 70%; margin:  0px auto;"><img src="/2018/08/13/LeetCode解题/01-Array/leetcode-283-Move-Zeroes/双指针.gif" alt="原理"></div><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution1</span> &#123;</span></span><br><span class="line">    <span class="comment">// 时间复杂度 O(N)   空间复杂度O(1)    双指针</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>;        <span class="comment">// nums中, [0...slow)的元素均为非0元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> fast = <span class="number">0</span>; fast &lt; nums.length; ++fast) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> != nums[fast]) &#123;</span><br><span class="line">                nums[slow++] = nums[fast];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// [slow , nums.length) 存放0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = slow; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            nums[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">12</span>&#125;;</span><br><span class="line">        moveZeroes(nums);</span><br><span class="line">        System.out.println(Arrays.toString(nums));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解法2-优化解法1"><a href="#解法2-优化解法1" class="headerlink" title="解法2:优化解法1"></a>解法2:优化解法1</h2><p>在解法1的基础上，不需要将[slow , nums.length)单独拿出来赋值为0，在快慢指针进行的过程中，就已经完成了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution2</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = nums[i];</span><br><span class="line">        nums[i] = nums[j];</span><br><span class="line">        nums[j] = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 时间复杂度 O(N) 空间复杂度O(1) 双指针</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> fast = <span class="number">0</span>; fast &lt; nums.length; ++fast) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> != nums[fast]) &#123;</span><br><span class="line">                swap(nums, slow++, fast);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">12</span>&#125;;</span><br><span class="line">        moveZeroes(nums);</span><br><span class="line">        System.out.println(Arrays.toString(nums));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解法3"><a href="#解法3" class="headerlink" title="解法3"></a>解法3</h2><p><strong><code>基本思想：</code></strong>遍历nums[]数组，不等于0的元素，暂存在临时数组res[]中，最后将最终结果再复制给nums[]</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution3</span> &#123;</span></span><br><span class="line">    <span class="comment">// 时间复杂度 O(N) 空间复杂度O(N)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[nums.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 非零元素存到res[]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> != nums[i]) &#123;</span><br><span class="line">                res[k++] = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            res[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">            nums[i] = res[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">12</span> &#125;;</span><br><span class="line">        moveZeroes(nums);</span><br><span class="line">        System.out.println(Arrays.toString(nums));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ps：<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/LeetCode%E8%A7%A3%E9%A2%98%E7%9B%AE%E5%BD%95/283.%20Move%20Zeroes" target="_blank" rel="noopener">源代码链接</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java实现 </tag>
            
            <tag> 数组问题 </tag>
            
            <tag> 双指针之快慢指针 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>插入排序</title>
      <link href="/2018/07/31/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
      <url>/2018/07/31/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>本文将介绍插入排序<a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="插入排序基本思想"><a href="#插入排序基本思想" class="headerlink" title="插入排序基本思想"></a>插入排序基本思想</h2><p><strong><code>基本思想：</code></strong>待排序的一组序列分为已经排好序的和未排好序的两个部分；<strong><code>初始状态时</code></strong>，已排序的序列仅包含第一个元素，未排序的序列中元素未除去第一个以外N-1个元素；此后将未排序的元素依次插入到已排序的序列中。如此往复，经过N-1次插入后，未排序序列中元素个数为0，则排序完成。<br>可以把插入排序想象成打扑克时，拿牌的过程，首先右手先拿一张牌，放入左手此时只有一张牌且已经有序，右再拿一张牌，与当前已经有序的牌从右到左进行比较，放到适合的位置，重复此过程直到排序完成。</p><p><strong><code>具体实现：</code></strong></p><ol><li>从第一个元素开始，该元素可以认为已经被排序</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li><li>将新元素插入到该位置后</li><li>重复步骤2~5</li></ol><p><strong><code>动画演示：</code></strong></p><div align="center" style="zoom: 55%; margin:  0px auto;"><img src="/2018/07/31/插入排序/InserionSort.gif" alt="原理"></div><h2 id="插入排序代码"><a href="#插入排序代码" class="headerlink" title="插入排序代码"></a>插入排序代码</h2><p><strong><code>SortHelper.h</code></strong>存放相关工具函数<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ALGORITHM_SORTHELPER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALGORITHM_SORTHELPER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成有n个元素的随机数组,每个元素的随机范围为[rangeL, rangeR]</span></span><br><span class="line"><span class="keyword">int</span> *generateRandomArray(<span class="keyword">int</span> n, <span class="keyword">int</span> rangeL, <span class="keyword">int</span> rangeR)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> * arr = NULL;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">if</span> (n &gt; <span class="number">0</span> &amp;&amp; rangeL &lt;= rangeR)</span><br><span class="line">    &#123;</span><br><span class="line">        arr = (<span class="keyword">int</span> *) malloc(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);          <span class="comment">// 用malloc 分配数组 是因为不用malloc的话 随着此函数的结束 数组空间会被释放掉</span></span><br><span class="line">        srand(time(NULL));</span><br><span class="line">        <span class="built_in">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i] = rand() % (rangeR - rangeL + <span class="number">1</span>) + rangeL;  <span class="comment">// 注意区间是[rangeL, rangeR]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换两个数位置</span></span><br><span class="line"><span class="keyword">void</span> swap(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成近乎有序的数组  n数据个数  swapTimes:交换次数  最多只有2*交换次数个元素无序</span></span><br><span class="line"><span class="keyword">int</span> * generateNearlyOrderArray(<span class="keyword">int</span> n, <span class="keyword">int</span> swapTimes)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> *arr = NULL;</span><br><span class="line">    <span class="built_in">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        arr = (<span class="keyword">int</span> *) malloc(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);</span><br><span class="line">        <span class="built_in">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        srand(time(NULL));</span><br><span class="line">        <span class="built_in">for</span> (i = <span class="number">0</span>; i &lt; swapTimes; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x = rand() % n;</span><br><span class="line">            <span class="keyword">int</span> y = rand() % n;</span><br><span class="line">            swap(&amp;arr[x], &amp;arr[y]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成近乎倒序的数组  n数据个数  swapTimes:交换次数  最多只有2*交换次数个元素无序  左闭右开</span></span><br><span class="line"><span class="keyword">int</span> * generateNearlyReverseOrderArray(<span class="keyword">int</span> n, <span class="keyword">int</span> swapTimes)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> *arr = NULL;</span><br><span class="line">    <span class="built_in">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        arr = (<span class="keyword">int</span> *) malloc(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);</span><br><span class="line">        <span class="built_in">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i] = n<span class="number">-1</span>-i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        srand(time(NULL));</span><br><span class="line">        <span class="built_in">for</span> (i = <span class="number">0</span>; i &lt; swapTimes; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x = rand() % n;</span><br><span class="line">            <span class="keyword">int</span> y = rand() % n;</span><br><span class="line">            swap(&amp;arr[x], &amp;arr[y]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入排序</span></span><br><span class="line"><span class="keyword">void</span> InsertionSort(<span class="keyword">int</span> * arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="built_in">for</span> (i = left + <span class="number">1</span>; i &lt;= right; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        <span class="built_in">for</span> (j = i; j &gt; left &amp;&amp; arr[j<span class="number">-1</span>] &gt; temp; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印数组</span></span><br><span class="line"><span class="keyword">void</span> printArray(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(<span class="string">"%d "</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> testSort(<span class="keyword">char</span> * sortName, <span class="keyword">void</span>(*sort)(<span class="keyword">int</span>* , <span class="keyword">int</span> ), <span class="keyword">int</span> * arr, <span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    clock_t startTime = clock();</span><br><span class="line">    sort(arr, n);</span><br><span class="line">    clock_t endTime = clock();</span><br><span class="line">    printf(<span class="string">"%s cost: %lfs\n"</span>,sortName, (<span class="keyword">double</span>)(endTime - startTime) / CLOCKS_PER_SEC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝arr数组</span></span><br><span class="line"><span class="keyword">int</span> * copyArray(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> *arr2 = (<span class="keyword">int</span> *) malloc(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);</span><br><span class="line">    <span class="built_in">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        arr2[i] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> arr2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//ALGORITHM_SORTHELPER_H</span></span></span><br></pre></td></tr></table></figure></p><p><strong><code>InsertionSort.c</code></strong>插入排序源码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SortHelper.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertionSort1</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//        for (j = i; j&gt;0; --j)</span></span><br><span class="line"><span class="comment">//        &#123;</span></span><br><span class="line"><span class="comment">//            if (arr[j] &lt; arr[j - 1])</span></span><br><span class="line"><span class="comment">//            &#123;</span></span><br><span class="line"><span class="comment">//                swap(&amp;arr[j], &amp;arr[j - 1]);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            else</span></span><br><span class="line"><span class="comment">//            &#123;</span></span><br><span class="line"><span class="comment">//                break;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">// 可以改写成这样  注意i从1开始 j是&gt;0</span></span><br><span class="line">        <span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span> &amp;&amp; arr[j] &lt; arr[j - <span class="number">1</span>]; --j)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(&amp;arr[j], &amp;arr[j - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化的插入排序  将交换(每次做三步赋值)   换成了 赋值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertionSort2</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];        <span class="comment">// 取出未排序序列中的第一个元素</span></span><br><span class="line">        <span class="comment">// 在已排序元素中 从后往前扫描  如果发现比temp大 则往后移一位</span></span><br><span class="line">        <span class="keyword">for</span> (j = i; j &gt; <span class="number">0</span> &amp;&amp; arr[j<span class="number">-1</span>] &gt; temp; --j)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[j] = arr[j<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j] = temp;            <span class="comment">// temp进入适合的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">100000</span>;</span><br><span class="line">    <span class="comment">// 随机数组   区间[0,n]</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"test RandomArray size = %d [0,%d]\n"</span>, n, n);</span><br><span class="line">    <span class="keyword">int</span> *arr = generateRandomArray(n, <span class="number">0</span>, n);</span><br><span class="line">    <span class="keyword">int</span> *arr1 = copyArray(arr, n);</span><br><span class="line">    testSort(<span class="string">"insertionSort1"</span>, insertionSort1, arr, n);</span><br><span class="line">    testSort(<span class="string">"insertionSort2 "</span>, insertionSort2, arr1, n);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 近乎有序的数组 swapTimes：交换次数 区间[0,n)</span></span><br><span class="line">    <span class="keyword">int</span> swapTimes = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\ntest NearlyOrderArray size = %d [0,%d) swapTimes: %d\n"</span>, n, n, swapTimes);</span><br><span class="line">    <span class="keyword">int</span> *arr2 = generateNearlyOrderArray(n, swapTimes);</span><br><span class="line">    <span class="keyword">int</span> *arr3 = copyArray(arr, n);</span><br><span class="line">    testSort(<span class="string">"insertionSort1 "</span>, insertionSort1, arr2, n);</span><br><span class="line">    testSort(<span class="string">"insertionSort2"</span>, insertionSort2, arr3, n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 近乎倒序的数组  区间[0,n)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\ntest NearlyReverseArray size = %d [0,%d) swapTimes: %d\n"</span>, n, n, swapTimes);</span><br><span class="line">    <span class="keyword">int</span> *arr4 = generateNearlyReverseOrderArray(n, swapTimes);</span><br><span class="line">    <span class="keyword">int</span> *arr5 = copyArray(arr4, n);</span><br><span class="line">    testSort(<span class="string">"insertionSort1 "</span>, insertionSort1, arr4, n);</span><br><span class="line">    testSort(<span class="string">"insertionSort2 "</span>, insertionSort2, arr5, n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 含大量重复元素的数组  [0,10]</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\ntest RandomArray  size = %d [0,10]\n"</span>, n);</span><br><span class="line">    <span class="keyword">int</span> *arr6 = generateRandomArray(n, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">int</span> *arr7 = copyArray(arr6, n);</span><br><span class="line">    testSort(<span class="string">"insertionSort1 "</span>, insertionSort1, arr6, n);</span><br><span class="line">    testSort(<span class="string">"insertionSort2"</span>, insertionSort2, arr7, n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(arr);<span class="built_in">free</span>(arr1);<span class="built_in">free</span>(arr2);<span class="built_in">free</span>(arr3);<span class="built_in">free</span>(arr4);<span class="built_in">free</span>(arr5);<span class="built_in">free</span>(arr6);<span class="built_in">free</span>(arr7);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong><code>Clion运行结果如下：</code></strong></p><div align="center" style="zoom: 80%; margin:  0px auto;"><img src="/2018/07/31/插入排序/InsertionSort2.png" alt="原理"></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong><code>时间复杂度</code></strong>：<strong><code>O(n^2)</code></strong> &nbsp;&nbsp;&nbsp;指的是平均时间复杂度<br><strong><code>空间复杂度</code></strong>：<strong><code>O(1)</code></strong>   &nbsp;&nbsp;&nbsp; &nbsp;   拿insertionSort2来说 只开辟了<strong><code>i,j,temp</code></strong>等<strong><code>常数</code></strong>个空间<br><strong> <code>稳定性</code> </strong>：&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>稳定的</code></strong>   &nbsp;&nbsp;&nbsp; 元素关键字相等的两个元素进行比较时并不会发生交换，即<strong><code>相对位置不会发生变化</code></strong><br>插入排序<strong><code>最坏的情况</code></strong>下对应的每一个i，要进行i-1次比较和交换，时间复杂度<strong><code>O(N^2)</code></strong><br>插入排序<strong><code>最好的情况</code></strong>下(序列已经<strong><code>有序</code></strong>)，只用执行第一层循环就行了<strong><code>O(N)</code></strong></p><blockquote><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/09_%E6%8E%92%E5%BA%8F/04-InsertionSort" target="_blank" rel="noopener">源代码链接</a></p></blockquote></the>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C实现 </tag>
            
            <tag> 排序 </tag>
            
            <tag> 直接插入排序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>冒泡排序</title>
      <link href="/2018/07/31/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
      <url>/2018/07/31/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>本文将介绍冒泡排序<a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="冒泡排序基本思想"><a href="#冒泡排序基本思想" class="headerlink" title="冒泡排序基本思想"></a>冒泡排序基本思想</h2><p><strong><code>基本思想：</code></strong>对元素个数为<strong><code>N</code></strong>的的待排序序列进行排序时，共进行<strong><code>N-1</code></strong>次循环。在第K次循环中，对于从第1到k-1个元素从前往后进行比较，每次比较相邻的两个元素，<strong><code>若前一个元素大于后一个元素</code></strong>(相等的时候不交换，这也是为什么冒泡是稳定的)，则两者<strong><code>交换位置</code></strong>，否则保持<strong><code>位置不变</code></strong>。这样一次循环下来，就把第k大的元素移动到第N-k个位置上，称为第k趟的冒泡。整个过程一共进行N-1趟冒泡，直到第1个和第2个元素比较完成，最终剩余最小的元素，留在第1个位置上，排序结束</p><p><strong><code>动画演示：</code></strong></p><div align="center" style="zoom: 50%; margin:  0px auto;"><img src="/2018/07/31/冒泡排序/BubbleSort.gif" alt="原理"></div><h2 id="冒泡排序代码"><a href="#冒泡排序代码" class="headerlink" title="冒泡排序代码"></a>冒泡排序代码</h2><p><strong><code>SortHelper.h</code></strong>存放相关工具函数<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ALGORITHM_SORTHELPER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALGORITHM_SORTHELPER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成有n个元素的随机数组,每个元素的随机范围为[rangeL, rangeR]</span></span><br><span class="line"><span class="keyword">int</span> *generateRandomArray(<span class="keyword">int</span> n, <span class="keyword">int</span> rangeL, <span class="keyword">int</span> rangeR)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> * arr = NULL;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">if</span> (n &gt; <span class="number">0</span> &amp;&amp; rangeL &lt;= rangeR)</span><br><span class="line">    &#123;</span><br><span class="line">        arr = (<span class="keyword">int</span> *) malloc(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);          <span class="comment">// 用malloc 分配数组 是因为不用malloc的话 随着此函数的结束 数组空间会被释放掉</span></span><br><span class="line">        srand(time(NULL));</span><br><span class="line">        <span class="built_in">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i] = rand() % (rangeR - rangeL + <span class="number">1</span>) + rangeL;  <span class="comment">// 注意区间是[rangeL, rangeR]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换两个数位置</span></span><br><span class="line"><span class="keyword">void</span> swap(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成近乎有序的数组  n数据个数  swapTimes:交换次数  最多只有2*交换次数个元素无序</span></span><br><span class="line"><span class="keyword">int</span> * generateNearlyOrderArray(<span class="keyword">int</span> n, <span class="keyword">int</span> swapTimes)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> *arr = NULL;</span><br><span class="line">    <span class="built_in">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        arr = (<span class="keyword">int</span> *) malloc(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);</span><br><span class="line">        <span class="built_in">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        srand(time(NULL));</span><br><span class="line">        <span class="built_in">for</span> (i = <span class="number">0</span>; i &lt; swapTimes; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x = rand() % n;</span><br><span class="line">            <span class="keyword">int</span> y = rand() % n;</span><br><span class="line">            swap(&amp;arr[x], &amp;arr[y]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成近乎倒序的数组  n数据个数  swapTimes:交换次数  最多只有2*交换次数个元素无序  左闭右开</span></span><br><span class="line"><span class="keyword">int</span> * generateNearlyReverseOrderArray(<span class="keyword">int</span> n, <span class="keyword">int</span> swapTimes)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> *arr = NULL;</span><br><span class="line">    <span class="built_in">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        arr = (<span class="keyword">int</span> *) malloc(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);</span><br><span class="line">        <span class="built_in">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i] = n<span class="number">-1</span>-i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        srand(time(NULL));</span><br><span class="line">        <span class="built_in">for</span> (i = <span class="number">0</span>; i &lt; swapTimes; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x = rand() % n;</span><br><span class="line">            <span class="keyword">int</span> y = rand() % n;</span><br><span class="line">            swap(&amp;arr[x], &amp;arr[y]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入排序</span></span><br><span class="line"><span class="keyword">void</span> InsertionSort(<span class="keyword">int</span> * arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="built_in">for</span> (i = left + <span class="number">1</span>; i &lt;= right; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        <span class="built_in">for</span> (j = i; j &gt; left &amp;&amp; arr[j<span class="number">-1</span>] &gt; temp; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印数组</span></span><br><span class="line"><span class="keyword">void</span> printArray(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(<span class="string">"%d "</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> testSort(<span class="keyword">char</span> * sortName, <span class="keyword">void</span>(*sort)(<span class="keyword">int</span>* , <span class="keyword">int</span> ), <span class="keyword">int</span> * arr, <span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    clock_t startTime = clock();</span><br><span class="line">    sort(arr, n);</span><br><span class="line">    clock_t endTime = clock();</span><br><span class="line">    printf(<span class="string">"%s cost: %lfs\n"</span>,sortName, (<span class="keyword">double</span>)(endTime - startTime) / CLOCKS_PER_SEC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝arr数组</span></span><br><span class="line"><span class="keyword">int</span> * copyArray(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> *arr2 = (<span class="keyword">int</span> *) malloc(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);</span><br><span class="line">    <span class="built_in">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        arr2[i] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> arr2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//ALGORITHM_SORTHELPER_H</span></span></span><br></pre></td></tr></table></figure></p><p><strong><code>BubbleSort.c</code></strong>冒泡排序源码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SortHelper.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort1</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p, i;</span><br><span class="line">    <span class="keyword">for</span> (p = n - <span class="number">1</span>; p &gt; <span class="number">0</span>; --p)       <span class="comment">// 趟数 n-1趟</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; p; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 每趟找出一个最大元素  被交换到最右端</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>])  <span class="comment">// 若前一个元素大于后一个元素 交换</span></span><br><span class="line">            &#123;</span><br><span class="line">                swap(&amp;arr[i], &amp;arr[i + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 优化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort2</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p,i,flag;</span><br><span class="line">    <span class="keyword">for</span> (p = n - <span class="number">1</span>; p &gt; <span class="number">0</span>; --p)       <span class="comment">// 趟数 n-1趟</span></span><br><span class="line">    &#123;</span><br><span class="line">        flag = <span class="number">1</span>;                     <span class="comment">// 1:代表此时整个序列已经有序</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; p; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 每趟找出一个最大元素  被交换到最右端</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>])  <span class="comment">// 若前一个元素大于后一个元素 交换</span></span><br><span class="line">            &#123;</span><br><span class="line">                swap(&amp;arr[i], &amp;arr[i + <span class="number">1</span>]);</span><br><span class="line">                flag = <span class="number">0</span>;             <span class="comment">// 说明无序</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag)                     <span class="comment">// 如果flag还保持为1 说明已经有序</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">100000</span>;</span><br><span class="line">    <span class="comment">// 随机数组   区间[0,n]</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"test RandomArray size = %d [0,%d]\n"</span>, n, n);</span><br><span class="line">    <span class="keyword">int</span> *arr = generateRandomArray(n, <span class="number">0</span>, n);</span><br><span class="line">    <span class="keyword">int</span> *arr1 = copyArray(arr, n);</span><br><span class="line">    testSort(<span class="string">"bubbleSort1 "</span>, bubbleSort1, arr, n);</span><br><span class="line">    testSort(<span class="string">"bubbleSort2 "</span>, bubbleSort2, arr1, n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 近乎有序的数组 swapTimes：交换次数 区间[0,n)</span></span><br><span class="line">    <span class="keyword">int</span> swapTimes = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\ntest NearlyOrderArray size = %d [0,%d) swapTimes: %d\n"</span>, n, n, swapTimes);</span><br><span class="line">    <span class="keyword">int</span> *arr2 = generateNearlyOrderArray(n, swapTimes);</span><br><span class="line">    <span class="keyword">int</span> *arr3 = copyArray(arr, n);</span><br><span class="line">    testSort(<span class="string">"bubbleSort1 "</span>, bubbleSort1, arr2, n);</span><br><span class="line">    testSort(<span class="string">"bubbleSort2 "</span>, bubbleSort2, arr3, n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 近乎倒序的数组  区间[0,n)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\ntest NearlyReverseArray size = %d [0,%d) swapTimes: %d\n"</span>, n, n, swapTimes);</span><br><span class="line">    <span class="keyword">int</span> *arr4 = generateNearlyReverseOrderArray(n, swapTimes);</span><br><span class="line">    <span class="keyword">int</span> *arr5 = copyArray(arr4, n);</span><br><span class="line">    testSort(<span class="string">"bubbleSort1 "</span>, bubbleSort1, arr4, n);</span><br><span class="line">    testSort(<span class="string">"bubbleSort2 "</span>, bubbleSort2, arr5, n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 含大量重复元素的数组  [0,10]</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\ntest RandomArray  size = %d [0,10]\n"</span>, n);</span><br><span class="line">    <span class="keyword">int</span> *arr6 = generateRandomArray(n, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">int</span> *arr7 = copyArray(arr6, n);</span><br><span class="line">    testSort(<span class="string">"bubbleSort1 "</span>, bubbleSort1, arr6, n);</span><br><span class="line">    testSort(<span class="string">"bubbleSort2 "</span>, bubbleSort2, arr7, n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(arr);<span class="built_in">free</span>(arr1);<span class="built_in">free</span>(arr2);<span class="built_in">free</span>(arr3);<span class="built_in">free</span>(arr4);<span class="built_in">free</span>(arr5);<span class="built_in">free</span>(arr6);<span class="built_in">free</span>(arr7);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>Clion运行结果如下：</code></strong></p><div align="center" style="zoom: 80%; margin:  0px auto;"><img src="/2018/07/31/冒泡排序/BubbleSort2.png" alt="原理"></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong><code>时间复杂度</code></strong>：<strong><code>O(n^2)</code></strong> &nbsp;&nbsp;&nbsp;指的是平均时间复杂度<br><strong><code>空间复杂度</code></strong>：<strong><code>O(1)</code></strong>   &nbsp;&nbsp;&nbsp; &nbsp;   拿bubbleSort2来说 只开辟了<strong><code>p,i,flag</code></strong>等<strong><code>常数</code></strong>个空间<br><strong> <code>稳定性</code> </strong>：&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>稳定的</code></strong>   &nbsp;&nbsp;&nbsp; 元素关键字相等的两个元素进行比较时并不会发生交换，即<strong><code>相对位置不会发生变化</code></strong><br>冒泡排序<strong><code>最坏的情况</code></strong>下(序列时<strong><code>逆序</code></strong>排序的)，每次比较都需要进行交换，时间复杂度<strong><code>O(N^2)</code></strong><br>冒泡排序<strong><code>最好的情况</code></strong>下(序列已经<strong><code>有序</code></strong>)，这时由于用了flag标志只要进行<strong><code>O(N)</code></strong>次比较就可以从循环跳出来.看上面运行结果图在几乎有序的情况下，未经flag优化的运行时间。</p><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/09_%E6%8E%92%E5%BA%8F/03-BubbleSort" target="_blank" rel="noopener">源代码链接</a></p></the>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C实现 </tag>
            
            <tag> 排序 </tag>
            
            <tag> 冒泡排序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>选择排序</title>
      <link href="/2018/07/31/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
      <url>/2018/07/31/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>本文将介绍选择排序<a id="more"></a></excerpt></p><the rest="" of="" contents="" |="" 余下全文=""><h2 id="选择排序基本思想"><a href="#选择排序基本思想" class="headerlink" title="选择排序基本思想"></a>选择排序基本思想</h2><p><strong><code>基本思想：</code></strong>在未排序序列中选取<strong><code>最小元素</code></strong>与<strong><code>序列第一位</code></strong>交换，接下来再从<strong><code>剩下的未排序序列`</code></strong>中选取<strong><code>最小值</code></strong>与整个<strong><code>序列第二位</code></strong>交换,依次类推，最后形成从小到大的已排序序列</p><p><strong><code>选择排序动画演示：</code></strong></p><div align="center" style="zoom: 55%; margin:  0px auto;"><img src="/2018/07/31/选择排序/SelectionSort.gif" alt="原理"></div><h2 id="快速排序源码"><a href="#快速排序源码" class="headerlink" title="快速排序源码"></a>快速排序源码</h2><p><strong><code>SortHelper.h</code></strong>存放的是相关函数<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ALGORITHM_SORTHELPER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALGORITHM_SORTHELPER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成有n个元素的随机数组,每个元素的随机范围为[rangeL, rangeR]</span></span><br><span class="line"><span class="keyword">int</span> *generateRandomArray(<span class="keyword">int</span> n, <span class="keyword">int</span> rangeL, <span class="keyword">int</span> rangeR)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> * arr = NULL;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">if</span> (n &gt; <span class="number">0</span> &amp;&amp; rangeL &lt;= rangeR)</span><br><span class="line">    &#123;</span><br><span class="line">        arr = (<span class="keyword">int</span> *) malloc(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);          <span class="comment">// 用malloc 分配数组 是因为不用malloc的话 随着此函数的结束 数组空间会被释放掉</span></span><br><span class="line">        srand(time(NULL));</span><br><span class="line">        <span class="built_in">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i] = rand() % (rangeR - rangeL + <span class="number">1</span>) + rangeL;  <span class="comment">// 注意区间是[rangeL, rangeR]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换两个数位置</span></span><br><span class="line"><span class="keyword">void</span> swap(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成近乎有序的数组  n数据个数  swapTimes:交换次数  最多只有2*交换次数个元素无序</span></span><br><span class="line"><span class="keyword">int</span> * generateNearlyOrderArray(<span class="keyword">int</span> n, <span class="keyword">int</span> swapTimes)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> *arr = NULL;</span><br><span class="line">    <span class="built_in">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        arr = (<span class="keyword">int</span> *) malloc(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);</span><br><span class="line">        <span class="built_in">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        srand(time(NULL));</span><br><span class="line">        <span class="built_in">for</span> (i = <span class="number">0</span>; i &lt; swapTimes; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x = rand() % n;</span><br><span class="line">            <span class="keyword">int</span> y = rand() % n;</span><br><span class="line">            swap(&amp;arr[x], &amp;arr[y]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入排序</span></span><br><span class="line"><span class="keyword">void</span> InsertionSort(<span class="keyword">int</span> * arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="built_in">for</span> (i = left + <span class="number">1</span>; i &lt;= right; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        <span class="built_in">for</span> (j = i; j &gt; left &amp;&amp; arr[j<span class="number">-1</span>] &gt; temp; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印数组</span></span><br><span class="line"><span class="keyword">void</span> printArray(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(<span class="string">"%d "</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> testSort(<span class="keyword">char</span> * sortName, <span class="keyword">void</span>(*sort)(<span class="keyword">int</span>* , <span class="keyword">int</span> ), <span class="keyword">int</span> * arr, <span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    clock_t startTime = clock();</span><br><span class="line">    sort(arr, n);</span><br><span class="line">    clock_t endTime = clock();</span><br><span class="line">    printf(<span class="string">"%s cost: %lfs\n"</span>,sortName, (<span class="keyword">double</span>)(endTime - startTime) / CLOCKS_PER_SEC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝arr数组</span></span><br><span class="line"><span class="keyword">int</span> * copyArray(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> *arr2 = (<span class="keyword">int</span> *) malloc(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);</span><br><span class="line">    <span class="built_in">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        arr2[i] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> arr2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//ALGORITHM_SORTHELPER_H</span></span></span><br></pre></td></tr></table></figure></p><p><strong><code>SimpleSelectSort.c源码如下：</code></strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"math.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SortHelper.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间复杂度 O(n^2)   空间复杂度O(1):只声明了i，j，minIndex等变量</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span> * arr, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; ++i)       <span class="comment">// 寻找最小元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (j = i+<span class="number">1</span>; j &lt; n; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[minIndex])  <span class="comment">// 如果有元素比arr[minIndex]小 交换位置</span></span><br><span class="line">            &#123;</span><br><span class="line">                swap(&amp;arr[j], &amp;arr[minIndex]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">pow</span>(<span class="number">10</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">int</span> *arr = generateRandomArray(n, <span class="number">0</span>, n);</span><br><span class="line">    <span class="keyword">int</span> *arr1 = generateNearlyOrderArray(n, <span class="number">100</span>);</span><br><span class="line">    <span class="keyword">int</span> *arr2 = generateRandomArray(n, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    testSort(<span class="string">"simple seletion sort RandomArray"</span>, selectionSort, arr, n);</span><br><span class="line">    testSort(<span class="string">"simple seletion sort NearlyOrderArray"</span>, selectionSort, arr1, n);</span><br><span class="line">    testSort(<span class="string">"simple seletion sort RandomArray [0,10]"</span>, selectionSort, arr2, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong><code>Clion运行结果如下：</code></strong>(数据规模：100000 十万)</p><div align="center" style="zoom: 90%; margin:  0px auto;"><img src="/2018/07/31/选择排序/SelectionSort.png" alt="原理"></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong><code>时间复杂度</code></strong>：<strong><code>O(n^2)</code></strong> &nbsp;&nbsp;&nbsp;指的是平均时间复杂度<br><strong><code>空间复杂度</code></strong>：<strong><code>O(1)</code></strong>   &nbsp;&nbsp;&nbsp; &nbsp;    只开辟了<strong><code>i，j，minIndex</code></strong>等<strong><code>常数</code></strong>个空间<br><strong> <code>稳定性</code> </strong>：&nbsp;&nbsp;&nbsp;&nbsp;<strong><code>稳定的</code></strong>   &nbsp;&nbsp;&nbsp; 元素关键字相等的两个元素进行比较时并不会发生交换，即<strong><code>相对位置不会发生变化</code></strong><br>选择排序<strong><code>无论在什么情况下</code></strong>，都需要比较N*(N-1)/2次，故时间复杂度<strong><code>O(N^2)</code></strong>.事实上，在将第i个元素与最小元素交换之前，我们可以判断一下，如果minIndex == i，则无需交换，那么简单选择排序移动元素ishu在最好的情况下时0次(序列已经有序),在最坏的情况下为3(N-1)次(除去最后一个元素外，每个元素都要经过3步交换位置)</p><blockquote><p><strong><code>pS:</code></strong>&nbsp;<a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/09_%E6%8E%92%E5%BA%8F/05-SelectionSort" target="_blank" rel="noopener">源代码链接</a></p></blockquote></the>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C实现 </tag>
            
            <tag> 排序 </tag>
            
            <tag> 选择排序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>归并排序(自顶向下，自底向上)</title>
      <link href="/2018/07/28/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
      <url>/2018/07/28/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>本文将介绍从归并排序<a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><h2 id="归并排序基本思想"><a href="#归并排序基本思想" class="headerlink" title="归并排序基本思想"></a>归并排序基本思想</h2><p><strong><code>基本思想:</code></strong>将大小为N的序列看成N个长度为1的子序列，接下来将相邻的子序列两两进行归并操作，形成N/2(+1)个长度为2(或1)的有序子序列；然后再继续进行相邻子序列两两归并操作，如此一直循环，直到剩下1个长度为N的序列，则待序列为原序列完成排序后的结果。动画演示如下：</p><div align="center" style="zoom: 50%; margin:  0px auto;"><img src="/2018/07/28/归并排序/mergeSort1.gif" alt="原理"></div><p>其中归并的过程具体如下，选取<strong><code>2 3 6 8</code></strong> <strong><code>1 4 5 7</code></strong>这个即将要归并成一个序列的归并过程来讲归并的实现。动画演示如下：</p><div align="center" style="zoom: 50%; margin:  0px auto;"><img src="/2018/07/28/归并排序/mergeSort2.gif" alt="原理"></div><p>解释上面的动画过程，用一个<strong><code>辅助数组aux[]</code></strong>复制即将整合的两个序列，<strong><code>初始时</code></strong> <strong><code>i指向第一个序列的起始位置</code></strong>，<strong><code>j指向第二个序列的起始位置</code></strong>。当<strong><code>aux[i-left] &lt; aux[j-left]</code></strong>要减去left的偏移量，则<strong><code>arr[k]= arr[i-left]</code></strong>，<strong><code>k++, i++,j不变</code></strong>;如果<strong><code>aux[i-left] &gt;= aux[j-left]</code></strong>，则<strong><code>arr[k]= arr[j-left]</code></strong>，<strong><code>k++, j++,i不变</code></strong>;如果<strong><code>第一个序列结束</code></strong>  将<strong><code>第二个序列搬到arr[]</code></strong>;如果<strong><code>如果第二个序列结束</code></strong>  将<strong><code>第一个序列搬到arr[]</code></strong></p><div align="center" style="zoom: 50%; margin:  0px auto;"><img src="/2018/07/28/归并排序/mergeSort3.png" alt="原理"></div><h2 id="自顶向下归并排序源代码"><a href="#自顶向下归并排序源代码" class="headerlink" title="自顶向下归并排序源代码"></a>自顶向下归并排序源代码</h2><p><strong><code>SortHelper.h</code></strong> 存放归并排序需要的相关函数:<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ALGORITHM_SORTHELPER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALGORITHM_SORTHELPER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成有n个元素的随机数组,每个元素的随机范围为[rangeL, rangeR]</span></span><br><span class="line"><span class="keyword">int</span> *generateRandomArray(<span class="keyword">int</span> n, <span class="keyword">int</span> rangeL, <span class="keyword">int</span> rangeR)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> * arr = NULL;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">if</span> (n &gt; <span class="number">0</span> &amp;&amp; rangeL &lt;= rangeR)</span><br><span class="line">    &#123;</span><br><span class="line">        arr = (<span class="keyword">int</span> *) malloc(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);          <span class="comment">// 用malloc 分配数组 是因为不用malloc的话 随着此函数的结束 数组空间会被释放掉</span></span><br><span class="line">        srand(time(NULL));</span><br><span class="line">        <span class="built_in">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i] = rand() % (rangeR - rangeL + <span class="number">1</span>) + rangeL;  <span class="comment">// 注意区间是[rangeL, rangeR]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换两个数位置</span></span><br><span class="line"><span class="keyword">void</span> swap(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成近乎有序的数组  n数据个数  swapTimes:交换次数  最多只有2*交换次数个元素无序</span></span><br><span class="line"><span class="keyword">int</span> * generateNearlyOrderArray(<span class="keyword">int</span> n, <span class="keyword">int</span> swapTimes)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> *arr = NULL;</span><br><span class="line">    <span class="built_in">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        arr = (<span class="keyword">int</span> *) malloc(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);</span><br><span class="line">        <span class="built_in">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        srand(time(NULL));</span><br><span class="line">        <span class="built_in">for</span> (i = <span class="number">0</span>; i &lt; swapTimes; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x = rand() % n;</span><br><span class="line">            <span class="keyword">int</span> y = rand() % n;</span><br><span class="line">            swap(&amp;arr[x], &amp;arr[y]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入排序</span></span><br><span class="line"><span class="keyword">void</span> InsertionSort(<span class="keyword">int</span> * arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="built_in">for</span> (i = left + <span class="number">1</span>; i &lt;= right; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        <span class="built_in">for</span> (j = i; j &gt; left &amp;&amp; arr[j<span class="number">-1</span>] &gt; temp; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印数组</span></span><br><span class="line"><span class="keyword">void</span> printArray(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(<span class="string">"%d "</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> testSort(<span class="keyword">char</span> * sortName, <span class="keyword">void</span>(*sort)(<span class="keyword">int</span>* , <span class="keyword">int</span> ), <span class="keyword">int</span> * arr, <span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    clock_t startTime = clock();</span><br><span class="line">    sort(arr, n);</span><br><span class="line">    clock_t endTime = clock();</span><br><span class="line">    printf(<span class="string">"%s cost: %lfs\n"</span>,sortName, (<span class="keyword">double</span>)(endTime - startTime) / CLOCKS_PER_SEC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝arr数组</span></span><br><span class="line"><span class="keyword">int</span> * copyArray(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> *arr2 = (<span class="keyword">int</span> *) malloc(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);</span><br><span class="line">    <span class="built_in">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        arr2[i] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> arr2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//ALGORITHM_SORTHELPER_H</span></span></span><br></pre></td></tr></table></figure></p><p><strong><code>MergeSort1.c</code></strong>自顶向下源码如下：<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include <span class="string">"SortHelper.h"</span></span><br><span class="line"></span><br><span class="line">// 将arr[<span class="built_in">left</span> ... <span class="built_in">right</span>] 进行归并操作</span><br><span class="line">void __merge1(<span class="built_in">int</span> *arr, <span class="built_in">int</span> <span class="built_in">left</span>, <span class="built_in">int</span> <span class="built_in">mid</span>, <span class="built_in">int</span> <span class="built_in">right</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> i, j, k;</span><br><span class="line">    <span class="built_in">int</span> aux[<span class="built_in">right</span> - <span class="built_in">left</span> + <span class="number">1</span>];              // 辅助数组aux[]  复制即将整合的两个序列</span><br><span class="line">    for (i = <span class="built_in">left</span>; i &lt;= <span class="built_in">right</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        aux[i - <span class="built_in">left</span>] = arr[i];             // aux[] 复制 arr[]的内容</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    i = <span class="built_in">left</span>, j = <span class="built_in">mid</span> + <span class="number">1</span>;                  // i指向第一个序列的起始位置  j指向第二个序列的起始位置</span><br><span class="line"></span><br><span class="line">    for (k = <span class="built_in">left</span>; k &lt;= <span class="built_in">right</span>; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">if</span> (i &gt; <span class="built_in">mid</span>)                        // 如果第一个序列结束  将第二个序列搬到arr[]</span><br><span class="line">        &#123;</span><br><span class="line">            arr[k] = aux[j - <span class="built_in">left</span>];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        else <span class="built_in">if</span> (j &gt; <span class="built_in">right</span>)                 // 如果第二个序列结束  将第一个序列搬到arr[]</span><br><span class="line">        &#123;</span><br><span class="line">            arr[k] = aux[i-<span class="built_in">left</span>];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        else <span class="built_in">if</span> (aux[i-<span class="built_in">left</span>] &lt; aux[j-<span class="built_in">left</span>])  // 如果此时i指向的元素 小于 j</span><br><span class="line">        &#123;</span><br><span class="line">            arr[k] = aux[i - <span class="built_in">left</span>];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            arr[k] = aux[j - <span class="built_in">left</span>];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 对arr[<span class="built_in">left</span> ... <span class="built_in">right</span>] 进行归并排序</span><br><span class="line">void __mergeSort1(<span class="built_in">int</span> *arr, <span class="built_in">int</span> <span class="built_in">left</span>, <span class="built_in">int</span> <span class="built_in">right</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">if</span> (<span class="built_in">left</span> &gt;= <span class="built_in">right</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">mid</span> = <span class="built_in">left</span> + (<span class="built_in">right</span> - <span class="built_in">left</span>) / <span class="number">2</span>;</span><br><span class="line">    __mergeSort1(arr, <span class="built_in">left</span>, <span class="built_in">mid</span>);           // 对左子序列进行归并排序</span><br><span class="line">    __mergeSort1(arr, <span class="built_in">mid</span> + <span class="number">1</span>, <span class="built_in">right</span>);      // 对右子序列进行归并排序</span><br><span class="line">    __merge1(arr, <span class="built_in">left</span>, <span class="built_in">mid</span> , <span class="built_in">right</span>);       // 将左子序列 右子序列进行归并操作</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void mergeSort1(<span class="built_in">int</span> *arr, <span class="built_in">int</span> <span class="built_in">n</span>)</span><br><span class="line">&#123;</span><br><span class="line">    __mergeSort1(arr, <span class="number">0</span>, <span class="built_in">n</span> - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main(void)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">n</span> = pow(<span class="number">10</span>, <span class="number">7</span>);</span><br><span class="line">    // 测试随机数组</span><br><span class="line">    <span class="built_in">int</span> *arr = generateRandomArray(<span class="built_in">n</span>, <span class="number">0</span>, <span class="built_in">n</span>);</span><br><span class="line">    testSort(<span class="string">"mergeSort1"</span>, mergeSort1, arr, <span class="built_in">n</span>);</span><br><span class="line">    free(arr);</span><br><span class="line"></span><br><span class="line">    // 测试几乎有序的数组</span><br><span class="line">    <span class="built_in">int</span> swapTimes = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">int</span> *arr1 = generateNearlyOrderArray(<span class="built_in">n</span>, swapTimes);</span><br><span class="line">    testSort(<span class="string">"mergeSort1"</span>, mergeSort1, arr1, <span class="built_in">n</span>);</span><br><span class="line">    free(arr1);</span><br><span class="line"></span><br><span class="line">    // 测试含有大量重复元素的数组  <span class="built_in">n</span>个数组 范围[<span class="number">0</span>,<span class="number">10</span>]</span><br><span class="line">    <span class="built_in">int</span> *arr2 = generateRandomArray(<span class="built_in">n</span>, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    testSort(<span class="string">"mergeSort1"</span>, mergeSort1, arr2, <span class="built_in">n</span>);</span><br><span class="line">    free(arr2);</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong><code>自顶向下归并排序Clion运行结果：(数据规模10000000   1千万)</code></strong></p><div align="center" style="zoom: 90%; margin:  0px auto;"><img src="/2018/07/28/归并排序/mergeSort4.png" alt="原理"></div><p>还有两个地方可以<strong><code>优化：</code></strong></p><ul><li>对于<strong><code>小规模</code></strong>数组,使用<strong><code>插入排序</code></strong></li><li>对于<strong><code>arr[mid] &lt;= arr[mid+1]</code></strong>的情况 不进行merge 因为已经有序</li></ul><p><strong><code>优化后自顶向下的归并排序</code></strong>  <strong><code>MergeSort2.c</code></strong><br><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include <span class="string">"SortHelper.h"</span></span><br><span class="line"></span><br><span class="line">// 将arr[<span class="built_in">left</span> ... <span class="built_in">right</span>] 进行归并操作</span><br><span class="line">void __merge2(<span class="built_in">int</span> *arr, <span class="built_in">int</span> <span class="built_in">left</span>, <span class="built_in">int</span> <span class="built_in">mid</span>, <span class="built_in">int</span> <span class="built_in">right</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> i, j, k;</span><br><span class="line">    <span class="built_in">int</span> aux[<span class="built_in">right</span> - <span class="built_in">left</span> + <span class="number">1</span>];              // 辅助数组aux[]  复制即将整合的两个序列</span><br><span class="line">    for (i = <span class="built_in">left</span>; i &lt;= <span class="built_in">right</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        aux[i - <span class="built_in">left</span>] = arr[i];             // aux[] 复制 arr[]的内容</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    i = <span class="built_in">left</span>, j = <span class="built_in">mid</span> + <span class="number">1</span>;                  // i指向第一个序列的起始位置  j指向第二个序列的起始位置</span><br><span class="line"></span><br><span class="line">    for (k = <span class="built_in">left</span>; k &lt;= <span class="built_in">right</span>; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">if</span> (i &gt; <span class="built_in">mid</span>)                        // 如果第一个序列结束  将第二个序列搬到arr[]</span><br><span class="line">        &#123;</span><br><span class="line">            arr[k] = aux[j - <span class="built_in">left</span>];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        else <span class="built_in">if</span> (j &gt; <span class="built_in">right</span>)                 // 如果第二个序列结束  将第一个序列搬到arr[]</span><br><span class="line">        &#123;</span><br><span class="line">            arr[k] = aux[i-<span class="built_in">left</span>];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        else <span class="built_in">if</span> (aux[i-<span class="built_in">left</span>] &lt; aux[j-<span class="built_in">left</span>])  // 如果此时i指向的元素 小于 j</span><br><span class="line">        &#123;</span><br><span class="line">            arr[k] = aux[i - <span class="built_in">left</span>];</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            arr[k] = aux[j - <span class="built_in">left</span>];</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在__mergeSort1的基础上两个地方进行优化</span><br><span class="line">// 对arr[<span class="built_in">left</span> ... <span class="built_in">right</span>] 进行归并排序</span><br><span class="line">void __mergeSort2(<span class="built_in">int</span> *arr, <span class="built_in">int</span> <span class="built_in">left</span>, <span class="built_in">int</span> <span class="built_in">right</span>)</span><br><span class="line">&#123;</span><br><span class="line">    // 优化<span class="number">1</span>： 对于小规模数组,使用插入排序</span><br><span class="line">    <span class="built_in">if</span> (<span class="built_in">right</span> - <span class="built_in">left</span> &lt;= <span class="number">15</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        InsertionSort(arr, <span class="built_in">left</span>, <span class="built_in">right</span>);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">mid</span> = <span class="built_in">left</span> + (<span class="built_in">right</span> - <span class="built_in">left</span>) / <span class="number">2</span>;</span><br><span class="line">    __mergeSort2(arr, <span class="built_in">left</span>, <span class="built_in">mid</span>);</span><br><span class="line">    __mergeSort2(arr, <span class="built_in">mid</span> + <span class="number">1</span>, <span class="built_in">right</span>);</span><br><span class="line">    // 优化<span class="number">2</span>： 对于arr[<span class="built_in">mid</span>] &lt;= arr[<span class="built_in">mid</span>+<span class="number">1</span>]的情况 不进行merge 因为已经有序</span><br><span class="line">    // 对于近乎有序的数组非常有效 但是对于一般情况，有一定的性能损失（判读需要时间）</span><br><span class="line">    <span class="built_in">if</span> (arr[<span class="built_in">mid</span>] &gt; arr[<span class="built_in">mid</span> + <span class="number">1</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        __merge2(arr, <span class="built_in">left</span>, <span class="built_in">mid</span> , <span class="built_in">right</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void mergeSort2(<span class="built_in">int</span> *arr, <span class="built_in">int</span> <span class="built_in">n</span>)</span><br><span class="line">&#123;</span><br><span class="line">    __mergeSort2(arr, <span class="number">0</span>, <span class="built_in">n</span> - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main(void)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">n</span> = pow(<span class="number">10</span>, <span class="number">7</span>);</span><br><span class="line">    // 测试随机数组</span><br><span class="line">    <span class="built_in">int</span> *arr = generateRandomArray(<span class="built_in">n</span>, <span class="number">0</span>, <span class="built_in">n</span>);</span><br><span class="line">    testSort(<span class="string">"mergeSort2"</span>, mergeSort2, arr, <span class="built_in">n</span>);</span><br><span class="line">    free(arr);</span><br><span class="line"></span><br><span class="line">    // 测试几乎有序的数组</span><br><span class="line">    <span class="built_in">int</span> swapTimes = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">int</span> *arr1 = generateNearlyOrderArray(<span class="built_in">n</span>, swapTimes);</span><br><span class="line">    testSort(<span class="string">"mergeSort2"</span>, mergeSort2, arr1, <span class="built_in">n</span>);</span><br><span class="line">    free(arr1);</span><br><span class="line"></span><br><span class="line">    // 测试含有大量重复元素的数组  <span class="built_in">n</span>个数组 范围[<span class="number">0</span>,<span class="number">10</span>]</span><br><span class="line">    <span class="built_in">int</span> *arr2 = generateRandomArray(<span class="built_in">n</span>, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    testSort(<span class="string">"mergeSort2"</span>, mergeSort2, arr2, <span class="built_in">n</span>);</span><br><span class="line">    free(arr2);</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong><code>自顶向下归并排序(优化后)Clion运行结果：(数据规模10000000   1千万)</code></strong></p><div align="center" style="zoom: 90%; margin:  0px auto;"><img src="/2018/07/28/归并排序/mergeSort5.png" alt="原理"></div><h2 id="自底向上的归并排序"><a href="#自底向上的归并排序" class="headerlink" title="自底向上的归并排序"></a>自底向上的归并排序</h2><p>自底向上的归并排序<strong><code>MergeSortBU.c</code></strong>如下：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MergeSort1.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SortHelper.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">min</span>(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">return</span> a &gt; b ? b : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> mergeSortBU(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>, i;</span><br><span class="line">    <span class="built_in">for</span> (<span class="built_in">size</span> = <span class="number">1</span>; <span class="built_in">size</span> &lt;= n; <span class="built_in">size</span> += <span class="built_in">size</span>)             <span class="comment">// 规模 每次扩大两倍</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">for</span> (i = <span class="number">0</span>; i + <span class="built_in">size</span> &lt; n; i += <span class="number">2</span> * <span class="built_in">size</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 对 arr[i...i+size-1] 和 arr[i+size...i+2*size-1] 进行归并</span></span><br><span class="line">            <span class="comment">// 循环条件i+size &lt; n 是为了确保第二部分的存在 也保证了i+size-1(第一个子序列)不会越界</span></span><br><span class="line">            <span class="comment">// 为了确保第二个子序列不会越界 min(i + 2 * size - 1, n-1)</span></span><br><span class="line">            __merge1(arr, i, i + <span class="built_in">size</span> - <span class="number">1</span>, <span class="built_in">min</span>(i + <span class="number">2</span> * <span class="built_in">size</span> - <span class="number">1</span>, n - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在mergeSortBU的基础上两个地方进行优化</span></span><br><span class="line"><span class="keyword">void</span> mergeSortBU2(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>, i;</span><br><span class="line">    <span class="comment">// 优化1： 对于小规模数组,使用插入排序</span></span><br><span class="line">    <span class="built_in">for</span> (i = <span class="number">0</span>; i &lt; n; i += <span class="number">16</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        InsertionSort(arr, i, <span class="built_in">min</span>(i + <span class="number">15</span>, n - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">for</span> (<span class="built_in">size</span> = <span class="number">16</span>; <span class="built_in">size</span> &lt;= n; <span class="built_in">size</span> += <span class="built_in">size</span>)             <span class="comment">// 规模 每次扩大两倍</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">for</span> (i = <span class="number">0</span>; i + <span class="built_in">size</span> &lt; n; i += <span class="number">2</span> * <span class="built_in">size</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 优化2： 对于arr[i + size - 1] &gt; arr[i + size]的情况 不进行merge 因为已经有序</span></span><br><span class="line">            <span class="built_in">if</span> (arr[i + <span class="built_in">size</span> - <span class="number">1</span>] &gt; arr[i + <span class="built_in">size</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                __merge1(arr, i, i + <span class="built_in">size</span> - <span class="number">1</span>, <span class="built_in">min</span>(i + <span class="number">2</span> * <span class="built_in">size</span> - <span class="number">1</span>, n - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">pow</span>(<span class="number">10</span>, <span class="number">7</span>);</span><br><span class="line">    <span class="comment">// 测试随机数组</span></span><br><span class="line">    <span class="keyword">int</span> *arr = generateRandomArray(n, <span class="number">0</span>, n);</span><br><span class="line">    <span class="keyword">int</span> *arr1 = copyArray(arr, n);</span><br><span class="line">    testSort(<span class="string">"mergeSortBU"</span>, mergeSortBU, arr, n);</span><br><span class="line">    testSort(<span class="string">"mergeSortBU2"</span>, mergeSortBU2, arr1, n);</span><br><span class="line">    free(arr);</span><br><span class="line">    free(arr1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试几乎有序的数组</span></span><br><span class="line">    <span class="keyword">int</span> swapTimes = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> *arr2 = generateNearlyOrderArray(n, swapTimes);</span><br><span class="line">    <span class="keyword">int</span> *arr3 = copyArray(arr2, n);</span><br><span class="line">    testSort(<span class="string">"mergeSortBU"</span>, mergeSortBU, arr2, n);</span><br><span class="line">    testSort(<span class="string">"mergeSortBU2"</span>, mergeSortBU2, arr3, n);</span><br><span class="line">    free(arr2);</span><br><span class="line">    free(arr3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试含有大量重复元素的数组  n个数组 范围[0,10]</span></span><br><span class="line">    <span class="keyword">int</span> *arr4 = generateRandomArray(n, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">int</span> *arr5 = copyArray(arr4, n);</span><br><span class="line">    testSort(<span class="string">"mergeSortBU"</span>, mergeSortBU, arr4, n);</span><br><span class="line">    testSort(<span class="string">"mergeSortBU2"</span>, mergeSortBU2, arr5, n);</span><br><span class="line">    free(arr4);</span><br><span class="line">    free(arr5);</span><br><span class="line">    <span class="built_in">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong><code>自底向上归并排序Clion运行结果：(数据规模10000000   1千万)</code></strong></p><div align="center" style="zoom: 90%; margin:  0px auto;"><img src="/2018/07/28/归并排序/mergeSort6.png" alt="原理"></div><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>将<strong><code>MergeSort1.c</code></strong>,<strong><code>MergeSort2.c</code></strong>,<strong><code>MergeSortBU.c</code></strong>更改为<strong><code>.h</code></strong>,新建<strong><code>Main.c</code></strong>如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SortHelper.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MergeSort2.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"MergeSortBU.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">pow</span>(<span class="number">10</span>, <span class="number">8</span>);</span><br><span class="line">    <span class="comment">// 测试随机数组</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"test generateRandomArray, size = %d, random range [0, %d]\n"</span>, n, n);</span><br><span class="line">    <span class="keyword">int</span> *arr = generateRandomArray(n, <span class="number">0</span>, n);</span><br><span class="line">    <span class="keyword">int</span> *arr1 = copyArray(arr, n);</span><br><span class="line">    <span class="keyword">int</span> *arr2 = copyArray(arr, n);</span><br><span class="line">    <span class="keyword">int</span> *arr3 = copyArray(arr, n);</span><br><span class="line">    testSort(<span class="string">"mergeSort1"</span>, mergeSort1, arr, n);</span><br><span class="line">    testSort(<span class="string">"mergeSort2"</span>, mergeSort2, arr1, n);</span><br><span class="line">    testSort(<span class="string">"mergeSortBU"</span>, mergeSortBU, arr2, n);</span><br><span class="line">    testSort(<span class="string">"mergeSortBU2"</span>, mergeSortBU2, arr3, n);</span><br><span class="line">    <span class="built_in">free</span>(arr);<span class="built_in">free</span>(arr1);<span class="built_in">free</span>(arr2);<span class="built_in">free</span>(arr3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试几乎有序的数组</span></span><br><span class="line">    <span class="keyword">int</span> swapTimes = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\ntest generateNearlyOrderArray, size = %d, sawpTimes = %d\n"</span>,n, swapTimes);</span><br><span class="line">    <span class="keyword">int</span> *arr4 = generateNearlyOrderArray(n, swapTimes);</span><br><span class="line">    <span class="keyword">int</span> *arr5 = copyArray(arr4, n);</span><br><span class="line">    <span class="keyword">int</span> *arr6 = copyArray(arr4, n);</span><br><span class="line">    <span class="keyword">int</span> *arr7 = copyArray(arr4, n);</span><br><span class="line">    testSort(<span class="string">"mergeSort1"</span>, mergeSort1, arr4, n);</span><br><span class="line">    testSort(<span class="string">"mergeSort2"</span>, mergeSort2, arr5, n);</span><br><span class="line">    testSort(<span class="string">"mergeSortBU"</span>, mergeSortBU, arr6, n);</span><br><span class="line">    testSort(<span class="string">"mergeSortBU2"</span>, mergeSortBU2, arr7, n);</span><br><span class="line">    <span class="built_in">free</span>(arr4);<span class="built_in">free</span>(arr5);<span class="built_in">free</span>(arr6);<span class="built_in">free</span>(arr7);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试含有大量重复元素的数组  n个数组 范围[0,10]</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\ntest generateRandomArray, size = %d, random range [0, %d]\n"</span>,n, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">int</span> *arr8 = generateRandomArray(n, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">int</span> *arr9 = copyArray(arr8, n);</span><br><span class="line">    <span class="keyword">int</span> *arr10 = copyArray(arr8, n);</span><br><span class="line">    <span class="keyword">int</span> *arr11 = copyArray(arr8, n);</span><br><span class="line">    testSort(<span class="string">"mergeSort1"</span>, mergeSort1, arr8, n);</span><br><span class="line">    testSort(<span class="string">"mergeSort2"</span>, mergeSort2, arr9, n);</span><br><span class="line">    testSort(<span class="string">"mergeSortBU"</span>, mergeSortBU, arr10, n);</span><br><span class="line">    testSort(<span class="string">"mergeSortBU2"</span>, mergeSortBU2, arr11, n);</span><br><span class="line">    <span class="built_in">free</span>(arr8);<span class="built_in">free</span>(arr9);<span class="built_in">free</span>(arr10);<span class="built_in">free</span>(arr11);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong><code>Clion运行结果如下</code></strong>,规模又扩大了10倍(1亿)</p><div align="center" style="zoom: 90%; margin:  0px auto;"><img src="/2018/07/28/归并排序/mergeSort7.png" alt="原理"></div><p><a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/09_%E6%8E%92%E5%BA%8F/02-MergeSort" target="_blank" rel="noopener">相关源代码下载链接</a></p>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C实现 </tag>
            
            <tag> 排序 </tag>
            
            <tag> 分治法 </tag>
            
            <tag> 归并排序 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>二分查找递归与非递归形式</title>
      <link href="/2018/07/28/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E9%80%92%E5%BD%92%E4%B8%8E%E9%9D%9E%E9%80%92%E5%BD%92%E5%BD%A2%E5%BC%8F/"/>
      <url>/2018/07/28/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E9%80%92%E5%BD%92%E4%B8%8E%E9%9D%9E%E9%80%92%E5%BD%92%E5%BD%A2%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>本文将介绍二分查找的递归形式与非递归形式，并对临界情况进行分析<a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><h2 id="二分查找基本思想"><a href="#二分查找基本思想" class="headerlink" title="二分查找基本思想"></a>二分查找基本思想</h2><p><strong><code>基本思想：</code></strong>在<strong><code>有序</code></strong>的数组中（不适用于链表）取中间元素为比较对象，如果要查找的值比中间元素的值<strong><code>小</code></strong>，到中间元素的<strong><code>左边</code></strong>去查，如果要查找的值比中间元素的值<strong><code>大</code></strong>，到中间元素的<strong><code>右边</code></strong>去查，如果<strong><code>相等</code></strong>则查找成功，不断重复此过程。</p><h2 id="二分查找非递归代码"><a href="#二分查找非递归代码" class="headerlink" title="二分查找非递归代码"></a>二分查找非递归代码</h2><p><strong><code>searchHelper.h</code></strong>辅助代码如下:<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ALGORITHM_SEARCHHELPER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALGORITHM_SEARCHHELPER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"time.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成有序的数组  n:数据个数 [0,n)</span></span><br><span class="line"><span class="keyword">int</span> * generateOrderArray(<span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> *arr = NULL;</span><br><span class="line">    <span class="built_in">if</span> (n &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        arr = (<span class="keyword">int</span> *) malloc(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);</span><br><span class="line">        <span class="built_in">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印数组内容</span></span><br><span class="line"><span class="keyword">void</span> printArray(<span class="keyword">int</span> * arr, <span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(<span class="string">"%d  "</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试该算法</span></span><br><span class="line"><span class="keyword">void</span> testSearch(<span class="keyword">char</span> * searchName, <span class="keyword">int</span> (*search)(<span class="keyword">int</span> *, <span class="keyword">int</span> , <span class="keyword">int</span> ), <span class="keyword">int</span> * arr, <span class="keyword">int</span> n )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    clock_t startTime = clock();</span><br><span class="line">    <span class="built_in">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">if</span> (i != search(arr, n, i))</span><br><span class="line">        &#123;</span><br><span class="line">            printf(<span class="string">"no found %d\n"</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    clock_t endTime = clock();</span><br><span class="line">    printf(<span class="string">"%s test complete.  cost time: %lf s\n"</span>, searchName, (<span class="keyword">double</span>)(endTime - startTime) / CLOCKS_PER_SEC);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//ALGORITHM_SEARCHHELPER_H</span></span></span><br></pre></td></tr></table></figure></p><p>边界范围<strong><code>[left,right]</code></strong>,<strong><code>BinarySearch1.c</code></strong>如下：<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line">#include <span class="string">"searchHelper.h"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 定义二分查找的区间为 [<span class="built_in">left</span>, <span class="built_in">right</span>]</span><br><span class="line"><span class="built_in">int</span> binarySearch1(<span class="built_in">int</span> *arr, <span class="built_in">int</span> <span class="built_in">n</span>, <span class="built_in">int</span> target)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>, <span class="built_in">right</span> = <span class="built_in">n</span> - <span class="number">1</span>;     // 在[left...right]的范围里寻找target</span><br><span class="line">    while (<span class="built_in">left</span> &lt;= <span class="built_in">right</span>)            // 当 <span class="built_in">left</span> == <span class="built_in">right</span>时,区间[left...right]依然是有效的</span><br><span class="line">    &#123;</span><br><span class="line">        // <span class="built_in">int</span> <span class="built_in">mid</span> = (<span class="built_in">left</span> + <span class="built_in">right</span>) / <span class="number">2</span>;  此写法有bug 如果<span class="built_in">left</span> + <span class="built_in">right</span>超出了整数的范围 数据溢出</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">mid</span> = <span class="built_in">left</span> + (<span class="built_in">right</span> - <span class="built_in">left</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">if</span> (arr[<span class="built_in">mid</span>] == target)</span><br><span class="line">        &#123;</span><br><span class="line">            return <span class="built_in">mid</span>;</span><br><span class="line">        &#125; else <span class="built_in">if</span> (arr[<span class="built_in">mid</span>] &gt; target)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">right</span> = <span class="built_in">mid</span> - <span class="number">1</span>;</span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            <span class="built_in">left</span> = <span class="built_in">mid</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -<span class="number">1</span>;    // 找不到</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main(void)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">n</span> = pow(<span class="number">10</span>, <span class="number">7</span>);</span><br><span class="line">    <span class="built_in">int</span> *arr1 = generateOrderArray(<span class="built_in">n</span>);</span><br><span class="line">    testSearch(<span class="string">"BinarySearch1"</span>, binarySearch1, arr1, <span class="built_in">n</span>);</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>边界范围<strong><code>[left,right)</code></strong>,<strong><code>BinarySearch2.c</code></strong>如下：<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line">#include <span class="string">"searchHelper.h"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 在binarySearch1的基础上 更改 二分查找的区间为 [<span class="built_in">left</span>, <span class="built_in">right</span>)</span><br><span class="line"><span class="built_in">int</span> binarySearch2(<span class="built_in">int</span> *arr, <span class="built_in">int</span> <span class="built_in">n</span>, <span class="built_in">int</span> target)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">left</span> = <span class="number">0</span>, <span class="built_in">right</span> = <span class="built_in">n</span>;         // 在[left...right)的范围里寻找target</span><br><span class="line">    while (<span class="built_in">left</span> &lt; <span class="built_in">right</span>)            // 当 <span class="built_in">left</span> &lt; <span class="built_in">right</span>时,区间[left...right)依然是有效的</span><br><span class="line">    &#123;</span><br><span class="line">        // <span class="built_in">int</span> <span class="built_in">mid</span> = (<span class="built_in">left</span> + <span class="built_in">right</span>) / <span class="number">2</span>;  此写法有bug 如果<span class="built_in">left</span> + <span class="built_in">right</span>超出了整数的范围 数据溢出</span><br><span class="line">        <span class="built_in">int</span> <span class="built_in">mid</span> = <span class="built_in">left</span> + (<span class="built_in">right</span> - <span class="built_in">left</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">if</span> (arr[<span class="built_in">mid</span>] == target)</span><br><span class="line">        &#123;</span><br><span class="line">            return <span class="built_in">mid</span>;</span><br><span class="line">        &#125; else <span class="built_in">if</span> (arr[<span class="built_in">mid</span>] &gt; target)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">right</span> = <span class="built_in">mid</span>;            // 从<span class="built_in">mid</span> -<span class="number">1</span> 改成<span class="built_in">mid</span></span><br><span class="line">        &#125; else&#123;</span><br><span class="line">            <span class="built_in">left</span> = <span class="built_in">mid</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -<span class="number">1</span>;    // 找不到</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main(void)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="built_in">n</span> = pow(<span class="number">10</span>, <span class="number">7</span>);</span><br><span class="line">    <span class="built_in">int</span> *arr2 = generateOrderArray(<span class="built_in">n</span>);</span><br><span class="line">    testSearch(<span class="string">"BinarySearch2"</span>, binarySearch2, arr2, <span class="built_in">n</span>);</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="二分查找递归"><a href="#二分查找递归" class="headerlink" title="二分查找递归"></a>二分查找递归</h2><p>边界范围<strong><code>[left,right]</code></strong>,<strong><code>BinarySearchRecursive.c</code></strong>如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"searchHelper.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义二分查找的区间为 [left, right]</span></span><br><span class="line"><span class="keyword">int</span> __BinarySearchRecursive(<span class="keyword">int</span> *arr, <span class="keyword">int</span> left,<span class="keyword">int</span> right, <span class="keyword">int</span> target)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right)      <span class="comment">// 根据定义的区间[left, right] 当left == right时 还有效</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = (right - left) / <span class="number">2</span> + left;</span><br><span class="line">    <span class="keyword">if</span> (arr[mid] == target)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &lt; target)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> __BinarySearchRecursive(arr, mid + <span class="number">1</span>, right,target);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> __BinarySearchRecursive(arr, left, mid - <span class="number">1</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统一接口</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">BinarySearchRecursive</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  __BinarySearchRecursive(arr, <span class="number">0</span>, n - <span class="number">1</span>, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">pow</span>(<span class="number">10</span>, <span class="number">7</span>);</span><br><span class="line">    <span class="keyword">int</span> *arr3 = generateOrderArray(n);</span><br><span class="line">    testSearch(<span class="string">"BinarySearchRecursive"</span>, BinarySearchRecursive, arr3, n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>将<strong><code>BinarySearch1.c</code></strong> <strong><code>BinarySearch2.c</code></strong> <strong><code>BinarySearchRecursive.c</code></strong> 分别改成<strong><code>.h</code></strong>，在<strong><code>Main.c</code></strong>中比较三者运行效率,二分查找<strong><code>[0,n)</code></strong>之间的所有元素 <strong><code>Main.c</code></strong>如下：</p><pre><code>#include &quot;BinarySearch1.h&quot;#include &quot;BinarySearch2.h&quot;#include &quot;BinarySearchRecursive.h&quot;int main(void){    int n = pow(10, 7);    int *arr1 = generateOrderArray(n);    int *arr2 = generateOrderArray(n);    int *arr3 = generateOrderArray(n);    testSearch(&quot;BinarySearch1&quot;, binarySearch1, arr1, n);    testSearch(&quot;BinarySearch2&quot;, binarySearch2, arr2, n);    testSearch(&quot;BinarySearchRecursive&quot;, BinarySearchRecursive, arr3, n);    return 0;}</code></pre><p><strong><code>Clion运行结果</code></strong>如下：</p><div align="center" style="zoom: 90%; margin:  0px auto;"><img src="/2018/07/28/二分查找递归与非递归形式/BinarySear.png" alt="原理"></div><p><strong><code>二分查找缺点：</code></strong></p><ul><li>必须按关键字排序，有时排序也很费时。</li><li>只适用于顺序存储结构，所以插入、删除操作需大量移动元素<br>二分查找适用于一经建立就很少改动，而又经常需要查找的线性表。对于那些经常需要改动的线性表，可以采用链表存储结构，进行顺序查找</li></ul><p>可以看出递归形式与非递归形式相比的较慢         <a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/08_%E6%9F%A5%E6%89%BE/BinarySearch" target="_blank" rel="noopener">相关源码下载</a></p>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 查找 </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>快速排序实现及优化</title>
      <link href="/2018/07/23/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0%E5%8F%8A%E4%BC%98%E5%8C%96/"/>
      <url>/2018/07/23/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E5%AE%9E%E7%8E%B0%E5%8F%8A%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<p><excerpt in="" index="" |="" 首页摘要=""><br>本文将介绍从一路快速排序，二路快速排序，三路快速排序一步步实现以及优化的过程<a id="more"></a></excerpt></p><p><the rest="" of="" contents="" |="" 余下全文=""></the></p><h2 id="Quick-Sort-基本思想"><a href="#Quick-Sort-基本思想" class="headerlink" title="Quick Sort 基本思想"></a>Quick Sort 基本思想</h2><p><strong><code>基本思想</code></strong>：每次从当前待排序序列中选取一个元素作为<strong><code>基准</code></strong>(pivot)，如下图所示，这里我们选取的元素是4，之后想办法把4(基准)挪到整个序列排好序时应该所处的位置，此时4(基准)之前的元素是小于4的，4之后的元素是大于4的，对小于4(基准)的序列和大于4(基准)的序列分别使用快速排序逐渐<strong><code>递归</code></strong>下去，完成整个排序过程。   </p><div align="center" style="zoom: 50%; margin:  0px auto;"><img src="/2018/07/23/快速排序实现及优化/QuickSort1.png" alt="原理"></div><p><strong><code>一路快速排序图片相关参数介绍：</code></strong></p><ul><li>v: 基准</li><li>l: 也就是left </li><li>r: 也就是right </li><li>i: 当前访问的元素</li><li>j: 记录大于v(基准)小于v的分界点，指向&lt;v的最后一个元素 </li></ul><h2 id="一路快速排序-原理演示"><a href="#一路快速排序-原理演示" class="headerlink" title="一路快速排序 原理演示"></a>一路快速排序 原理演示</h2><p>将把序列分成两个部分的过程称为<strong><code>Partition</code></strong>,一般将数组的第一个元素作为基准（<strong><code>基准的选取</code></strong>影响了整个程序的效率，有<a href="https://blog.csdn.net/liuyi1207164339/article/details/50827608" target="_blank" rel="noopener">三种选取方法</a>），从left + 1 位置开始遍历序列，将序列分成小于v的部分和大于v的部分  </p><div align="center" style="zoom: 50%; margin:  0px auto;"><img src="/2018/07/23/快速排序实现及优化/QuickOneWays.gif" alt=""></div><div align="center" style="zoom: 50%; margin:  0px auto;"><img src="/2018/07/23/快速排序实现及优化/QuickSort2.png" alt="原理"></div><p><strong><code>arr[left+1 ... j] &lt; v</code></strong> 这段左闭右闭的区间是小于v的，<strong><code>arr[j+1 ... i-1] &gt; v</code></strong>这段左闭右闭的区间是大于v的，如果当前所指向元素<strong><code>arr[i] &gt; v</code></strong>，则<strong><code>i++</code></strong>,动画演示如下：</p><div align="center" style="zoom: 50%; margin:  0px auto;"><img src="/2018/07/23/快速排序实现及优化/QuickSort3.gif" alt=""></div><p>如果当前所指元素<strong><code>arr[i] &lt; v</code></strong>，则<strong><code>swap(arr[i], arr[j+1])</code></strong>, 并且<strong><code>j++</code></strong>, <strong><code>i++</code></strong>,动画演示如下:</p><div align="center" style="zoom: 50%; margin:  0px auto;"><img src="/2018/07/23/快速排序实现及优化/QuickSort4.gif" alt=""></div><p><strong><code>遍历完</code></strong>整个序列是这样子的：</p><div align="center" style="zoom: 50%; margin:  0px auto;"><img src="/2018/07/23/快速排序实现及优化/QuickSort5.png" alt=""></div><p>最后要将v放到它应该在的位置,即<strong><code>swap(arr[left],arr[j])</code></strong>，动画演示如下：</p><div align="center" style="zoom: 50%; margin:  0px auto;"><img src="/2018/07/23/快速排序实现及优化/QuickSort6.gif" alt=""></div><h2 id="一路快速排序-代码实现"><a href="#一路快速排序-代码实现" class="headerlink" title="一路快速排序 代码实现"></a>一路快速排序 代码实现</h2><p>为了方便从数组描述算法的性能，我把一些辅助函数放在<strong><code>SortHelper.h</code></strong>的头文件里，内容如下:<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> ALGORITHM_SORTHELP_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALGORITHM_SORTHELP_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成有n个元素的随机数组,每个元素的随机范围为[rangeL, rangeR] 左闭右闭区间</span></span><br><span class="line"><span class="keyword">int</span> * generateRandomArray(<span class="keyword">int</span> n, <span class="keyword">int</span> rangeL, <span class="keyword">int</span> rangeR)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> *arr = NULL;</span><br><span class="line">    <span class="built_in">if</span> (n &gt; <span class="number">0</span> &amp;&amp; rangeR &gt;= rangeL)</span><br><span class="line">    &#123;</span><br><span class="line">        arr = (<span class="keyword">int</span> *) malloc(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);   <span class="comment">// 用malloc 分配数组 是因为不用malloc的话 随着此函数的结束 数组空间会被释放掉</span></span><br><span class="line">        srand(time(NULL));                       <span class="comment">// 设置随机种子</span></span><br><span class="line">        <span class="built_in">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i] = rand() % (rangeR - rangeL + <span class="number">1</span>) + rangeL;  <span class="comment">// 注意随机数所在区间区间是[rangeL, rangeR]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换两个数</span></span><br><span class="line"><span class="keyword">void</span> swap(<span class="keyword">int</span> * a, <span class="keyword">int</span> * b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成近乎有序的数组  n:数据个数  swapTimes:交换次数  最多只有2*交换次数个元素无序</span></span><br><span class="line"><span class="keyword">int</span> * generateNearlyOrderArray(<span class="keyword">int</span> n, <span class="keyword">int</span> swapTimes)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> *arr = NULL;</span><br><span class="line">    <span class="built_in">if</span> (n &gt; <span class="number">0</span> &amp;&amp; swapTimes &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        arr = (<span class="keyword">int</span> *) malloc(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);</span><br><span class="line">        srand(time(NULL));</span><br><span class="line"></span><br><span class="line">        <span class="built_in">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">for</span> (i = <span class="number">0</span>; i &lt; swapTimes; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> x = rand() % n;</span><br><span class="line">            <span class="keyword">int</span> y = rand() % n;</span><br><span class="line">            swap(&amp;arr[x], &amp;arr[y]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试此排序方法 第四个形参传递的是方法</span></span><br><span class="line"><span class="keyword">void</span> testSort(<span class="keyword">int</span> * arr, <span class="keyword">int</span> n, <span class="keyword">char</span> * sortName , <span class="keyword">void</span>(*sort)(<span class="keyword">int</span> * , <span class="keyword">int</span> ))</span><br><span class="line">&#123;</span><br><span class="line">    clock_t startTime = clock();</span><br><span class="line">    sort(arr, n);</span><br><span class="line">    clock_t endTime = clock();</span><br><span class="line">    printf(<span class="string">"%s cost time: %lf s\n"</span>, sortName, (<span class="keyword">double</span>) (endTime - startTime) / CLOCKS_PER_SEC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制数组</span></span><br><span class="line"><span class="keyword">int</span> * copyArray(<span class="keyword">int</span> * arr, <span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> *newArr = (<span class="keyword">int</span> *) malloc(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * n);</span><br><span class="line">    <span class="built_in">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        newArr[i] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入排序</span></span><br><span class="line"><span class="keyword">void</span> InsertionSort(<span class="keyword">int</span> * arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="built_in">for</span> (i = left + <span class="number">1</span>; i &lt;= right; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">        <span class="built_in">for</span> (j = i; j &gt; left &amp;&amp; arr[j<span class="number">-1</span>] &gt; temp; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印数组内容</span></span><br><span class="line"><span class="keyword">void</span> printArray(<span class="keyword">int</span> * arr, <span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">for</span> (i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        printf(<span class="string">"%d  "</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//ALGORITHM_SORTHELP_H</span></span></span><br></pre></td></tr></table></figure></p><p><strong><code>QuickSortOneWays.c</code></strong>源代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SortHelp.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对arr[left...right]部分进行partition操作</span></span><br><span class="line"><span class="comment">// 返回posi,使得arr[left...p-1] &lt; arr[p] ; arr[p+1...right] &gt; arr[p]</span></span><br><span class="line"><span class="keyword">int</span> __partition(<span class="keyword">int</span> *arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">int</span> v = arr[left];                      <span class="comment">// 基准</span></span><br><span class="line">    j = left;</span><br><span class="line">    <span class="keyword">for</span> (i = left + <span class="number">1</span>; i &lt;= right; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果当前元素 比 基准小</span></span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; v)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(&amp;arr[i], &amp;arr[j + <span class="number">1</span>]);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 比基准大 i++</span></span><br><span class="line">    &#125;</span><br><span class="line">    swap(&amp;arr[left], &amp;arr[j]);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对arr[left, right]进行快速排序</span></span><br><span class="line"><span class="keyword">void</span> __QuickSortOneWays(<span class="keyword">int</span> * arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right)                          <span class="comment">// 递归结束条件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> p = __partition(arr, left, right);      <span class="comment">// 排好序后 基准所在位置的索引</span></span><br><span class="line">    __QuickSortOneWays(arr, left, p - <span class="number">1</span>);              <span class="comment">// 对左子序列进行快排</span></span><br><span class="line">    __QuickSortOneWays(arr, p + <span class="number">1</span>, right);             <span class="comment">// 对右子序列进行快排</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统一接口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSortOneWays</span><span class="params">(<span class="keyword">int</span> * arr, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __QuickSortOneWays(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 生成随机数组测试</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">100000</span>;</span><br><span class="line">    <span class="keyword">int</span> *arr = generateRandomArray(n, <span class="number">0</span>, n);    <span class="comment">// 生成n个[0,n]的随机数</span></span><br><span class="line">    testSort(arr, n, <span class="string">"QuickSortOneWays"</span>, QuickSortOneWays);</span><br><span class="line">    <span class="comment">// printArray(arr, n);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成 几乎有序的数组 最多只有2*100个元素无序</span></span><br><span class="line">    <span class="keyword">int</span> swapTimes = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> *arr1 = generateNearlyOrderArray(n, swapTimes);</span><br><span class="line">    testSort(arr1, n, <span class="string">"QuickSortOneWays"</span>, QuickSortOneWays);</span><br><span class="line">    <span class="comment">// printArray(arr1, n);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成大量重复元素数组 [0,10]</span></span><br><span class="line">    <span class="keyword">int</span> *arr2 = generateRandomArray(n, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    testSort(arr2, n, <span class="string">"QuickSortOneWays"</span>, QuickSortOneWays);</span><br><span class="line">    <span class="comment">// printArray(arr2, n);</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong><code>Clion运行结果如下：</code></strong></p><div align="center" style="zoom: 90%; margin:  0px auto;"><img src="/2018/07/23/快速排序实现及优化/QuickSort7.png" alt=""></div><p>可以看出<strong>一路快速排序</strong>的<strong><code>缺点</code></strong>在有<strong><code>大量重复元素</code></strong>，<strong><code>近乎有序的序列</code></strong>,运行效率都非常慢,<strong><code>二路快速排序</code></strong>由此被引伸出来,在此一路快速排序还有两个地方可以<strong><code>优化</code></strong>：</p><ol><li>当规模小于某个值时  使用插入排序</li><li><a href="https://blog.csdn.net/liuyi1207164339/article/details/50827608" target="_blank" rel="noopener">基准的选取</a> 这里采用随机数法 <strong><code>三位取中法</code></strong> 更好一点  因为rand() 需要时间</li></ol><p><strong><code>基准选取的三种方法</code></strong><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 三数取中法  **/</span></span><br><span class="line">int mid = <span class="keyword">left</span> + (<span class="keyword">right</span> - <span class="keyword">left</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 这里取三个数排序后，中间那个数作为枢轴</span></span><br><span class="line"><span class="keyword">if</span> (arr[<span class="keyword">left</span>] &gt; arr[mid])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">swap</span>(&amp;arr[<span class="keyword">left</span>], &amp;arr[mid]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (arr[<span class="keyword">left</span>] &gt; arr[<span class="keyword">right</span>])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">swap</span>(&amp;arr[<span class="keyword">left</span>], &amp;arr[<span class="keyword">right</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (arr[mid] &gt; arr[<span class="keyword">right</span>])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">swap</span>(&amp;arr[mid], &amp;arr[<span class="keyword">right</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 此时 arr[left] &lt;= arr[mid] &lt;= arr[right]*/</span></span><br><span class="line"><span class="built_in">swap</span>(&amp;arr[<span class="keyword">left</span>], &amp;arr[mid]);    <span class="comment">// 将基准放到最左边</span></span><br><span class="line">int v = arr[<span class="keyword">left</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 随机选取 **/</span></span><br><span class="line"><span class="built_in">swap</span>(&amp;arr[<span class="keyword">left</span>], &amp;arr[rand() % (<span class="keyword">right</span> - <span class="keyword">left</span> + <span class="number">1</span>) + <span class="keyword">left</span>]);   <span class="comment">// 选取随机基准 与arr[left]交换</span></span><br><span class="line">int v = arr[<span class="keyword">left</span>];                                            <span class="comment">// 基准 此时基准已经时交换了的随机数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** 固定基准 **/</span></span><br><span class="line">int v = arr[<span class="keyword">left</span>];</span><br></pre></td></tr></table></figure></p><p><strong><code>优化之后</code></strong>的源代码<strong><code>QuickSortOneWays1.c</code></strong>：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SortHelp.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对arr[left...right]部分进行partition操作</span></span><br><span class="line"><span class="comment">// 返回posi,使得arr[left...p-1] &lt; arr[p] ; arr[p+1...right] &gt; arr[p]</span></span><br><span class="line"><span class="keyword">int</span> __partition1(<span class="keyword">int</span> *arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="comment">/******************* 优化2 *******************/</span></span><br><span class="line">    swap(&amp;arr[left], &amp;arr[rand() % (right - left + <span class="number">1</span>) + left]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> v = arr[left];                      <span class="comment">// 基准</span></span><br><span class="line">    j = left;</span><br><span class="line">    <span class="keyword">for</span> (i = left + <span class="number">1</span>; i &lt;= right; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果当前元素 比 基准小</span></span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; v)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(&amp;arr[i], &amp;arr[j + <span class="number">1</span>]);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 比基准大 i++</span></span><br><span class="line">    &#125;</span><br><span class="line">    swap(&amp;arr[left], &amp;arr[j]);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对arr[left, right]进行快速排序</span></span><br><span class="line"><span class="keyword">void</span> __QuickSortOneWays1(<span class="keyword">int</span> * arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/************ 优化1 **********/</span></span><br><span class="line">    <span class="keyword">if</span> (right - left &lt;= <span class="number">15</span>)                      <span class="comment">// 递归结束条件</span></span><br><span class="line">    &#123;</span><br><span class="line">        InsertionSort(arr, left, right);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> p = __partition1(arr, left, right);      <span class="comment">// 排好序后 基准所在位置的索引</span></span><br><span class="line">    __QuickSortOneWays1(arr, left, p - <span class="number">1</span>);          <span class="comment">// 对左子序列进行快排</span></span><br><span class="line">    __QuickSortOneWays1(arr, p + <span class="number">1</span>, right);         <span class="comment">// 对右子序列进行快排</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统一接口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSortOneWays1</span><span class="params">(<span class="keyword">int</span> * arr, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    __QuickSortOneWays1(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 生成随机数组测试</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">100000</span>;</span><br><span class="line">    <span class="keyword">int</span> *arr = generateRandomArray(n, <span class="number">0</span>, n);    <span class="comment">// 生成n个[0,n]的随机数</span></span><br><span class="line">    testSort(arr, n, <span class="string">"QuickSortOneWays"</span>, QuickSortOneWays1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成 几乎有序的数组 最多只有2*100个元素无序</span></span><br><span class="line">    <span class="keyword">int</span> swapTimes = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> *arr1 = generateNearlyOrderArray(n, swapTimes);</span><br><span class="line">    testSort(arr1, n, <span class="string">"QuickSortOneWays"</span>, QuickSortOneWays1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成大量重复元素数组 [0,10]</span></span><br><span class="line">    <span class="keyword">int</span> *arr2 = generateRandomArray(n, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    testSort(arr2, n, <span class="string">"QuickSortOneWays"</span>,QuickSortOneWays1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong><code>优化后Clion运行结果：(数据规模100000   10万)</code></strong></p><div align="center" style="zoom: 90%; margin:  0px auto;"><img src="/2018/07/23/快速排序实现及优化/QuickSort8.png" alt=""></div><p>测试数据规模为100000(10万)，发现在<strong><code>几乎有序的数组</code></strong>中，从之前的15.284000s提高到0.022000s，效率明显<strong><code>高</code></strong>了不少（而且我们快速排序的对象只是一个数组，内部设计不是很复杂），在大量重复元素和随机数组中效率差不多，这是为什么呢？下面我用图来解释。</p><div align="center" style="zoom: 50%; margin:  0px auto;"><img src="/2018/07/23/快速排序实现及优化/QuickSort9.png" alt=""></div><p>随着<strong><code>基准选取的不同</code></strong>,快速排序的效率也受到了影响，当<strong><code>基准</code></strong>能把原序列换分成<strong><code>均匀</code></strong>的两个子序列时，每一次递归层次上比较的次数都是<strong><code>O(N)</code></strong>次，而递归的深度是 <strong><code>log2^N</code></strong> (每次都是将原始序列分一半，即一直除2)，最好的情况下时间复杂度应为<strong><code>O(Nlog2^N)</code></strong>,最坏的情况下，即基准每次是第一个元素，用因为是有序的，比基准小的元素没有，只有比基准大的元素，每次划分序列都近似于1和N-1，划分极度不均匀，像一个单链表，导致时间复杂度为<strong><code>O(N^2)</code></strong>,最坏情况下，快速排序图解如下：</p><div align="center" style="zoom: 50%; margin:  0px auto;"><img src="/2018/07/23/快速排序实现及优化/QuickSort10.png" alt=""></div><p>其中<strong><code>空间复杂度为O(log2^N)</code></strong>，递归的深度为log2^N，系统栈需要压入log2^N种状态，需要空间O(log2^N),在快排过程种定义的left,right…,都是常数级需要空间O(1),总共耗费空间O(log2^N) * O(1)。<br>这里解释下我为什么基准选取随机数：最坏的情况下，数组完全有序，每次选中最左边的元素，$ \frac{1}{n} \times \cfrac{1}{n-1} \times \cfrac{1}{n-2} \times….. \cfrac{1}{1} $ 当n无穷大时，出现最坏情况的概率接近于0</p><h2 id="二路快速排序"><a href="#二路快速排序" class="headerlink" title="二路快速排序"></a>二路快速排序</h2><p>当我在一路快速排序已经进行优化的代码中（基准选取得当解决了近乎有序数组的问题），把数组规模再<strong><code>扩大10倍</code></strong>（百万），Clion运行结果如下:</p><div align="center" style="zoom: 90%; margin:  0px auto;"><img src="/2018/07/23/快速排序实现及优化/QuickSort11.png" alt=""></div><p>从数据观察到，含有大量重复元素时，快速排序算法的复杂度似乎又退化到了<strong><code>O(N^2)</code></strong>，这是因为我们之前并没有算当前元素<strong><code>e==v</code></strong>这种情况，如图：</p><div align="center" style="zoom: 50%; margin:  0px auto;"><img src="/2018/07/23/快速排序实现及优化/QuickSort2.png" alt="原理"></div><p>假设此时我们把e==V 放在<strong><code>黄色</code></strong>区域,或者把e==v放在<strong><code>紫色</code></strong>区域,最后都会变成这样：</p><div align="center" style="zoom: 50%; margin:  0px auto;"><img src="/2018/07/23/快速排序实现及优化/QuickSort12.png" alt="原理"></div><p>partition这个过程极有可能将序列分为<strong><code>极度不平衡</code></strong>的两个子序列，而最好的情况是划分为均匀的两个序列O(log2^N)，<strong>此时的情况更接近于最坏的情况<code>O(N^2)</code></strong>， 如何解决这个问题呢？ <strong><code>二路快速排序</code></strong>由此而来.</p><p><strong><code>二路快速排序图片相关参数介绍：</code></strong></p><ul><li>v: 基准</li><li>l: 也就是left </li><li>r: 也就是right </li><li>e: 当前所指向元素</li><li>i: 记录小于v这一端即将要扫描的位置(向右)</li><li>j: 记录大于v这一端即将要扫描的位置(向左)  </li></ul><h2 id="二路快速排序-基本思想"><a href="#二路快速排序-基本思想" class="headerlink" title="二路快速排序 基本思想"></a>二路快速排序 基本思想</h2><p><strong><code>基本思想：</code></strong>首先我们从i开始向右扫描，如果当前扫描到的元素<strong><code>e &lt; v</code></strong> 则i往后移(<strong><code>i++</code></strong>)，<strong>直到</strong>碰到当前元素<strong><code>e &gt;= v</code></strong>停止。然后<strong>从j开始</strong>向左扫描,如果当前元素<strong><code>e &gt; v</code></strong>，则j往前移(<strong><code>j--</code></strong>),<strong>直到</strong>遇到 <strong><code>e &lt;= v</code></strong>，则将<strong>i,j对应的元素</strong> <strong><code>交换</code></strong>，<strong><code>i++</code></strong>，<strong><code>j--</code></strong>，再从i开始重复此过程，<strong><code>直到i，j相遇</code></strong>，然后把基准放到j对应的位置，即<strong><code>swap(arr[left, arr[j])</code></strong>代表整个序列遍历完毕，动画如下:</p><div align="center" style="zoom: 50%; margin:  0px auto;"><img src="/2018/07/23/快速排序实现及优化/QuickSort13.gif" alt=""></div><p><strong><code>实际上上面的图最后那里有点错误</code></strong>，正确的图如下：</p><div align="center" style="zoom: 62%; margin:  0px auto;"><img src="/2018/07/23/快速排序实现及优化/QuickSort14.png" alt=""></div><p>根据我们描叙的逻辑，<strong><code>橙色部分 &lt;= v</code></strong>的元素， <strong><code>紫色部分 &gt;= v</code></strong>的元素,这就解决了<strong><code>大量重复元素集中在一个区域</code></strong>的情况，<strong>之前一路快速排序=v的元素，根据自己设置的代码逻辑要么集中在黄色区域，要么就是紫色区域，造成划分的子序列不均匀</strong>,<strong><code>现在=v即可以在黄色区域，又可以在紫色区域</code></strong>，换句话来说假设i,j此时都指向等于v的元素，两者还是会交换，<strong>这样就不会造成=v的元素集中在一个区域</strong>。</p><h2 id="二路快速排序-代码实现"><a href="#二路快速排序-代码实现" class="headerlink" title="二路快速排序 代码实现"></a>二路快速排序 代码实现</h2><p><strong><code>QuickSortTwoWays.c</code></strong>源代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SortHelp.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对arr[left...right]部分进行partition操作</span></span><br><span class="line"><span class="comment">// 返回排好序时基准所在的位置p,使得 arr[left+1...i) &lt;= v; arr(j...right] &gt;= v</span></span><br><span class="line"><span class="keyword">int</span> __partitionTwoWays(<span class="keyword">int</span> *arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    swap(&amp;arr[left], &amp;arr[rand() % (right - left + <span class="number">1</span>) + left]);   <span class="comment">// 选取随机基准 与arr[left]交换</span></span><br><span class="line">    <span class="keyword">int</span> v = arr[left];                                            <span class="comment">// 基准 此时基准已经时交换了的随机数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// arr[left+1...i) &lt;= v; arr(j...right] &gt;= v</span></span><br><span class="line">    i = left + <span class="number">1</span>, j = right;                                      <span class="comment">// i初始化为left+1 刚好arr[left+1..i)无效 j同理</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// i 从左向右扫描 遇到比基准小的元素 i++</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt;= right &amp;&amp; arr[i] &lt; v)</span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// j 从右向左扫描 遇到比基准大的元素 j--</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= left + <span class="number">1</span> &amp;&amp; arr[j] &gt; v)</span><br><span class="line">        &#123;</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两者相遇时 按照之前的动画逻辑  相遇时 i&gt;j 用数据加图来体会</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(&amp;arr[i], &amp;arr[j]);         <span class="comment">// i,j两者对应元素交换</span></span><br><span class="line">        i++;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(&amp;arr[left], &amp;arr[j]);          <span class="comment">// 把基准放到 排好序应该在的位置</span></span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对arr[left, right]进行快速排序</span></span><br><span class="line"><span class="keyword">void</span> __QuickSortTwoWays(<span class="keyword">int</span> *arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (right - left &lt;= <span class="number">15</span>)                      <span class="comment">// 递归结束条件</span></span><br><span class="line">    &#123;</span><br><span class="line">        InsertionSort(arr, left, right);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> p = __partitionTwoWays(arr, left, right);      <span class="comment">// 排好序后 基准所在位置的索引</span></span><br><span class="line">    __QuickSortTwoWays(arr, left, p - <span class="number">1</span>);              <span class="comment">// 对左子序列进行快排</span></span><br><span class="line">    __QuickSortTwoWays(arr, p + <span class="number">1</span>, right);             <span class="comment">// 对右子序列进行快排</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统一接口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSortTwoWays</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    __QuickSortTwoWays(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 生成随机数组测试</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">1000000</span>;</span><br><span class="line">    <span class="keyword">int</span> *arr = generateRandomArray(n, <span class="number">0</span>, n);           <span class="comment">// 生成n个[0,n]的随机数</span></span><br><span class="line">    testSort(arr, n, <span class="string">"QuickSortTwoWays"</span>, QuickSortTwoWays);</span><br><span class="line">    <span class="comment">// printArray(arr, n);                             // 打印元素 看是否排序成功</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成 几乎有序的数组 最多只有2*100个元素无序</span></span><br><span class="line">    <span class="keyword">int</span> swapTimes = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> *arr1 = generateNearlyOrderArray(n, swapTimes);</span><br><span class="line">    testSort(arr1, n, <span class="string">"QuickSortTwoWays"</span>, QuickSortTwoWays);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成大量重复元素数组 [0,10]</span></span><br><span class="line">    <span class="keyword">int</span> *arr2 = generateRandomArray(n, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    testSort(arr2, n, <span class="string">"QuickSortTwoWays"</span>, QuickSortTwoWays);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong><code>二路快速排序Clion运行结果：(数据规模1000000   1百万)</code></strong></p><div align="center" style="zoom: 90%; margin:  0px auto;"><img src="/2018/07/23/快速排序实现及优化/QuickSort15.png" alt=""></div><p><strong><code>优化后的一路快速排序Clion运行结果：(数据规模1000000   1百万万)</code></strong></p><div align="center" style="zoom: 100%; margin:  0px auto;"><img src="/2018/07/23/快速排序实现及优化/QuickSort11.png" alt=""></div><p>可以看出<strong><code>二路快速排序</code></strong>在处理<strong><code>随机元素</code></strong>， <strong><code>几乎有序元素</code></strong>，<strong><code>大量重复元素</code></strong>, 效率都很不错,对比一路快排尤其在含大量重复元素时，优化了不少.但是对含有大量重复元素时，还有一个更好的方法，那就是下面要介绍的<strong><code>三路快速排序</code></strong></p><h2 id="三路快速排序"><a href="#三路快速排序" class="headerlink" title="三路快速排序"></a>三路快速排序</h2><p><strong><code>基本思想</code></strong>:之前二路快速排序将序列分为<v>v两部分，现在三路快速排序将序列分为 <v =="v">v 三部分，这样分割之后在递归的过程中对于<strong><code>==v</code></strong>的部分，就可以<strong><code>不用管</code></strong>了，只需要对<strong><code>&lt;v &gt;v</code></strong>的部分进行递归排序，更有效的解决了<strong><code>含有大量重复元素的序列</code></strong></v></v></p><p><strong><code>三路快速排序图片相关参数介绍：</code></strong></p><ul><li>v: 基准</li><li>l: 也就是left </li><li>lt:指向&lt;v部分的最后一个元素</li><li>r: 也就是right </li><li>e: 当前所指向元素</li><li>i: 当前所指向元素</li><li>gt:大于v部分的第一个元素</li></ul><p>如果当前元素 <strong><code>e==v</code></strong>，直接<strong><code>i++</code></strong>，如下图所示：</p><div align="center" style="zoom: 50%; margin:  0px auto;"><img src="/2018/07/23/快速排序实现及优化/QuickSort16.gif" alt=""></div><p>如果当前元素 <strong><code>e &lt; v</code></strong>，则当前元素与==v部分的第一个元素交换，即<strong><code>swap(arr[i], arr[lt+1])</code></strong>,然后<strong><code>lt++</code></strong>, i往后移,<strong><code>i++</code></strong></p><div align="center" style="zoom: 50%; margin:  0px auto;"><img src="/2018/07/23/快速排序实现及优化/QuickSort17.gif" alt=""></div><p>如果当前元素 <strong><code>e &gt; v</code></strong>，则当前元素与&gt;v部分的前面一个交换位置，即<strong><code>swap(arr[i], arr[gt-1])</code></strong>，然后gt往左移<strong><code>gt--</code></strong>,注意此时<strong><code>i不变</code></strong>，任然指向一个没有被处理的元素，只不过这个元素是从gt-1这个位置换过来的</p><div align="center" style="zoom: 50%; margin:  0px auto;"><img src="/2018/07/23/快速排序实现及优化/QuickSort18.gif" alt=""></div><p>当遍历完整个序列后,即<strong>i和gt相遇</strong>,最后只需要将基准v放到排好序应该在的地方，即<strong><code>swap(arr[left],arr[lt])</code></strong>，这个时候就不用管==v的部分，只用对 <strong><code>&lt;v &gt;v</code></strong>的部分进行<strong><code>递归</code></strong>快速排序.</p><div align="center" style="zoom: 50%; margin:  0px auto;"><img src="/2018/07/23/快速排序实现及优化/QuickSort19.gif" alt=""></div><h2 id="三路快速排序-代码实现"><a href="#三路快速排序-代码实现" class="headerlink" title="三路快速排序 代码实现"></a>三路快速排序 代码实现</h2><p><strong><code>QuickSortThreeWays.c</code></strong>源代码如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SortHelp.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[left+1...lt] &lt; v  ; arr[lt+1...i-1] == v ; arr[gt...right] &gt;v</span></span><br><span class="line"><span class="keyword">void</span> __QuickSortThreeWays(<span class="keyword">int</span> *arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i, lt, gt;</span><br><span class="line">    <span class="keyword">if</span> (right - left &lt;= <span class="number">15</span>)                     <span class="comment">// 递归结束条件</span></span><br><span class="line">    &#123;</span><br><span class="line">        InsertionSort(arr, left, right);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    swap(&amp;arr[left], &amp;arr[rand() % (right - left + <span class="number">1</span>) + left]);      <span class="comment">// 选取随机基准 与arr[left]交换</span></span><br><span class="line">    <span class="keyword">int</span> v = arr[left];                                               <span class="comment">// 基准</span></span><br><span class="line"></span><br><span class="line">    lt = left;           <span class="comment">// 将初始lt代入 [left+1...lt] &lt; v  刚好使这个区间无效</span></span><br><span class="line">    gt = right + <span class="number">1</span>;      <span class="comment">// 同理 gt代入  [gt...right] &gt;v</span></span><br><span class="line">    i = left + <span class="number">1</span>;        <span class="comment">// 同理i代入    [lt+1...i-1] == v</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// i和gt还没遇上</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; gt)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; v)               <span class="comment">// 当前元素 &lt; 基准</span></span><br><span class="line">        &#123;</span><br><span class="line">            swap(&amp;arr[i], &amp;arr[lt + <span class="number">1</span>]);</span><br><span class="line">            lt++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &gt; v)        <span class="comment">// 当前元素 &gt; 基准</span></span><br><span class="line">        &#123;</span><br><span class="line">            swap(&amp;arr[i], &amp;arr[gt - <span class="number">1</span>]);</span><br><span class="line">            gt--;                     <span class="comment">// 注意i不动</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;                             <span class="comment">// 等于基准</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此时i和gt已经遇上了</span></span><br><span class="line">    swap(&amp;arr[left], &amp;arr[lt--]);</span><br><span class="line">    __QuickSortThreeWays(arr, left, lt);  </span><br><span class="line">    __QuickSortThreeWays(arr, gt, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 统一接口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QuickSortThreeWays</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    __QuickSortThreeWays(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 生成随机数组测试</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">1000000</span>;</span><br><span class="line">    <span class="keyword">int</span> *arr = generateRandomArray(n, <span class="number">0</span>, n);    <span class="comment">// 生成n个[0,n]的随机数</span></span><br><span class="line">    testSort(arr, n, <span class="string">"QuickSortThreeWays"</span>, QuickSortThreeWays);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成 几乎有序的数组 最多只有2*100个元素无序</span></span><br><span class="line">    <span class="keyword">int</span> swapTimes = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">int</span> *arr1 = generateNearlyOrderArray(n, swapTimes);</span><br><span class="line">    testSort(arr1, n, <span class="string">"QuickSortThreeWays"</span>, QuickSortThreeWays);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成大量重复元素数组 [0,10]</span></span><br><span class="line">    <span class="keyword">int</span> *arr2 = generateRandomArray(n, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    testSort(arr2, n, <span class="string">"QuickSortThreeWays"</span>, QuickSortThreeWays);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我将一路快速排序优化后，二路快速排序，三路快速排序的源代码<strong><code>改成.h文件</code></strong>,在<strong><code>Main.c</code></strong>中比较他们分别针对<strong><code>随机序列</code></strong>、<strong><code>几乎有序的序列</code></strong>、<strong><code>含有大量重复元素的序列</code></strong>分别进行效率测试，Main.c如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SortHelp.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"QuickSortOneWays1.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"QuickSortTwoWays.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"QuickSortThreeWays.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 生成随机数组测试</span></span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">1000000</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\ntest generateRandomArray, size = %d, random range [0, %d]\n "</span>, n, n);</span><br><span class="line">    <span class="keyword">int</span> *arr1 = generateRandomArray(n, <span class="number">0</span>, n);    <span class="comment">// 生成n个[0,n]的随机数</span></span><br><span class="line">    <span class="keyword">int</span> *arr2 = copyArray(arr1, n);</span><br><span class="line">    <span class="keyword">int</span> *arr3 = copyArray(arr2, n);</span><br><span class="line">    testSort(arr1, n, <span class="string">"QuickSortOneWays1"</span>, QuickSortOneWays1);</span><br><span class="line">    testSort(arr2, n, <span class="string">"QuickSortTwoWays"</span>, QuickSortTwoWays);</span><br><span class="line">    testSort(arr3, n, <span class="string">"QuickSortThreeWays"</span>, QuickSortThreeWays);</span><br><span class="line">    <span class="built_in">free</span>(arr1);<span class="built_in">free</span>(arr2);<span class="built_in">free</span>(arr3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成 几乎有序的数组 最多只有2*100个元素无序</span></span><br><span class="line">    <span class="keyword">int</span> swapTimes = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\ntest generateNearlyOrderArray, size = %d, sawpTimes = %d\n"</span>,n, swapTimes);</span><br><span class="line">    <span class="keyword">int</span> *arr4 = generateNearlyOrderArray(n, swapTimes);</span><br><span class="line">    <span class="keyword">int</span> *arr5 = copyArray(arr4, n);</span><br><span class="line">    <span class="keyword">int</span> *arr6 = copyArray(arr4, n);</span><br><span class="line">    testSort(arr4, n, <span class="string">"QuickSortOneWays1"</span>, QuickSortOneWays1);</span><br><span class="line">    testSort(arr5, n, <span class="string">"QuickSortTwoWays"</span>, QuickSortTwoWays);</span><br><span class="line">    testSort(arr6, n, <span class="string">"QuickSortThreeWays"</span>, QuickSortThreeWays);</span><br><span class="line">    <span class="built_in">free</span>(arr4);<span class="built_in">free</span>(arr5);<span class="built_in">free</span>(arr6);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成大量重复元素数组 [0,10]</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\ntest generateRandomArray, size = %d, random range [0, %d]\n"</span>,n, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">int</span> *arr7 = generateRandomArray(n, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">int</span> *arr8 = copyArray(arr7, n);</span><br><span class="line">    <span class="keyword">int</span> *arr9 = copyArray(arr7, n);</span><br><span class="line">    testSort(arr7, n, <span class="string">"QuickSortOneWays1"</span>, QuickSortOneWays1);</span><br><span class="line">    testSort(arr8, n, <span class="string">"QuickSortTwoWays"</span>, QuickSortTwoWays);</span><br><span class="line">    testSort(arr9, n, <span class="string">"QuickSortThreeWays"</span>, QuickSortThreeWays);</span><br><span class="line">    <span class="built_in">free</span>(arr7);<span class="built_in">free</span>(arr8);<span class="built_in">free</span>(arr9);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong><code>Clion运行结果如下：</code></strong></p><div align="center" style="zoom: 80%; margin:  0px auto;"><img src="/2018/07/23/快速排序实现及优化/QuickSort20.png" alt=""></div><p>当我在把数据规模扩大<strong><code>10倍</code></strong>(把含有大量重复元素一路快排去掉)<strong><code>Clion运行结果如下：</code></strong></p><div align="center" style="zoom: 72%; margin:  0px auto;"><img src="/2018/07/23/快速排序实现及优化/QuickSort21.png" alt=""></div><h2 id="快速排序总结"><a href="#快速排序总结" class="headerlink" title="快速排序总结"></a>快速排序总结</h2><p><strong><code>总结：</code></strong> 当测试的规模<strong><code>n越大</code></strong>,在<strong><code>随机序列</code></strong>以及<strong><code>几乎有序</code></strong>的序列<strong><code>二路快速排序效率最高</code></strong>，在含有<strong><code>大量重复元素</code></strong>时，<strong><code>三路快速排序效率最高</code></strong>，<strong>二路快速次之</strong>，<strong>一路快速排序</strong>接近退化到<strong><code>O(N^2)</code></strong><br><strong><code>时间复杂度</code></strong>：<strong><code>O(Nlog2^N)</code></strong> 指的是平均时间复杂度<br><strong><code>空间复杂度</code></strong>：<strong><code>O(log2^N)</code></strong>      递归的深度为log2^N，系统栈需要压入log2^N种状态，需要空间O(log2^N),在快排过程种定义的left,right…,都是常数级需要空间O(1),总共耗费空间O(log2^N) * O(1)。<br><strong> <code>稳定性</code> </strong>：<strong><code>不稳定的</code></strong>   &nbsp;&nbsp;&nbsp; 元素关键字相等的两个元素进行比较时会发生交换，即<strong><code>相对位置会发生变化</code></strong><br>快速排序<strong><code>最坏的情况</code></strong>即基准每次是第一个元素，用因为是有序的，比基准小的元素没有，只有比基准大的元素，每次划分序列都近似于1和N-1，划分极度不均匀，像一个单链表，导致时间复杂度为<strong><code>O(N^2)</code></strong><br>快速排序<strong><code>最好的情况</code></strong>下当<strong><code>基准</code></strong>能把原序列换分成<strong><code>均匀</code></strong>的两个子序列时，每一次递归层次上比较的次数都是<strong><code>O(N)</code></strong>次，而递归的深度是 <strong><code>log2^N</code></strong> (每次都是将原始序列分一半，即一直除2)，时间复杂度应为<strong><code>O(Nlog2^N)</code></strong></p><p><strong><code>pS:</code></strong> <a href="https://github.com/XerDemo/Algorithm-Tour/tree/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/09_%E6%8E%92%E5%BA%8F/01-QuickSort" target="_blank" rel="noopener">相关源码链接</a></p>]]></content>
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C实现 </tag>
            
            <tag> 排序 </tag>
            
            <tag> 分治法，快速排序 </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
  
</search>
